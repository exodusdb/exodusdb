<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>exodus: mvipc_ms.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>mvipc_ms.cpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//#if defined(_WIN32) || defined(_WIN64)  || defined(_MINGW)</span>
<a name="l00002"></a>00002 <span class="preprocessor">#include &lt;exodus/mvconfig.h&gt;</span>
<a name="l00003"></a>00003 <span class="preprocessor">#ifdef EXODUS_IPC_WINPIPES</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span>
<a name="l00005"></a>00005 <span class="preprocessor">#ifndef DEBUG</span>
<a name="l00006"></a>00006 <span class="preprocessor"></span><span class="preprocessor">#define TRACING 0</span>
<a name="l00007"></a>00007 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span><span class="preprocessor">#define TRACING 5</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#define WIN32_LEAN_AND_MEAN</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span><span class="preprocessor">#include &lt;windows.h&gt;</span> 
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00015"></a>00015 <span class="comment">//#include &lt;tchar.h&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="comment">//</span>
<a name="l00019"></a>00019 <span class="comment">//#define MV_NO_NARROW</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#define EXODUS_IPC_EXTERN extern</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#include &lt;exodus/mvipc.h&gt;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="comment">//#include &quot;TConvert.h&quot;//for creation of LPTSTR</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="comment">//for documentation see end of file</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="comment">//allow deprecated mbstowcs instead of &quot;safe&quot; mbstowcs_s</span>
<a name="l00029"></a>00029 <span class="preprocessor">#pragma warning ( disable : 4995 4996)</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 <span class="comment">//for mingw</span>
<a name="l00032"></a>00032 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="preprocessor">#include &lt;strsafe.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#else</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="preprocessor">#include &lt;aclapi.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;ddk\ntifs.h&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#endif</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a>00039 <span class="comment">//actually limited to 256 characters long according to MS</span>
<a name="l00040"></a>00040 <span class="preprocessor">#define MAXPIPENAMESIZE 1024</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span>
<a name="l00042"></a>00042 <span class="preprocessor">#define CONNECTING_STATE 0 </span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#define READING_STATE 1 </span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#define WRITING_STATE 2 </span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="comment">//neosys only one instance</span>
<a name="l00046"></a>00046 <span class="comment">//#define INSTANCES 4 </span>
<a name="l00047"></a>00047 <span class="preprocessor">#define INSTANCES 1</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#define PIPE_TIMEOUT 5000</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#define BUFSIZE 1048576</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span> 
<a name="l00051"></a>00051 <span class="keyword">namespace </span>exodus
<a name="l00052"></a>00052 {
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">//open a pipe with the right environment</span>
<a name="l00055"></a>00055 <span class="comment">//to answer any requests from postgres server to evaluate data</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057 <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00058"></a>00058 {
<a name="l00059"></a>00059    OVERLAPPED oOverlap;
<a name="l00060"></a>00060    HANDLE hPipeInst;
<a name="l00061"></a>00061    TCHAR chRequest[BUFSIZE];
<a name="l00062"></a>00062    DWORD cbRead;
<a name="l00063"></a>00063    TCHAR chReply[BUFSIZE];
<a name="l00064"></a>00064    DWORD cbToWrite; 
<a name="l00065"></a>00065    DWORD dwState; 
<a name="l00066"></a>00066    BOOL fPendingIO; 
<a name="l00067"></a>00067 } PIPEINST, *LPPIPEINST; 
<a name="l00068"></a>00068  
<a name="l00069"></a>00069 VOID DisconnectAndReconnect(DWORD); 
<a name="l00070"></a>00070 BOOL ConnectToNewClient(HANDLE, LPOVERLAPPED); 
<a name="l00071"></a>00071  
<a name="l00072"></a>00072 PIPEINST Pipe[INSTANCES]; 
<a name="l00073"></a>00073 HANDLE hEvents[INSTANCES];
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <span class="keywordtype">int</span> MVipc(<span class="keyword">const</span> <span class="keywordtype">int</span> environmentn, var&amp; pgconnparams)
<a name="l00076"></a>00076 {
<a name="l00077"></a>00077 
<a name="l00078"></a>00078         <span class="comment">//TODO</span>
<a name="l00079"></a>00079 
<a name="l00080"></a>00080         <span class="comment">//flag to connectlocal NOT to be recursive and open yet another ipc thread</span>
<a name="l00081"></a>00081         tss_ipcstarted.reset(<span class="keyword">new</span> <span class="keywordtype">bool</span>(<span class="keyword">true</span>));
<a name="l00082"></a>00082 
<a name="l00083"></a>00083         <span class="comment">//clone the postgres connection because the parent thread is running a select with it</span>
<a name="l00084"></a>00084         <span class="keywordflow">if</span> (!var().connect(pgconnparams))
<a name="l00085"></a>00085         {
<a name="l00086"></a>00086                 <span class="keywordflow">throw</span> var(L<span class="stringliteral">&quot;MVipc Cannot connect additional thread to postgres&quot;</span>);
<a name="l00087"></a>00087                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00088"></a>00088         }
<a name="l00089"></a>00089         <span class="comment">//TODO prevent or handle SELECT in dictionary functions</span>
<a name="l00090"></a>00090 
<a name="l00091"></a>00091         <span class="comment">//set the threads environment number (same as and provided by the parent thread)</span>
<a name="l00092"></a>00092         <span class="comment">//AFTER opening the database connection</span>
<a name="l00093"></a>00093         setenvironmentn(environmentn);
<a name="l00094"></a>00094         
<a name="l00095"></a>00095         <span class="comment">//&quot;\\\\.\\pipe\\exoduspipexyz&quot;</span>
<a name="l00096"></a>00096         <span class="comment">//strings of MS tchars</span>
<a name="l00097"></a>00097         <span class="comment">//typedef basic_string&lt;TCHAR&gt; tstring;</span>
<a name="l00098"></a>00098         <span class="comment">//wchar_t* exoduspipename=&quot;\\\\.\\pipe\\exoduspipexyz&quot;;</span>
<a name="l00099"></a>00099         var exoduspipename=L<span class="stringliteral">&quot;\\\\.\\pipe\\exodusservice-&quot;</span>;
<a name="l00100"></a>00100         exoduspipename^= getprocessn()^<span class="stringliteral">&quot;.&quot;</span>^environmentn;
<a name="l00101"></a>00101         std::wstring wexoduspipename=exoduspipename.towstring();
<a name="l00102"></a>00102         LPTSTR lpszPipename = (LPTSTR) wexoduspipename.c_str();
<a name="l00103"></a>00103 
<a name="l00104"></a>00104         <span class="comment">//create a LPTSTR holding object that will automatically delete then LPTSTR when goes out of scope</span>
<a name="l00105"></a>00105 <span class="comment">//      _totchar texoduspipename(texoduspipename.towstring().c_str());</span>
<a name="l00106"></a>00106         <span class="comment">//mbstowcs(texoduspipename, (LPTSTR)exoduspipename.toString().c_str(), wcslen(exoduspipename.toString().c_str())+1);</span>
<a name="l00107"></a>00107         <span class="comment">//wcscpy(texoduspipename, (LPTSTR)exoduspipename.toString().c_str());</span>
<a name="l00108"></a>00108 
<a name="l00109"></a>00109         <span class="comment">// declare and initialize a security attributes structure</span>
<a name="l00110"></a>00110         SECURITY_ATTRIBUTES SA;
<a name="l00111"></a>00111         ZeroMemory( &amp;SA, <span class="keyword">sizeof</span>(SA) );
<a name="l00112"></a>00112         SA.nLength = <span class="keyword">sizeof</span>( SA );
<a name="l00113"></a>00113         SA.bInheritHandle = FALSE; <span class="comment">// object uninheritable</span>
<a name="l00114"></a>00114 
<a name="l00115"></a>00115         <span class="comment">// declare and initialize a security descriptor</span>
<a name="l00116"></a>00116         SECURITY_DESCRIPTOR SD;
<a name="l00117"></a>00117 
<a name="l00118"></a>00118         BOOL bInitOk = InitializeSecurityDescriptor( &amp;SD,
<a name="l00119"></a>00119                          SECURITY_DESCRIPTOR_REVISION );
<a name="l00120"></a>00120 
<a name="l00121"></a>00121         <span class="keywordflow">if</span> ( bInitOk )
<a name="l00122"></a>00122         {
<a name="l00123"></a>00123         <span class="comment">// give the security descriptor a Null Dacl</span>
<a name="l00124"></a>00124          <span class="comment">// done using the  &quot;TRUE, (PACL)NULL&quot; here</span>
<a name="l00125"></a>00125         BOOL bSetOk = SetSecurityDescriptorDacl( &amp;SD,
<a name="l00126"></a>00126                                             TRUE,
<a name="l00127"></a>00127                                             (PACL)NULL,
<a name="l00128"></a>00128                                             FALSE );
<a name="l00129"></a>00129                 <span class="keywordflow">if</span> (bSetOk)
<a name="l00130"></a>00130                 {
<a name="l00131"></a>00131 
<a name="l00132"></a>00132                         <span class="comment">// Make the security attributes point</span>
<a name="l00133"></a>00133                         <span class="comment">// to the security descriptor</span>
<a name="l00134"></a>00134                         SA.lpSecurityDescriptor = &amp;SD;
<a name="l00135"></a>00135 
<a name="l00136"></a>00136                 }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138         };
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 
<a name="l00141"></a>00141    DWORD i, dwWait, cbRet, dwErr; 
<a name="l00142"></a>00142    BOOL fSuccess;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="comment">// The initial loop creates several instances of a named pipe </span>
<a name="l00145"></a>00145 <span class="comment">// along with an event object for each instance.  An </span>
<a name="l00146"></a>00146 <span class="comment">// overlapped ConnectNamedPipe operation is started for </span>
<a name="l00147"></a>00147 <span class="comment">// each instance. </span>
<a name="l00148"></a>00148  
<a name="l00149"></a>00149    <span class="keywordflow">for</span> (i = 0; i &lt; INSTANCES; i++) 
<a name="l00150"></a>00150    { 
<a name="l00151"></a>00151  
<a name="l00152"></a>00152    <span class="comment">// Create an event object for this instance. </span>
<a name="l00153"></a>00153  
<a name="l00154"></a>00154       hEvents[i] = CreateEvent( 
<a name="l00155"></a>00155          NULL,    <span class="comment">// default security attribute </span>
<a name="l00156"></a>00156          TRUE,    <span class="comment">// manual-reset event </span>
<a name="l00157"></a>00157          TRUE,    <span class="comment">// initial state = signaled </span>
<a name="l00158"></a>00158          NULL);   <span class="comment">// unnamed event object </span>
<a name="l00159"></a>00159 
<a name="l00160"></a>00160       <span class="keywordflow">if</span> (hEvents[i] == NULL) 
<a name="l00161"></a>00161       {
<a name="l00162"></a>00162                   wprintf(L<span class="stringliteral">&quot;MVipc() CreateEvent failed. WIN32 Error: %d.\n&quot;</span>, GetLastError()); 
<a name="l00163"></a>00163          <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00164"></a>00164       }
<a name="l00165"></a>00165  
<a name="l00166"></a>00166       Pipe[i].oOverlap.hEvent = hEvents[i]; 
<a name="l00167"></a>00167  
<a name="l00168"></a>00168       Pipe[i].hPipeInst = CreateNamedPipe( 
<a name="l00169"></a>00169          lpszPipename,            <span class="comment">// pipe name </span>
<a name="l00170"></a>00170          PIPE_ACCESS_DUPLEX |     <span class="comment">// read/write access </span>
<a name="l00171"></a>00171          FILE_FLAG_OVERLAPPED,    <span class="comment">// overlapped mode </span>
<a name="l00172"></a>00172          PIPE_TYPE_MESSAGE |      <span class="comment">// message-type pipe </span>
<a name="l00173"></a>00173          PIPE_READMODE_MESSAGE |  <span class="comment">// message-read mode </span>
<a name="l00174"></a>00174          PIPE_WAIT,               <span class="comment">// blocking mode </span>
<a name="l00175"></a>00175          INSTANCES,               <span class="comment">// number of instances </span>
<a name="l00176"></a>00176          BUFSIZE*<span class="keyword">sizeof</span>(TCHAR),   <span class="comment">// output buffer size </span>
<a name="l00177"></a>00177          BUFSIZE*<span class="keyword">sizeof</span>(TCHAR),   <span class="comment">// input buffer size </span>
<a name="l00178"></a>00178          PIPE_TIMEOUT,            <span class="comment">// client time-out </span>
<a name="l00179"></a>00179         &amp;SA);
<a name="l00180"></a>00180 
<a name="l00181"></a>00181         <span class="keywordflow">if</span> (Pipe[i].hPipeInst == INVALID_HANDLE_VALUE) 
<a name="l00182"></a>00182         {
<a name="l00183"></a>00183                 <span class="keywordflow">if</span> (GetLastError()==231)
<a name="l00184"></a>00184                 {
<a name="l00185"></a>00185                         wprintf(L<span class="stringliteral">&quot;MVipc() CreateNamedPipe failed because pipe %s is busy. Is another server running?&quot;</span>,lpszPipename);
<a name="l00186"></a>00186                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00187"></a>00187                 }
<a name="l00188"></a>00188                 wprintf(L<span class="stringliteral">&quot;MVipc() CreateNamedPipe %s failed. WIN32 Error: %d.\n&quot;</span>, lpszPipename, GetLastError());
<a name="l00189"></a>00189                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00190"></a>00190         }
<a name="l00191"></a>00191         <span class="keywordflow">else</span>
<a name="l00192"></a>00192 <span class="preprocessor">#if TRACING &gt;= 1</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span>                wprintf(L<span class="stringliteral">&quot;MVipc() CreateNamedPipe %s succeeded\n&quot;</span>, lpszPipename);
<a name="l00194"></a>00194 <span class="preprocessor">#endif </span>
<a name="l00195"></a>00195 <span class="preprocessor"></span>   <span class="comment">// Call the subroutine to connect to the new client</span>
<a name="l00196"></a>00196  
<a name="l00197"></a>00197       Pipe[i].fPendingIO = ConnectToNewClient( 
<a name="l00198"></a>00198          Pipe[i].hPipeInst, 
<a name="l00199"></a>00199          &amp;Pipe[i].oOverlap); 
<a name="l00200"></a>00200  
<a name="l00201"></a>00201       Pipe[i].dwState = Pipe[i].fPendingIO ? 
<a name="l00202"></a>00202          CONNECTING_STATE : <span class="comment">// still connecting </span>
<a name="l00203"></a>00203          READING_STATE;     <span class="comment">// ready to read </span>
<a name="l00204"></a>00204    } 
<a name="l00205"></a>00205  
<a name="l00206"></a>00206         <span class="comment">//indicate to waiting/paused parent thread that the pipe is open</span>
<a name="l00207"></a>00207         <span class="comment">//(the pipe is not actually waiting until the next step)</span>
<a name="l00208"></a>00208         <span class="comment">//scoped so that the scoped_lock is automatically released after the notification</span>
<a name="l00209"></a>00209         {
<a name="l00210"></a>00210                 boost::mutex::scoped_lock lock(global_ipcmutex);
<a name="l00211"></a>00211 <span class="preprocessor">#if TRACING &gt;= 1</span>
<a name="l00212"></a>00212 <span class="preprocessor"></span>                std::cout&lt;&lt;L<span class="stringliteral">&quot;MVipc() Notifying that pipe has been opened\n&quot;</span>;
<a name="l00213"></a>00213 <span class="preprocessor">#endif</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span>                <span class="comment">//TODO make sure notifies CORRECT parent thread by using an array of ipcmutexes and tss_environmentn</span>
<a name="l00215"></a>00215                 global_ipccondition.notify_one();
<a name="l00216"></a>00216 <span class="preprocessor">#if TRACING &gt;= 1</span>
<a name="l00217"></a>00217 <span class="preprocessor"></span>                std::wcout&lt;&lt;L<span class="stringliteral">&quot;MVipc() Notified that pipe has been opened\n&quot;</span>;
<a name="l00218"></a>00218 <span class="preprocessor">#endif</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span>        }
<a name="l00220"></a>00220 
<a name="l00221"></a>00221    <span class="keywordflow">while</span> (1) 
<a name="l00222"></a>00222    { 
<a name="l00223"></a>00223    <span class="comment">// Wait for the event object to be signaled, indicating </span>
<a name="l00224"></a>00224    <span class="comment">// completion of an overlapped read, write, or </span>
<a name="l00225"></a>00225    <span class="comment">// connect operation. </span>
<a name="l00226"></a>00226  
<a name="l00227"></a>00227       dwWait = WaitForMultipleObjects( 
<a name="l00228"></a>00228          INSTANCES,    <span class="comment">// number of event objects </span>
<a name="l00229"></a>00229          hEvents,      <span class="comment">// array of event objects </span>
<a name="l00230"></a>00230          FALSE,        <span class="comment">// does not wait for all </span>
<a name="l00231"></a>00231          INFINITE);    <span class="comment">// waits indefinitely </span>
<a name="l00232"></a>00232  
<a name="l00233"></a>00233    <span class="comment">// dwWait shows which pipe completed the operation. </span>
<a name="l00234"></a>00234  
<a name="l00235"></a>00235       i = dwWait - WAIT_OBJECT_0;  <span class="comment">// determines which pipe </span>
<a name="l00236"></a>00236       <span class="keywordflow">if</span> (i &lt; 0 || i &gt; (INSTANCES - 1)) 
<a name="l00237"></a>00237       {
<a name="l00238"></a>00238          wprintf(L<span class="stringliteral">&quot;MVipc() Index out of range.\n&quot;</span>); 
<a name="l00239"></a>00239          <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00240"></a>00240       }
<a name="l00241"></a>00241  
<a name="l00242"></a>00242    <span class="comment">// Get the result if the operation was pending. </span>
<a name="l00243"></a>00243  
<a name="l00244"></a>00244       <span class="keywordflow">if</span> (Pipe[i].fPendingIO) 
<a name="l00245"></a>00245       { 
<a name="l00246"></a>00246          fSuccess = GetOverlappedResult( 
<a name="l00247"></a>00247             Pipe[i].hPipeInst, <span class="comment">// handle to pipe </span>
<a name="l00248"></a>00248             &amp;Pipe[i].oOverlap, <span class="comment">// OVERLAPPED structure </span>
<a name="l00249"></a>00249             &amp;cbRet,            <span class="comment">// bytes transferred </span>
<a name="l00250"></a>00250             FALSE);            <span class="comment">// do not wait </span>
<a name="l00251"></a>00251  
<a name="l00252"></a>00252          <span class="keywordflow">switch</span> (Pipe[i].dwState) 
<a name="l00253"></a>00253          { 
<a name="l00254"></a>00254                         <span class="comment">// Pending connect operation </span>
<a name="l00255"></a>00255             <span class="keywordflow">case</span> CONNECTING_STATE: 
<a name="l00256"></a>00256                <span class="keywordflow">if</span> (! fSuccess) 
<a name="l00257"></a>00257                {
<a name="l00258"></a>00258                    wprintf(L<span class="stringliteral">&quot;MVipc() CONNECTING STATE WIN32 Error %d.\n&quot;</span>, GetLastError()); 
<a name="l00259"></a>00259                    <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00260"></a>00260                }
<a name="l00261"></a>00261                Pipe[i].dwState = READING_STATE; 
<a name="l00262"></a>00262                <span class="keywordflow">break</span>;
<a name="l00263"></a>00263  
<a name="l00264"></a>00264                         <span class="comment">// Pending read operation</span>
<a name="l00265"></a>00265             <span class="keywordflow">case</span> READING_STATE: 
<a name="l00266"></a>00266                <span class="keywordflow">if</span> (! fSuccess || cbRet == 0) 
<a name="l00267"></a>00267                { 
<a name="l00268"></a>00268                   DisconnectAndReconnect(i); 
<a name="l00269"></a>00269                   <span class="keywordflow">continue</span>; 
<a name="l00270"></a>00270                } 
<a name="l00271"></a>00271                Pipe[i].dwState = WRITING_STATE; 
<a name="l00272"></a>00272                <span class="keywordflow">break</span>; 
<a name="l00273"></a>00273  
<a name="l00274"></a>00274                         <span class="comment">// Pending write operation </span>
<a name="l00275"></a>00275             <span class="keywordflow">case</span> WRITING_STATE: 
<a name="l00276"></a>00276                <span class="keywordflow">if</span> (! fSuccess || cbRet != Pipe[i].cbToWrite) 
<a name="l00277"></a>00277                { 
<a name="l00278"></a>00278                   DisconnectAndReconnect(i); 
<a name="l00279"></a>00279                   <span class="keywordflow">continue</span>; 
<a name="l00280"></a>00280                } 
<a name="l00281"></a>00281                Pipe[i].dwState = READING_STATE; 
<a name="l00282"></a>00282                <span class="keywordflow">break</span>; 
<a name="l00283"></a>00283  
<a name="l00284"></a>00284             <span class="keywordflow">default</span>: 
<a name="l00285"></a>00285                wprintf(L<span class="stringliteral">&quot;MVipc() (1) Invalid pipe state %d\n&quot;</span>, Pipe[i].dwState); 
<a name="l00286"></a>00286                <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00287"></a>00287          }  
<a name="l00288"></a>00288       } 
<a name="l00289"></a>00289  
<a name="l00290"></a>00290         <span class="comment">// The pipe state determines which operation to do next. </span>
<a name="l00291"></a>00291         std::string response;
<a name="l00292"></a>00292  
<a name="l00293"></a>00293       <span class="keywordflow">switch</span> (Pipe[i].dwState) 
<a name="l00294"></a>00294       { 
<a name="l00295"></a>00295       <span class="comment">// READING_STATE: </span>
<a name="l00296"></a>00296       <span class="comment">// The pipe instance is connected to the client </span>
<a name="l00297"></a>00297       <span class="comment">// and is ready to read a request from the client. </span>
<a name="l00298"></a>00298  
<a name="l00299"></a>00299          <span class="keywordflow">case</span> READING_STATE: 
<a name="l00300"></a>00300             fSuccess = ReadFile( 
<a name="l00301"></a>00301                Pipe[i].hPipeInst, 
<a name="l00302"></a>00302                Pipe[i].chRequest, 
<a name="l00303"></a>00303                BUFSIZE*<span class="keyword">sizeof</span>(TCHAR), 
<a name="l00304"></a>00304                &amp;Pipe[i].cbRead, 
<a name="l00305"></a>00305                &amp;Pipe[i].oOverlap); 
<a name="l00306"></a>00306 
<a name="l00307"></a>00307                         <span class="comment">// The read operation completed successfully.</span>
<a name="l00308"></a>00308             <span class="keywordflow">if</span> (fSuccess &amp;&amp; Pipe[i].cbRead != 0) 
<a name="l00309"></a>00309             { 
<a name="l00310"></a>00310 <span class="preprocessor">#if TRACING &gt;= 3</span>
<a name="l00311"></a>00311 <span class="preprocessor"></span>wprintf(L<span class="stringliteral">&quot;---------------------------------\nMVipc() read  %d bytes from pipe\n&quot;</span>,Pipe[i].cbRead);
<a name="l00312"></a>00312 <span class="preprocessor">#endif</span>
<a name="l00313"></a>00313 <span class="preprocessor"></span>               Pipe[i].fPendingIO = FALSE; 
<a name="l00314"></a>00314                Pipe[i].dwState = WRITING_STATE; 
<a name="l00315"></a>00315                <span class="keywordflow">continue</span>; 
<a name="l00316"></a>00316             } 
<a name="l00317"></a>00317  
<a name="l00318"></a>00318                         <span class="comment">// The read operation is still pending. </span>
<a name="l00319"></a>00319             dwErr = GetLastError(); 
<a name="l00320"></a>00320             <span class="keywordflow">if</span> (! fSuccess &amp;&amp; (dwErr == ERROR_IO_PENDING)) 
<a name="l00321"></a>00321             { 
<a name="l00322"></a>00322                Pipe[i].fPendingIO = TRUE; 
<a name="l00323"></a>00323                <span class="keywordflow">continue</span>; 
<a name="l00324"></a>00324             } 
<a name="l00325"></a>00325  
<a name="l00326"></a>00326                         <span class="comment">// An error occurred; disconnect from the client.</span>
<a name="l00327"></a>00327             DisconnectAndReconnect(i); 
<a name="l00328"></a>00328             <span class="keywordflow">break</span>; 
<a name="l00329"></a>00329  
<a name="l00330"></a>00330                 <span class="comment">// WRITING_STATE: </span>
<a name="l00331"></a>00331                 <span class="comment">// The request was successfully read from the client. </span>
<a name="l00332"></a>00332                 <span class="comment">// Get the reply data and write it to the client. </span>
<a name="l00333"></a>00333                 <span class="keywordflow">case</span> WRITING_STATE: 
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 <span class="comment">//neosys CLOSE PIPE MESSAGE</span>
<a name="l00336"></a>00336                          <span class="keywordflow">if</span> (0==lstrcmp(Pipe[i].chReply,L<span class="stringliteral">&quot;NEOSYS_CLOSE_THIS_PIPE&quot;</span>))
<a name="l00337"></a>00337 <span class="comment">//                       if (0==lstrcmp(Pipe[i].chReply,TEXT(L&quot;&quot;)))</span>
<a name="l00338"></a>00338                          {
<a name="l00339"></a>00339                                  <span class="keywordflow">return</span> 0;
<a name="l00340"></a>00340                          }
<a name="l00341"></a>00341 
<a name="l00342"></a>00342                         getResponseToRequest((<span class="keywordtype">char</span>*)Pipe[i].chRequest, (<span class="keywordtype">size_t</span>) Pipe[i].cbRead, BUFSIZ*<span class="keyword">sizeof</span>(TCHAR), response);
<a name="l00343"></a>00343         <span class="comment">/*</span>
<a name="l00344"></a>00344 <span class="comment">                        //bytes to write to pipe</span>
<a name="l00345"></a>00345 <span class="comment">                        memcpy(pipe-&gt;chReply,reply.towstring().data(),nbytes);</span>
<a name="l00346"></a>00346 <span class="comment">                        //number of bytes to write to pipe</span>
<a name="l00347"></a>00347 <span class="comment">                        pipe-&gt;cbToWrite=int(reply.length())*sizeof(TCHAR);</span>
<a name="l00348"></a>00348 <span class="comment">        */</span>
<a name="l00349"></a>00349 
<a name="l00350"></a>00350                         <span class="comment">//bytes to write to pipe</span>
<a name="l00351"></a>00351                         memcpy(Pipe[i].chReply,response.data(),response.length());
<a name="l00352"></a>00352                         <span class="comment">//number of bytes to write to pipe</span>
<a name="l00353"></a>00353                         Pipe[i].cbToWrite=int(response.length());
<a name="l00354"></a>00354 
<a name="l00355"></a>00355             fSuccess = WriteFile( 
<a name="l00356"></a>00356                Pipe[i].hPipeInst, 
<a name="l00357"></a>00357                Pipe[i].chReply, 
<a name="l00358"></a>00358                Pipe[i].cbToWrite, 
<a name="l00359"></a>00359                &amp;cbRet, 
<a name="l00360"></a>00360                &amp;Pipe[i].oOverlap); 
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="preprocessor">#if TRACING &gt;= 3</span>
<a name="l00363"></a>00363 <span class="preprocessor"></span><span class="comment">//wprintf(L&quot;MVipc() wrote %d bytes &lt;- \&quot;%s\&quot;\n&quot;,Pipe[i].cbToWrite, Pipe[i].chReply);</span>
<a name="l00364"></a>00364 wprintf(L<span class="stringliteral">&quot;MVipc() wrote %d bytes &lt;- \&quot;%s\&quot;\n&quot;</span>,Pipe[i].cbToWrite, Pipe[i].chReply);
<a name="l00365"></a>00365 <span class="preprocessor">#endif</span>
<a name="l00366"></a>00366 <span class="preprocessor"></span>                        <span class="comment">// The write operation completed successfully. </span>
<a name="l00367"></a>00367                         <span class="keywordflow">if</span> (fSuccess &amp;&amp; cbRet == Pipe[i].cbToWrite) 
<a name="l00368"></a>00368                         { 
<a name="l00369"></a>00369                Pipe[i].fPendingIO = FALSE; 
<a name="l00370"></a>00370                Pipe[i].dwState = READING_STATE; 
<a name="l00371"></a>00371                <span class="keywordflow">continue</span>; 
<a name="l00372"></a>00372             } 
<a name="l00373"></a>00373  
<a name="l00374"></a>00374                         <span class="comment">// The write operation is still pending.</span>
<a name="l00375"></a>00375             dwErr = GetLastError(); 
<a name="l00376"></a>00376             <span class="keywordflow">if</span> (! fSuccess &amp;&amp; (dwErr == ERROR_IO_PENDING)) 
<a name="l00377"></a>00377             { 
<a name="l00378"></a>00378                Pipe[i].fPendingIO = TRUE; 
<a name="l00379"></a>00379                <span class="keywordflow">continue</span>; 
<a name="l00380"></a>00380             } 
<a name="l00381"></a>00381  
<a name="l00382"></a>00382                         <span class="comment">// An error occurred; disconnect from the client.</span>
<a name="l00383"></a>00383 wprintf(L<span class="stringliteral">&quot;MVipc() An error occurred; disconnect and reconnect to the client.&quot;</span>);
<a name="l00384"></a>00384             DisconnectAndReconnect(i); 
<a name="l00385"></a>00385             <span class="keywordflow">break</span>; 
<a name="l00386"></a>00386  
<a name="l00387"></a>00387          <span class="keywordflow">default</span>: 
<a name="l00388"></a>00388             wprintf(L<span class="stringliteral">&quot;MVipc() (2) Invalid pipe state.\n&quot;</span>); 
<a name="l00389"></a>00389             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00390"></a>00390       } 
<a name="l00391"></a>00391   }
<a name="l00392"></a>00392  
<a name="l00393"></a>00393   <span class="keywordflow">return</span> 0;
<a name="l00394"></a>00394 }
<a name="l00395"></a>00395  
<a name="l00396"></a>00396 <span class="comment">// DisconnectAndReconnect(DWORD) </span>
<a name="l00397"></a>00397 <span class="comment">// This function is called when an error occurs or when the client </span>
<a name="l00398"></a>00398 <span class="comment">// closes its handle to the pipe. Disconnect from this client, then </span>
<a name="l00399"></a>00399 <span class="comment">// call ConnectNamedPipe to wait for another client to connect. </span>
<a name="l00400"></a>00400  
<a name="l00401"></a>00401 VOID DisconnectAndReconnect(DWORD i) 
<a name="l00402"></a>00402 { 
<a name="l00403"></a>00403 <span class="comment">// Disconnect the pipe instance. </span>
<a name="l00404"></a>00404  
<a name="l00405"></a>00405    <span class="keywordflow">if</span> (! DisconnectNamedPipe(Pipe[i].hPipeInst) ) 
<a name="l00406"></a>00406    {
<a name="l00407"></a>00407       wprintf(L<span class="stringliteral">&quot;MVipc-DisconnectAndReconnect() DisconnectNamedPipe failed with %d.\n&quot;</span>, GetLastError());
<a name="l00408"></a>00408    }
<a name="l00409"></a>00409  
<a name="l00410"></a>00410 <span class="comment">// Call a subroutine to connect to the new client. </span>
<a name="l00411"></a>00411  
<a name="l00412"></a>00412    Pipe[i].fPendingIO = ConnectToNewClient( 
<a name="l00413"></a>00413       Pipe[i].hPipeInst, 
<a name="l00414"></a>00414       &amp;Pipe[i].oOverlap); 
<a name="l00415"></a>00415  
<a name="l00416"></a>00416    Pipe[i].dwState = Pipe[i].fPendingIO ? 
<a name="l00417"></a>00417       CONNECTING_STATE : <span class="comment">// still connecting </span>
<a name="l00418"></a>00418       READING_STATE;     <span class="comment">// ready to read </span>
<a name="l00419"></a>00419 } 
<a name="l00420"></a>00420  
<a name="l00421"></a>00421 <span class="comment">// ConnectToNewClient(HANDLE, LPOVERLAPPED) </span>
<a name="l00422"></a>00422 <span class="comment">// This function is called to start an overlapped connect operation. </span>
<a name="l00423"></a>00423 <span class="comment">// It returns TRUE if an operation is pending or FALSE if the </span>
<a name="l00424"></a>00424 <span class="comment">// connection has been completed. </span>
<a name="l00425"></a>00425  
<a name="l00426"></a>00426 BOOL ConnectToNewClient(HANDLE hPipe, LPOVERLAPPED lpo) 
<a name="l00427"></a>00427 { 
<a name="l00428"></a>00428    BOOL fConnected, fPendingIO = FALSE; 
<a name="l00429"></a>00429  
<a name="l00430"></a>00430 <span class="comment">// Start an overlapped connection for this pipe instance. </span>
<a name="l00431"></a>00431    fConnected = ConnectNamedPipe(hPipe, lpo); 
<a name="l00432"></a>00432  
<a name="l00433"></a>00433 <span class="comment">// Overlapped ConnectNamedPipe should return zero. </span>
<a name="l00434"></a>00434    <span class="keywordflow">if</span> (fConnected) 
<a name="l00435"></a>00435    {
<a name="l00436"></a>00436       wprintf(L<span class="stringliteral">&quot;MVipc-ConnectToNewClient() (1) ConnectNamedPipe failed. WIN32 Error %d.\n&quot;</span>, GetLastError()); 
<a name="l00437"></a>00437       <span class="keywordflow">return</span> 0;
<a name="l00438"></a>00438    }
<a name="l00439"></a>00439  
<a name="l00440"></a>00440    <span class="keywordflow">switch</span> (GetLastError()) 
<a name="l00441"></a>00441    {
<a name="l00442"></a>00442                 <span class="comment">// The overlapped connection in progress. </span>
<a name="l00443"></a>00443                 <span class="keywordflow">case</span> ERROR_IO_PENDING: 
<a name="l00444"></a>00444          fPendingIO = TRUE; 
<a name="l00445"></a>00445          <span class="keywordflow">break</span>; 
<a name="l00446"></a>00446  
<a name="l00447"></a>00447                 <span class="comment">// Client is already connected, so signal an event. </span>
<a name="l00448"></a>00448                 <span class="keywordflow">case</span> ERROR_PIPE_CONNECTED: 
<a name="l00449"></a>00449                         <span class="keywordflow">if</span> (SetEvent(lpo-&gt;hEvent)) 
<a name="l00450"></a>00450                                 <span class="keywordflow">break</span>; 
<a name="l00451"></a>00451  
<a name="l00452"></a>00452                 <span class="comment">// If an error occurs during the connect operation... </span>
<a name="l00453"></a>00453                 <span class="keywordflow">default</span>: 
<a name="l00454"></a>00454          wprintf(L<span class="stringliteral">&quot;MVipc-ConnectToNewClient() (2) ConnectNamedPipe failed. WIN32 Error %d.\n&quot;</span>, GetLastError());
<a name="l00455"></a>00455          <span class="keywordflow">return</span> 0;
<a name="l00456"></a>00456    }
<a name="l00457"></a>00457  
<a name="l00458"></a>00458    <span class="keywordflow">return</span> fPendingIO; 
<a name="l00459"></a>00459 }
<a name="l00460"></a>00460 
<a name="l00461"></a>00461 <span class="comment">/* from http://msdn2.microsoft.com/EN-US/library/aa365603.aspx</span>
<a name="l00462"></a>00462 <span class="comment"></span>
<a name="l00463"></a>00463 <span class="comment">Named Pipe Server Using Overlapped I/O</span>
<a name="l00464"></a>00464 <span class="comment"></span>
<a name="l00465"></a>00465 <span class="comment">The following is an example of a single-threaded pipe server that uses overlapped operations to service simultaneous connections to multiple pipe clients. The pipe server creates a fixed number of pipe instances. Each pipe instance can be connected to a separate pipe client. When a pipe client has finished using its pipe instance, the server disconnects from the client and reuses the pipe instance to connect to a new client. This pipe server can be used with the pipe client described in Named Pipe Client.</span>
<a name="l00466"></a>00466 <span class="comment"></span>
<a name="l00467"></a>00467 <span class="comment">The OVERLAPPED structure is specified as a parameter in each ReadFile, WriteFile, and ConnectNamedPipe operation on the pipe instance. Although the example shows simultaneous operations on different pipe instances, it avoids simultaneous operations on a single pipe instance by using the event object in the OVERLAPPED structure. Because the same event object is used for read, write, and connect operations for each instance, there is no way to know which operation&#39;s completion caused the event to be set to the signaled state for simultaneous operations using the same pipe instance.</span>
<a name="l00468"></a>00468 <span class="comment"></span>
<a name="l00469"></a>00469 <span class="comment">The event handles for each pipe instance are stored in an array that is passed to the WaitForMultipleObjects function. This function waits for one of the events to be signaled, and returns the array index of the event that caused the wait operation to complete. The example in this topic uses this array index to retrieve a structure containing information for the pipe instance. The server uses the fPendingIO member of the structure to keep track of whether the most recent I/O operation on the instance was pending, which requires a call to the GetOverlappedResult function. The server uses the dwState member of the structure to determine the next operation that must be performed for the pipe instance.</span>
<a name="l00470"></a>00470 <span class="comment"></span>
<a name="l00471"></a>00471 <span class="comment">Overlapped ReadFile, WriteFile, and ConnectNamedPipe operations can finish by the time the function returns. Otherwise, if the operation is pending, the event object in the specified OVERLAPPED structure is set to the nonsignaled state before the function returns. When the pending operation finishes, the system sets the state of the event object to signaled. The state of the event object is not changed if the operation finishes before the function returns.</span>
<a name="l00472"></a>00472 <span class="comment"></span>
<a name="l00473"></a>00473 <span class="comment">Because the example uses manual-reset event objects, the state of an event object is not changed to nonsignaled by the WaitForMultipleObjects function. This is important, because the example relies on the event objects remaining in the signaled state, except when there is a pending operation.</span>
<a name="l00474"></a>00474 <span class="comment"></span>
<a name="l00475"></a>00475 <span class="comment">If the operation has already finished when ReadFile, WriteFile, or ConnectNamedPipe returns, the function&#39;s return value indicates the result. For read and write operations, the number of bytes transferred is also returned. If the operation is still pending, the ReadFile, WriteFile, or ConnectNamedPipe function returns zero and the GetLastError function returns ERROR_IO_PENDING. In this case, use the GetOverlappedResult function to retrieve the results after the operation has finished. GetOverlappedResult returns only the results of pending operations. It does not report the results of operations that were completed before the overlapped ReadFile, WriteFile, or ConnectNamedPipe function returned.</span>
<a name="l00476"></a>00476 <span class="comment"></span>
<a name="l00477"></a>00477 <span class="comment">Before disconnecting from a client, you must wait for a signal indicating the client has finished. (Flushing the file buffers would defeat the purpose of overlapped I/O, because the flush operation would block the execution of the server thread while it waits for the client to empty the pipe.) In this example, the signal is the error generated by trying to read from the pipe after the pipe client closes its handle.</span>
<a name="l00478"></a>00478 <span class="comment"></span>
<a name="l00479"></a>00479 <span class="comment">*/</span>
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 }<span class="comment">//of namespace neo</span>
<a name="l00482"></a>00482 
<a name="l00483"></a>00483 <span class="preprocessor">#endif //EXODUS_IPC_WINPIPES</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sun Sep 12 2010 01:29:12 for exodus by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
