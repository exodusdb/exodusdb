<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>exodus: mvdbpostgres.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>mvdbpostgres.cpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">Copyright (c) 2009 Stephen John Bush</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<a name="l00005"></a>00005 <span class="comment">of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<a name="l00006"></a>00006 <span class="comment">in the Software without restriction, including without limitation the rights</span>
<a name="l00007"></a>00007 <span class="comment">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<a name="l00008"></a>00008 <span class="comment">copies of the Software, and to permit persons to whom the Software is</span>
<a name="l00009"></a>00009 <span class="comment">furnished to do so, subject to the following conditions:</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">The above copyright notice and this permission notice shall be included in</span>
<a name="l00012"></a>00012 <span class="comment">all copies or substantial portions of the Software.</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<a name="l00015"></a>00015 <span class="comment">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<a name="l00016"></a>00016 <span class="comment">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<a name="l00017"></a>00017 <span class="comment">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<a name="l00018"></a>00018 <span class="comment">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<a name="l00019"></a>00019 <span class="comment">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span>
<a name="l00020"></a>00020 <span class="comment">THE SOFTWARE.</span>
<a name="l00021"></a>00021 <span class="comment">*/</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">//http://www.postgresql.org/docs/8.3/static/libpq-envars.html</span>
<a name="l00024"></a>00024 <span class="comment">//PGHOST/PGHOSTADDR</span>
<a name="l00025"></a>00025 <span class="comment">//PGPORT</span>
<a name="l00026"></a>00026 <span class="comment">//PGDATABASE</span>
<a name="l00027"></a>00027 <span class="comment">//PGUSER</span>
<a name="l00028"></a>00028 <span class="comment">//PGPASSWORD</span>
<a name="l00029"></a>00029 <span class="comment">//PGPASSFILE defaults to ~/.pgpass</span>
<a name="l00030"></a>00030 <span class="comment">//PGSERVICE in pg_service.conf in PGSYSCONFDIR</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="comment">//0=silent, 1=errors, 2=warnings, 3=results, 4=tracing, 5=debugging</span>
<a name="l00033"></a>00033 <span class="comment">//0=silent, 1=errors, 2=warnings, 3=failures, 4=successes, 5=debugging ?</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="comment">//MSVC requires exception handling (eg compile with /EHsc or EHa?) for delayed dll loading detection</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="preprocessor">#ifndef DEBUG</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#define TRACING 0</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#define TRACING 5</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 <span class="preprocessor">#if defined _MSC_VER // || defined __CYGWIN__ || defined __MINGW32__</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">        #define WIN32_LEAN_AND_MEAN</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">        #include &lt;windows.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">        #include &lt;DelayImp.h&gt;</span>
<a name="l00047"></a>00047         <span class="comment">//doesnt seem to work, add them to visual studio project delayload section using semicolons or special linker options</span>
<a name="l00048"></a>00048         <span class="comment">//#pragma comment(linker, &quot;/DelayLoad:libpq.dll&quot;)</span>
<a name="l00049"></a>00049 <span class="preprocessor">#else</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>        <span class="comment">//#define __try try</span>
<a name="l00051"></a>00051         <span class="comment">//#define __except catch</span>
<a name="l00052"></a>00052 <span class="preprocessor">#endif</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="preprocessor">#pragma warning (disable: 4150)</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="comment">//warning C4150: deletion of pointer to incomplete type &#39;pg_conn&#39;; no destructor called</span>
<a name="l00056"></a>00056 <span class="comment">//see declaration of &#39;pg_conn&#39;</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="comment">//C4530: C++ exception handler used, but unwind semantics are not enabled. </span>
<a name="l00059"></a>00059 <span class="preprocessor">#pragma warning (disable: 4530)</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &lt;cstring&gt;</span><span class="comment">//for strcmp strlen</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="preprocessor">#include &lt;boost/thread/tss.hpp&gt;</span>
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="comment">//see exports.txt for a list of all PQ functions</span>
<a name="l00067"></a>00067 <span class="comment">//#include &lt;postgresql/libpq-fe.h&gt;//in postgres/include</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &lt;libpq-fe.h&gt;</span><span class="comment">//in postgres/include</span>
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="preprocessor">#define MV_NO_NARROW</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>
<a name="l00072"></a>00072 <span class="preprocessor">#include &lt;exodus/mvimpl.h&gt;</span>
<a name="l00073"></a>00073 <span class="preprocessor">#include &lt;exodus/mv.h&gt;</span>
<a name="l00074"></a>00074 <span class="preprocessor">#include &lt;exodus/mvenvironment.h&gt;</span>
<a name="l00075"></a>00075 <span class="preprocessor">#include &lt;exodus/mvutf.h&gt;</span>
<a name="l00076"></a>00076 <span class="preprocessor">#include &lt;exodus/mvexceptions.h&gt;</span>
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="preprocessor">#if TRACING &gt;= 5</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">        #define DEBUG_LOG_SQL exodus::errputln(L&quot;SQL:&quot; ^ sql);</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">        #define DEBUG_LOG_SQL1 exodus::errputln(L&quot;SQL:&quot; ^ sql.swap(L&quot;$1&quot;,var(paramValues[0])));</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">        #define DEBUG_LOG_SQL</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor">        #define DEBUG_LOG_SQL1</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span>
<a name="l00086"></a>00086 <span class="keyword">namespace </span>exodus {
<a name="l00087"></a>00087 
<a name="l00088"></a>00088 <span class="keywordtype">bool</span> startipc();
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="comment">//#define PGDATAFILEPREFIX &quot;data_&quot;</span>
<a name="l00091"></a>00091 <span class="preprocessor">#define PGDATAFILEPREFIX L&quot;&quot;</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span>
<a name="l00093"></a>00093 <span class="comment">//this front end C interface is based on postgres</span>
<a name="l00094"></a>00094 <span class="comment">//http://www.postgresql.org/docs/8.2/static/libpq-exec.html</span>
<a name="l00095"></a>00095 <span class="comment">//doc/postgres/libpq-example.html</span>
<a name="l00096"></a>00096 <span class="comment">//src/test/examples/testlibpq.c</span>
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="comment">//(backend pg functions extract and dateextract are based</span>
<a name="l00099"></a>00099 <span class="comment">// on samples in src/tutorial/funcs_new.c)</span>
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="comment">//SQL EXAMPLES</span>
<a name="l00102"></a>00102 <span class="comment">//create or replace view testview as select exodus_extract_bytea(data,1,0,0) as field1 from test;</span>
<a name="l00103"></a>00103 <span class="comment">//create index testfield1 on test (exodus_extract_bytea(data,1,0,0));</span>
<a name="l00104"></a>00104 <span class="comment">//select * from testview where field1  &gt; &#39;aaaaaaaaa&#39;;</span>
<a name="l00105"></a>00105 <span class="comment">//analyse;</span>
<a name="l00106"></a>00106 <span class="comment">//explain select * from testview where field1  &gt; &#39;aaaaaaaaa&#39;;</span>
<a name="l00107"></a>00107 <span class="comment">//explain analyse select * from testview where field1  &gt; &#39;aaaaaaaaa&#39;;e</span>
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="comment">//#include &lt;pg_type.h&gt;</span>
<a name="l00110"></a>00110 <span class="preprocessor">#define BYTEAOID 17;</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span><span class="preprocessor">#define TEXTOID 25;</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 <span class="comment">//this is not threadsafe</span>
<a name="l00115"></a>00115 <span class="comment">//PGconn     *thread_pgconn;</span>
<a name="l00116"></a>00116 <span class="comment">//but this is ...</span>
<a name="l00117"></a>00117 boost::thread_specific_ptr&lt;PGconn&gt; tss_pgconns;
<a name="l00118"></a>00118 boost::thread_specific_ptr&lt;var&gt; tss_pgconnparams;
<a name="l00119"></a>00119 boost::thread_specific_ptr&lt;bool&gt; tss_ipcstarted;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="comment">//this is not thread safe since it is at global scope</span>
<a name="l00122"></a>00122 <span class="comment">//var _STATUS;</span>
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="comment">/* not used anywhere in postgres interface</span>
<a name="l00125"></a>00125 <span class="comment">#define MV_MAX_KEY_LENGTH 8092-1</span>
<a name="l00126"></a>00126 <span class="comment">#define MV_MAX_KEY_LENGTH_EXCEEDED &quot;MV_MAX_KEY_LENGTH_EXCEEDED&quot;</span>
<a name="l00127"></a>00127 <span class="comment">#define MV_MAX_RECORD_LENGTH 1048576-1</span>
<a name="l00128"></a>00128 <span class="comment">#define MV_MAX_RECORD_LENGTH_EXCEEDED &quot;MV_MAX_RECORD_LENGTH_EXCEEDED&quot;</span>
<a name="l00129"></a>00129 <span class="comment">#define MV_MAX_FILENAME_LENGTH 8092-1</span>
<a name="l00130"></a>00130 <span class="comment">#define MV_MAX_FILENAME_LENGTH_EXCEEDED &quot;MV_MAX_FILENAME_LENGTH_EXCEEDED&quot;</span>
<a name="l00131"></a>00131 <span class="comment">#define MV_MAX_CONNECTPARAM_LENGTH 8092-1</span>
<a name="l00132"></a>00132 <span class="comment">#define MV_MAX_CONNECTPARAM_LENGTH_EXCEEDED &quot;MV_MAX_CONNECTPARAM_LENGTH_EXCEEDED&quot;</span>
<a name="l00133"></a>00133 <span class="comment">#define MV_BAD_FILENAME &quot;MV_BAD_FILENAME&quot;</span>
<a name="l00134"></a>00134 <span class="comment">*/</span>
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 <span class="keyword">typedef</span> PGresult*       PGresultptr;
<a name="l00137"></a>00137 <span class="keywordtype">int</span> pqexec(<span class="keyword">const</span> var&amp; sql, PGresultptr&amp; pgresult);
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="preprocessor">#if defined _MSC_VER //|| defined __CYGWIN__ || defined __MINGW32__</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span>LONG WINAPI DelayLoadDllExceptionFilter(PEXCEPTION_POINTERS pExcPointers) {
<a name="l00141"></a>00141    LONG lDisposition = EXCEPTION_EXECUTE_HANDLER;
<a name="l00142"></a>00142    
<a name="l00143"></a>00143    PDelayLoadInfo pDelayLoadInfo =
<a name="l00144"></a>00144     PDelayLoadInfo(pExcPointers-&gt;ExceptionRecord-&gt;ExceptionInformation[0]);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146    <span class="keywordflow">switch</span> (pExcPointers-&gt;ExceptionRecord-&gt;ExceptionCode) {
<a name="l00147"></a>00147    <span class="keywordflow">case</span> VcppException(ERROR_SEVERITY_ERROR, ERROR_MOD_NOT_FOUND):
<a name="l00148"></a>00148            printf(<span class="stringliteral">&quot;mvdbpostgres: %s was not found\n&quot;</span>, pDelayLoadInfo-&gt;szDll);
<a name="l00149"></a>00149       <span class="keywordflow">break</span>;
<a name="l00150"></a>00150 <span class="comment">/*</span>
<a name="l00151"></a>00151 <span class="comment">   case VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND):</span>
<a name="l00152"></a>00152 <span class="comment">      if (pdli-&gt;dlp.fImportByName) {</span>
<a name="l00153"></a>00153 <span class="comment">                          printf(&quot;Function %s was not found in %sn&quot;,</span>
<a name="l00154"></a>00154 <span class="comment">              pDelayLoadInfo-&gt;dlp.szProcName, pDelayLoadInfo-&gt;szDll);</span>
<a name="l00155"></a>00155 <span class="comment">      } else {</span>
<a name="l00156"></a>00156 <span class="comment">      printf(&quot;Function ordinal %d was not found in %sn&quot;,</span>
<a name="l00157"></a>00157 <span class="comment">              pDelayLoadInfo-&gt;dlp.dwOrdinal, pDelayLoadInfo-&gt;szDll);</span>
<a name="l00158"></a>00158 <span class="comment">      }</span>
<a name="l00159"></a>00159 <span class="comment">      break; </span>
<a name="l00160"></a>00160 <span class="comment">*/</span>
<a name="l00161"></a>00161    <span class="keywordflow">default</span>:
<a name="l00162"></a>00162       <span class="comment">// Exception is not related to delay loading</span>
<a name="l00163"></a>00163       printf(<span class="stringliteral">&quot;Unknown problem %s\n&quot;</span>, pDelayLoadInfo-&gt;szDll);
<a name="l00164"></a>00164       lDisposition = EXCEPTION_CONTINUE_SEARCH;
<a name="l00165"></a>00165       <span class="keywordflow">break</span>;
<a name="l00166"></a>00166    }
<a name="l00167"></a>00167 
<a name="l00168"></a>00168    <span class="keywordflow">return</span>(lDisposition);
<a name="l00169"></a>00169 }
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="comment">//msvc uses a special mode to catch failure to load a delay loaded dll that is incompatible with the normal try/catch and</span>
<a name="l00172"></a>00172 <span class="comment">//needs to be put in simple global function with no complex objects (that require standard c++ try/catch stack unwinding?)</span>
<a name="l00173"></a>00173 <span class="comment">//maybe it would be easier to manually load it using dlopen/dlsym implemented in var as var::load and var::call</span>
<a name="l00174"></a>00174 <span class="comment">//http://msdn.microsoft.com/en-us/library/5skw957f(vs.80).aspx</span>
<a name="l00175"></a>00175 <span class="keywordtype">bool</span> msvc_PQconnectdb(PGconn** pgconn, <span class="keyword">const</span> std::string&amp; conninfo)
<a name="l00176"></a>00176 {
<a name="l00177"></a>00177         <span class="comment">//connect or fail</span>
<a name="l00178"></a>00178         __try
<a name="l00179"></a>00179         {
<a name="l00180"></a>00180                 *pgconn=PQconnectdb(conninfo.c_str());
<a name="l00181"></a>00181         }
<a name="l00182"></a>00182         __except(DelayLoadDllExceptionFilter(GetExceptionInformation()))
<a name="l00183"></a>00183         {
<a name="l00184"></a>00184                 <span class="keywordflow">return</span> <span class="keyword">false</span>;           
<a name="l00185"></a>00185         }
<a name="l00186"></a>00186         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00187"></a>00187 }
<a name="l00188"></a>00188 
<a name="l00189"></a>00189 <span class="preprocessor">#endif</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span>
<a name="l00191"></a>00191 <span class="keywordtype">bool</span> var::connect(<span class="keyword">const</span> var&amp; conninfo)
<a name="l00192"></a>00192 {
<a name="l00193"></a>00193         THISIS(L<span class="stringliteral">&quot;bool var::connect(const var&amp; conninfo)&quot;</span>)
<a name="l00194"></a>00194 
<a name="l00195"></a>00195         <span class="comment">//nb dont log/trace or otherwise output the full connection info without HIDING the password</span>
<a name="l00196"></a>00196         var defaultconninfo=L&quot;host=127.0.0.1 port=5432 dbname=exodus user=exodus password=somesillysecret connect_timeout=10&quot;;
<a name="l00197"></a>00197         THISISDEFINED()
<a name="l00198"></a>00198         ISSTRING(conninfo)
<a name="l00199"></a>00199 
<a name="l00200"></a>00200         var_mvtype=pimpl::MVTYPE_UNA;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <span class="comment">//find connection details</span>
<a name="l00203"></a>00203         var conninfo2=conninfo;
<a name="l00204"></a>00204 
<a name="l00205"></a>00205         <span class="comment">//if no conninfo details provided then use last connection details if any</span>
<a name="l00206"></a>00206         if (!conninfo &amp;&amp; tss_pgconnparams.get())
<a name="l00207"></a>00207                 conninfo2==*tss_pgconnparams.get();
<a name="l00208"></a>00208 
<a name="l00209"></a>00209         <span class="comment">//otherwise search for details from exodus config file</span>
<a name="l00210"></a>00210         if (!conninfo2)
<a name="l00211"></a>00211         {
<a name="l00212"></a>00212                 <span class="keywordflow">if</span> (not conninfo2.osgetenv(L<span class="stringliteral">&quot;EXODUS_CONNECTION&quot;</span>))
<a name="l00213"></a>00213                 {
<a name="l00214"></a>00214                         var configfilename=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l00215"></a>00215                         var home;
<a name="l00216"></a>00216                         <span class="keywordflow">if</span> (home.osgetenv(L<span class="stringliteral">&quot;HOME&quot;</span>))
<a name="l00217"></a>00217                                 configfilename=home^L<span class="stringliteral">&quot;/.exodus&quot;</span>;
<a name="l00218"></a>00218                         <span class="keywordflow">else</span> {
<a name="l00219"></a>00219                                 home.osgetenv(L<span class="stringliteral">&quot;USERPROFILE&quot;</span>);
<a name="l00220"></a>00220                                 configfilename^=home^L<span class="stringliteral">&quot;\\.exodus&quot;</span>;
<a name="l00221"></a>00221                         }
<a name="l00222"></a>00222                         <span class="keywordflow">if</span> (not conninfo2.osread(configfilename))
<a name="l00223"></a>00223                         {
<a name="l00224"></a>00224                                 <span class="comment">//try to connect without info using libpq defaults (pg config files and env vars)</span>
<a name="l00225"></a>00225                                 <span class="comment">//exodus::errputln(L&quot;connect() config missing. Please login.&quot;);</span>
<a name="l00226"></a>00226                                 <span class="comment">//return false;</span>
<a name="l00227"></a>00227                         }
<a name="l00228"></a>00228                 }
<a name="l00229"></a>00229         }
<a name="l00230"></a>00230  
<a name="l00231"></a>00231         <span class="comment">//disconnect any previous connection</span>
<a name="l00232"></a>00232         <span class="keywordflow">if</span> (tss_pgconns.get())
<a name="l00233"></a>00233                 disconnect();
<a name="l00234"></a>00234 
<a name="l00235"></a>00235         <span class="comment">//connect or fail</span>
<a name="l00236"></a>00236         PGconn* pgconn;
<a name="l00237"></a>00237         <span class="keywordflow">do</span>
<a name="l00238"></a>00238         {
<a name="l00239"></a>00239 <span class="preprocessor">#if defined _MSC_VER //|| defined __CYGWIN__ || defined __MINGW32__</span>
<a name="l00240"></a>00240 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (not msvc_PQconnectdb(&amp;pgconn,conninfo2.tostring()))
<a name="l00241"></a>00241                 {
<a name="l00242"></a>00242                         <span class="comment">//#if TRACING &gt;= 1</span>
<a name="l00243"></a>00243                                 var libname=L<span class="stringliteral">&quot;libpq.dll&quot;</span>;
<a name="l00244"></a>00244                                 <span class="comment">//var libname=L&quot;libpq.so&quot;;</span>
<a name="l00245"></a>00245                                 exodus::errputln(L<span class="stringliteral">&quot;var::connect() Cannot load shared library &quot;</span> ^ libname ^ L<span class="stringliteral">&quot;. Verify configuration PATH contains postgres&#39;s \\bin.&quot;</span>);
<a name="l00246"></a>00246                         <span class="comment">//#endif</span>
<a name="l00247"></a>00247                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00248"></a>00248                 };
<a name="l00249"></a>00249 <span class="preprocessor">#else</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span>                pgconn=PQconnectdb(conninfo2.tostring().c_str());
<a name="l00251"></a>00251 <span class="preprocessor">#endif</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span>
<a name="l00253"></a>00253                 <span class="keywordflow">if</span> (PQstatus(pgconn) == CONNECTION_OK || conninfo2)
<a name="l00254"></a>00254                         <span class="keywordflow">break</span>;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256                 <span class="comment">//try again with default conninfo</span>
<a name="l00257"></a>00257                 conninfo2=defaultconninfo;
<a name="l00258"></a>00258 
<a name="l00259"></a>00259         } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l00260"></a>00260 
<a name="l00261"></a>00261         <span class="keywordflow">if</span> (PQstatus(pgconn) != CONNECTION_OK)
<a name="l00262"></a>00262         {
<a name="l00263"></a>00263 <span class="preprocessor">                #if TRACING &gt;= 2</span>
<a name="l00264"></a>00264 <span class="preprocessor"></span>                        exodus::errputln(L<span class="stringliteral">&quot;var::connect() Connection to database failed: &quot;</span> ^ var(PQerrorMessage(pgconn)));
<a name="l00265"></a>00265                         <span class="keywordflow">if</span> (not conninfo2)
<a name="l00266"></a>00266                                 exodus::errputln(L<span class="stringliteral">&quot;var::connect() Postgres login configuration missing or incorrect. Please login.&quot;</span>);
<a name="l00267"></a>00267 <span class="preprocessor">                #endif</span>
<a name="l00268"></a>00268 <span class="preprocessor"></span>                PQfinish(pgconn);
<a name="l00269"></a>00269                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00270"></a>00270         }
<a name="l00271"></a>00271 <span class="preprocessor">        #if TRACING &gt;= 3</span>
<a name="l00272"></a>00272 <span class="preprocessor"></span>                exodus::logputln(L<span class="stringliteral">&quot;var::connect() Connection to database succeeded.&quot;</span>);
<a name="l00273"></a>00273 <span class="preprocessor">        #endif</span>
<a name="l00274"></a>00274 <span class="preprocessor"></span>
<a name="l00275"></a>00275         <span class="comment">//abort if multithreading and it is not supported</span>
<a name="l00276"></a>00276 <span class="preprocessor">        #ifdef PQisthreadsafe</span>
<a name="l00277"></a>00277 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (!PQisthreadsafe())
<a name="l00278"></a>00278                 {
<a name="l00279"></a>00279                         <span class="comment">//TODO only abort if environmentn&gt;0</span>
<a name="l00280"></a>00280                         <span class="keywordflow">throw</span> MVDBException(L<span class="stringliteral">&quot;connect(): Postgres PQ library is not threadsafe&quot;</span>);
<a name="l00281"></a>00281                 }
<a name="l00282"></a>00282 <span class="preprocessor">        #endif</span>
<a name="l00283"></a>00283 <span class="preprocessor"></span>
<a name="l00284"></a>00284         *<span class="keyword">this</span>=1;
<a name="l00285"></a>00285 
<a name="l00286"></a>00286         <span class="comment">//need to set PQnoticeReceiver to suppress NOTICES like when creating files</span>
<a name="l00287"></a>00287         <span class="comment">//PQsetErrorVerbosity(pgconn, PQERRORS_TERSE);</span>
<a name="l00288"></a>00288 
<a name="l00289"></a>00289         <span class="comment">//save the connection in thread specific storage</span>
<a name="l00290"></a>00290         tss_pgconns.reset(pgconn);
<a name="l00291"></a>00291         tss_pgconnparams.reset(<span class="keyword">new</span> var(conninfo2));
<a name="l00292"></a>00292 
<a name="l00293"></a>00293         <span class="comment">//setup a thread to service callbacks from the database backend</span>
<a name="l00294"></a>00294         <span class="keywordflow">if</span> (!tss_ipcstarted.get())
<a name="l00295"></a>00295         {
<a name="l00296"></a>00296 <span class="preprocessor">                #if TRACING &gt;= 3</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span>                        exodus::outputln(L<span class="stringliteral">&quot;Starting IPC&quot;</span>);
<a name="l00298"></a>00298 <span class="preprocessor">                #endif</span>
<a name="l00299"></a>00299 <span class="preprocessor"></span>                startipc();
<a name="l00300"></a>00300         }
<a name="l00301"></a>00301 
<a name="l00302"></a>00302          <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 }
<a name="l00305"></a>00305 
<a name="l00306"></a>00306 <span class="comment">//use void pointer to avoid need for including postgres headers in mv.h or any fancy class hierarchy</span>
<a name="l00307"></a>00307 <span class="comment">//(assumes accurate programming by system programmers in exodus mvdb routines)</span>
<a name="l00308"></a>00308 <span class="keywordtype">void</span>* var::connection()<span class="keyword"> const</span>
<a name="l00309"></a>00309 <span class="keyword"></span>{
<a name="l00310"></a>00310         THISIS(L<span class="stringliteral">&quot;void* var::connection() const&quot;</span>)
<a name="l00311"></a>00311 
<a name="l00312"></a>00312         <span class="comment">//provides jit connection and caching</span>
<a name="l00313"></a>00313 
<a name="l00314"></a>00314         <span class="comment">//get the current thread connection if any</span>
<a name="l00315"></a>00315         PGconn* thread_pgconn=tss_pgconns.get();
<a name="l00316"></a>00316 
<a name="l00317"></a>00317         <span class="comment">//autoconnect if not connected</span>
<a name="l00318"></a>00318         if (!thread_pgconn)
<a name="l00319"></a>00319         {
<a name="l00320"></a>00320                 <span class="comment">//cast away const otherwise we have to remove const from all the var::select() methods to reflect</span>
<a name="l00321"></a>00321                 <span class="comment">//that autoconnection could cause connect() to update the base var (this)</span>
<a name="l00322"></a>00322                 <span class="comment">//if (!(const_cast&lt;const var&gt;(*this)).connect())</span>
<a name="l00323"></a>00323                 <span class="comment">//dodge the issue for now</span>
<a name="l00324"></a>00324                 <span class="keywordflow">if</span> (!var().connect())
<a name="l00325"></a>00325                 {
<a name="l00326"></a>00326                         <span class="comment">//handle failure to connect here to avoid error handling on every connection</span>
<a name="l00327"></a>00327                         <span class="comment">//calling process can always use connect() or try/catch</span>
<a name="l00328"></a>00328                         <span class="keywordflow">throw</span> MVDBException(L<span class="stringliteral">&quot;connection(): Cannot connect. Please login&quot;</span>);
<a name="l00329"></a>00329                 }
<a name="l00330"></a>00330                 <span class="comment">//get the new connection</span>
<a name="l00331"></a>00331                 thread_pgconn=tss_pgconns.get();
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333         <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*) thread_pgconn;
<a name="l00334"></a>00334 }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336 <span class="keywordtype">bool</span> var::disconnect()
<a name="l00337"></a>00337 {
<a name="l00338"></a>00338         THISIS(L<span class="stringliteral">&quot;bool var::disconnect()&quot;</span>)
<a name="l00339"></a>00339 
<a name="l00340"></a>00340         THISISDEFINED()
<a name="l00341"></a>00341 
<a name="l00342"></a>00342         <span class="preprocessor">#if TRACING &gt;= 3</span>
<a name="l00343"></a>00343 <span class="preprocessor"></span>                exodus::errputln(L<span class="stringliteral">&quot;var::disconnect() Closing connection&quot;</span>);
<a name="l00344"></a>00344 <span class="preprocessor">        #endif</span>
<a name="l00345"></a>00345 <span class="preprocessor"></span>
<a name="l00346"></a>00346         PGconn* thread_pgconn=tss_pgconns.get();
<a name="l00347"></a>00347 
<a name="l00348"></a>00348         PQfinish(thread_pgconn);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350         tss_pgconns.release();
<a name="l00351"></a>00351 
<a name="l00352"></a>00352         var_mvstr=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l00353"></a>00353         var_mvint=0;
<a name="l00354"></a>00354 
<a name="l00355"></a>00355         <span class="comment">//make unassigned()</span>
<a name="l00356"></a>00356         var_mvtype=pimpl::MVTYPE_UNA;
<a name="l00357"></a>00357 
<a name="l00358"></a>00358         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360 }
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="keywordtype">bool</span> var::open(<span class="keyword">const</span> var&amp; filename)
<a name="l00363"></a>00363 {
<a name="l00364"></a>00364         THISIS(L<span class="stringliteral">&quot;bool var::open(const var&amp; filename)&quot;</span>)
<a name="l00365"></a>00365 
<a name="l00366"></a>00366         return open(L&quot;&quot;,filename);
<a name="l00367"></a>00367 }
<a name="l00368"></a>00368 
<a name="l00369"></a>00369 <span class="keywordtype">bool</span> var::open(const var&amp; dictcode,const var&amp; filename)
<a name="l00370"></a>00370 {
<a name="l00371"></a>00371         THISIS(L<span class="stringliteral">&quot;bool var::open(const var&amp; dictcode,const var&amp; filename)&quot;</span>)
<a name="l00372"></a>00372         THISISDEFINED()
<a name="l00373"></a>00373         ISSTRING(dictcode)
<a name="l00374"></a>00374         ISSTRING(filename)
<a name="l00375"></a>00375 
<a name="l00376"></a>00376     <span class="comment">//dumb version of read to see if file exists</span>
<a name="l00377"></a>00377     <span class="comment">//should perhaps prepare pg parameters for repeated speed</span>
<a name="l00378"></a>00378 
<a name="l00379"></a>00379     var key=L&quot;&quot;;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381     const <span class="keywordtype">char</span>* paramValues[1];
<a name="l00382"></a>00382     <span class="keywordtype">int</span>         paramLengths[1];
<a name="l00383"></a>00383     <span class="keywordtype">int</span>         paramFormats[1];
<a name="l00384"></a>00384 <span class="comment">//    uint32_t    binaryIntVal;</span>
<a name="l00385"></a>00385 
<a name="l00386"></a>00386     <span class="comment">/* Here is our out-of-line parameter value */</span>
<a name="l00387"></a>00387         std::<span class="keywordtype">string</span> key2=key.tostring();
<a name="l00388"></a>00388     paramValues[0] = key2.c_str();
<a name="l00389"></a>00389     paramLengths[0] = <span class="keywordtype">int</span>(key2.length());
<a name="l00390"></a>00390     paramFormats[0] = 1;<span class="comment">//binary</span>
<a name="l00391"></a>00391 
<a name="l00392"></a>00392         <span class="comment">//TODO optimise by doing something other than SELECT * where key = &quot;&quot;?</span>
<a name="l00393"></a>00393         var sql=L&quot;SELECT key FROM &quot; PGDATAFILEPREFIX;
<a name="l00394"></a>00394     if (dictcode.ucase()==L&quot;DICT&quot;)
<a name="l00395"></a>00395         sql^=L&quot;dict_&quot;;
<a name="l00396"></a>00396     else if (dictcode)
<a name="l00397"></a>00397         sql^=dictcode;
<a name="l00398"></a>00398     if (filename) sql^=filename.convert(L&quot;.&quot;,L&quot;_&quot;);
<a name="l00399"></a>00399     else sql^=filename;
<a name="l00400"></a>00400     sql^= L&quot; WHERE key = $1&quot;;
<a name="l00401"></a>00401 
<a name="l00402"></a>00402     PGconn* thread_pgconn=(PGconn*) connection();
<a name="l00403"></a>00403         DEBUG_LOG_SQL1
<a name="l00404"></a>00404         PGresult* result = PQexecParams(thread_pgconn,
<a name="l00405"></a>00405                                         <span class="comment">//TODO: parameterise filename</span>
<a name="l00406"></a>00406                        sql.tostring().c_str(),
<a name="l00407"></a>00407                        1,       <span class="comment">/* one param */</span>
<a name="l00408"></a>00408                        NULL,    <span class="comment">/* let the backend deduce param type */</span>
<a name="l00409"></a>00409                        paramValues,
<a name="l00410"></a>00410                                            paramLengths,
<a name="l00411"></a>00411                                            paramFormats,
<a name="l00412"></a>00412                        1);      <span class="comment">/* ask for binary results */</span>
<a name="l00413"></a>00413 
<a name="l00414"></a>00414     if (PQresultStatus(result) != PGRES_TUPLES_OK)
<a name="l00415"></a>00415     {
<a name="l00416"></a>00416                 PQclear(result);
<a name="l00417"></a>00417 <span class="preprocessor">                #if TRACING &gt;= 2</span>
<a name="l00418"></a>00418 <span class="preprocessor"></span>                exodus::errputln(L<span class="stringliteral">&quot;OPEN failed: &quot;</span> ^ var(PQerrorMessage(thread_pgconn)));
<a name="l00419"></a>00419 <span class="preprocessor">        #endif</span>
<a name="l00420"></a>00420 <span class="preprocessor"></span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00421"></a>00421     }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423     PQclear(result);
<a name="l00424"></a>00424 
<a name="l00425"></a>00425         <span class="comment">//save the filename</span>
<a name="l00426"></a>00426         var_mvstr=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l00427"></a>00427         <span class="keywordflow">if</span> (dictcode.ucase()==L<span class="stringliteral">&quot;DICT&quot;</span>) var_mvstr=PGDATAFILEPREFIX L<span class="stringliteral">&quot;dict_&quot;</span>;
<a name="l00428"></a>00428         <span class="comment">//var_mvstr+=filename.var_mvstr;</span>
<a name="l00429"></a>00429         var_mvstr+=filename.convert(L<span class="stringliteral">&quot;. &quot;</span>,L<span class="stringliteral">&quot;__&quot;</span>).towstring();
<a name="l00430"></a>00430         var_mvtype=pimpl::MVTYPE_STR;
<a name="l00431"></a>00431 
<a name="l00432"></a>00432         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 <span class="keywordtype">void</span> var::close()
<a name="l00437"></a>00437 {
<a name="l00438"></a>00438         THISIS(L<span class="stringliteral">&quot;void var::close()&quot;</span>)
<a name="l00439"></a>00439         THISISSTRING()
<a name="l00440"></a>00440 <span class="comment">/*TODO</span>
<a name="l00441"></a>00441 <span class="comment">        if (var_mvtype!=MVTYPE_UNA) QMClose(var_mvint);</span>
<a name="l00442"></a>00442 <span class="comment">*/</span>
<a name="l00443"></a>00443 }
<a name="l00444"></a>00444 
<a name="l00445"></a>00445 <span class="keywordtype">bool</span> var::readv(const var&amp; filehandle, const var&amp; key, const <span class="keywordtype">int</span> fieldn)
<a name="l00446"></a>00446 {
<a name="l00447"></a>00447         THISIS(L<span class="stringliteral">&quot;bool var::readv(const var&amp; filehandle, const var&amp; key, const int fieldn)&quot;</span>)
<a name="l00448"></a>00448 
<a name="l00449"></a>00449         if (!read(filehandle,key))
<a name="l00450"></a>00450                 return false;
<a name="l00451"></a>00451         var_mvstr=extract(fieldn).var_mvstr;
<a name="l00452"></a>00452         return true;
<a name="l00453"></a>00453 }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455 <span class="keywordtype">bool</span> var::read(const var&amp; filehandle,const var&amp; key)
<a name="l00456"></a>00456 {
<a name="l00457"></a>00457         THISIS(L<span class="stringliteral">&quot;bool var::read(const var&amp; filehandle,const var&amp; key)&quot;</span>)
<a name="l00458"></a>00458         THISISDEFINED()
<a name="l00459"></a>00459         ISSTRING(filehandle)
<a name="l00460"></a>00460         ISSTRING(key)
<a name="l00461"></a>00461 
<a name="l00462"></a>00462     const <span class="keywordtype">char</span>* paramValues[1];
<a name="l00463"></a>00463     <span class="keywordtype">int</span>         paramLengths[1];
<a name="l00464"></a>00464     <span class="keywordtype">int</span>         paramFormats[1];
<a name="l00465"></a>00465         <span class="comment">//uint32_t    binaryIntVal;</span>
<a name="l00466"></a>00466 
<a name="l00467"></a>00467         std::<span class="keywordtype">string</span> key2=key.tostring();
<a name="l00468"></a>00468 
<a name="l00469"></a>00469         paramValues[0]=key2.c_str();
<a name="l00470"></a>00470         paramLengths[0]=<span class="keywordtype">int</span>(key2.length());
<a name="l00471"></a>00471         paramFormats[0]=1;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 
<a name="l00474"></a>00474         var sql=L&quot;SELECT data FROM &quot; PGDATAFILEPREFIX ^ filehandle ^ L&quot; WHERE key = $1&quot;;
<a name="l00475"></a>00475 
<a name="l00476"></a>00476     PGconn* thread_pgconn=(PGconn*) connection();
<a name="l00477"></a>00477         DEBUG_LOG_SQL1
<a name="l00478"></a>00478         PGresult* result = PQexecParams(thread_pgconn,
<a name="l00479"></a>00479                                         <span class="comment">//TODO: parameterise filename</span>
<a name="l00480"></a>00480                        sql.tostring().c_str(),
<a name="l00481"></a>00481                        1,       <span class="comment">/* one param */</span>
<a name="l00482"></a>00482                        NULL,    <span class="comment">/* let the backend deduce param type */</span>
<a name="l00483"></a>00483                        paramValues,
<a name="l00484"></a>00484                                            paramLengths,
<a name="l00485"></a>00485                                            paramFormats,
<a name="l00486"></a>00486                        1);      <span class="comment">/* ask for binary results */</span>
<a name="l00487"></a>00487 
<a name="l00488"></a>00488         if (PQresultStatus(result) != PGRES_TUPLES_OK)
<a name="l00489"></a>00489         {
<a name="l00490"></a>00490                 PQclear(result);
<a name="l00491"></a>00491                 <span class="keywordflow">throw</span> MVException(L<span class="stringliteral">&quot;read(&quot;</span> ^ filehandle ^ L<span class="stringliteral">&quot;, &quot;</span> ^ key ^ L<span class="stringliteral">&quot;) - probably file not opened or doesnt exist\n&quot;</span> ^ var(PQerrorMessage(thread_pgconn)));
<a name="l00492"></a>00492                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00493"></a>00493         }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495         <span class="keywordflow">if</span> (PQntuples(result) &lt; 1)
<a name="l00496"></a>00496         {
<a name="l00497"></a>00497                 PQclear(result);
<a name="l00498"></a>00498                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00499"></a>00499         }
<a name="l00500"></a>00500 
<a name="l00501"></a>00501         <span class="keywordflow">if</span> (PQntuples(result) &gt; 1)
<a name="l00502"></a>00502         {
<a name="l00503"></a>00503                 PQclear(result);
<a name="l00504"></a>00504                 exodus::errputln(L<span class="stringliteral">&quot;var::read() SELECT returned more than one record&quot;</span>);
<a name="l00505"></a>00505                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00506"></a>00506         }
<a name="l00507"></a>00507 
<a name="l00508"></a>00508         *<span class="keyword">this</span>=wstringfromUTF8((UTF8*)PQgetvalue(result, 0, 0), PQgetlength(result, 0, 0));
<a name="l00509"></a>00509 
<a name="l00510"></a>00510         PQclear(result);
<a name="l00511"></a>00511 
<a name="l00512"></a>00512         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00513"></a>00513 
<a name="l00514"></a>00514 }
<a name="l00515"></a>00515 
<a name="l00516"></a>00516 <span class="keywordtype">bool</span> var::lock(<span class="keyword">const</span> var&amp; key)<span class="keyword"> const</span>
<a name="l00517"></a>00517 <span class="keyword"></span>{
<a name="l00518"></a>00518         THISIS(L<span class="stringliteral">&quot;bool var::lock(const var&amp; key) const&quot;</span>)
<a name="l00519"></a>00519         THISISDEFINED()
<a name="l00520"></a>00520         ISSTRING(key)
<a name="l00521"></a>00521 
<a name="l00522"></a>00522         <span class="comment">//TODO</span>
<a name="l00523"></a>00523         exodus::errputln(L&quot;lock() not implemented yet&quot;);
<a name="l00524"></a>00524         return true;
<a name="l00525"></a>00525 }
<a name="l00526"></a>00526 
<a name="l00527"></a>00527 <span class="keywordtype">void</span> var::unlock(const var&amp; key)<span class="keyword"> const</span>
<a name="l00528"></a>00528 <span class="keyword"></span>{
<a name="l00529"></a>00529         THISIS(L<span class="stringliteral">&quot;void var::unlock(const var&amp; key) const&quot;</span>)
<a name="l00530"></a>00530         THISISDEFINED()
<a name="l00531"></a>00531         ISSTRING(key)
<a name="l00532"></a>00532 
<a name="l00533"></a>00533         return;
<a name="l00534"></a>00534 }
<a name="l00535"></a>00535 
<a name="l00536"></a>00536 <span class="keywordtype">void</span> var::unlockall()<span class="keyword"> const</span>
<a name="l00537"></a>00537 <span class="keyword"></span>{
<a name="l00538"></a>00538         THISIS(L<span class="stringliteral">&quot;void var::unlockall() const&quot;</span>)
<a name="l00539"></a>00539 
<a name="l00540"></a>00540         return;
<a name="l00541"></a>00541 }
<a name="l00542"></a>00542 
<a name="l00543"></a>00543 
<a name="l00544"></a>00544 <span class="keywordtype">bool</span> var::writev(const var&amp; filehandle,const var&amp; key,const <span class="keywordtype">int</span> fieldn)<span class="keyword"> const</span>
<a name="l00545"></a>00545 <span class="keyword"></span>{
<a name="l00546"></a>00546         <span class="keywordflow">if</span> (fieldn&lt;=1)
<a name="l00547"></a>00547                 <span class="keywordflow">return</span> write(filehandle, key);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549         THISIS(L<span class="stringliteral">&quot;bool var::writev(const var&amp; filehandle,const var&amp; key,const int fieldn) const&quot;</span>)
<a name="l00550"></a>00550         <span class="comment">//will be duplicated in read and write but do here to present the correct function name on error</span>
<a name="l00551"></a>00551         THISISSTRING()
<a name="l00552"></a>00552         ISSTRING(filehandle)
<a name="l00553"></a>00553         ISSTRING(key)
<a name="l00554"></a>00554 
<a name="l00555"></a>00555         <span class="comment">//get the old record</span>
<a name="l00556"></a>00556         var record;
<a name="l00557"></a>00557         if (!record.read(filehandle,key))
<a name="l00558"></a>00558                 record=L&quot;&quot;;
<a name="l00559"></a>00559 
<a name="l00560"></a>00560         <span class="comment">//replace the field</span>
<a name="l00561"></a>00561         record.replacer(fieldn,0,0,var_mvstr);
<a name="l00562"></a>00562 
<a name="l00563"></a>00563         <span class="comment">//write it back</span>
<a name="l00564"></a>00564         record.write(filehandle,key);
<a name="l00565"></a>00565 
<a name="l00566"></a>00566         return true;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 <span class="comment">/* prepared statement version doesnt seem to make much difference approx -10% - possibly because two field file is so simple</span>
<a name="l00571"></a>00571 <span class="comment">bool var::write(const var&amp; filehandle,const var&amp; key) const</span>
<a name="l00572"></a>00572 <span class="comment">{</span>
<a name="l00573"></a>00573 <span class="comment"></span>
<a name="l00574"></a>00574 <span class="comment">        if (!var_mvtype) throw MVUnassigned(L&quot;write()&quot;);</span>
<a name="l00575"></a>00575 <span class="comment">        if (!filehandle.var_mvtype) throw MVUnassigned(L&quot;write(filehandle)&quot;);</span>
<a name="l00576"></a>00576 <span class="comment">        if (!key.var_mvtype) throw MVUnassigned(L&quot;write(key)&quot;);</span>
<a name="l00577"></a>00577 <span class="comment"></span>
<a name="l00578"></a>00578 <span class="comment">        if (key==0)</span>
<a name="l00579"></a>00579 <span class="comment">        {</span>
<a name="l00580"></a>00580 <span class="comment"></span>
<a name="l00581"></a>00581 <span class="comment">//      PGresult *PQprepare(PGconn *thread_pgconn,</span>
<a name="l00582"></a>00582 <span class="comment">//              const wchar_t *stmtName,</span>
<a name="l00583"></a>00583 <span class="comment">//              const wchar_t *query,</span>
<a name="l00584"></a>00584 <span class="comment">//              int nParams,</span>
<a name="l00585"></a>00585 <span class="comment">//              const Oid *paramTypes);</span>
<a name="l00586"></a>00586 <span class="comment"></span>
<a name="l00587"></a>00587 <span class="comment">        Oid paramTypes[3];</span>
<a name="l00588"></a>00588 <span class="comment">        paramTypes[0]=BYTEAOID;</span>
<a name="l00589"></a>00589 <span class="comment">        paramTypes[1]=TEXTOID;</span>
<a name="l00590"></a>00590 <span class="comment">        paramTypes[2]=TEXTOID;</span>
<a name="l00591"></a>00591 <span class="comment"></span>
<a name="l00592"></a>00592 <span class="comment">        PGresult* res1;</span>
<a name="l00593"></a>00593 <span class="comment">        res1 = PQprepare(thread_pgconn,</span>
<a name="l00594"></a>00594 <span class="comment">                                                &quot;PREPAREDINSERT&quot;,</span>
<a name="l00595"></a>00595 <span class="comment">                                                &quot;INSERT INTO TEST (key, data) values($2, $3)&quot;,</span>
<a name="l00596"></a>00596 <span class="comment">                                                3,</span>
<a name="l00597"></a>00597 <span class="comment">                                                paramTypes);</span>
<a name="l00598"></a>00598 <span class="comment"></span>
<a name="l00599"></a>00599 <span class="comment">        if (PQresultStatus(res1) != PGRES_COMMAND_OK)</span>
<a name="l00600"></a>00600 <span class="comment">    {</span>
<a name="l00601"></a>00601 <span class="comment">        cerr&lt;&lt;L&quot;var::write() failed: Prepare: &quot;&lt;&lt;PQerrorMessage(thread_pgconn)&lt;&lt;endl;</span>
<a name="l00602"></a>00602 <span class="comment">        PQclear(res1);</span>
<a name="l00603"></a>00603 <span class="comment">        return false;</span>
<a name="l00604"></a>00604 <span class="comment">        }</span>
<a name="l00605"></a>00605 <span class="comment"></span>
<a name="l00606"></a>00606 <span class="comment">        }</span>
<a name="l00607"></a>00607 <span class="comment"></span>
<a name="l00608"></a>00608 <span class="comment">    // Here is our out-of-line parameter value</span>
<a name="l00609"></a>00609 <span class="comment">    const char* paramValues[3];</span>
<a name="l00610"></a>00610 <span class="comment">    int         paramLengths[3];</span>
<a name="l00611"></a>00611 <span class="comment">    int         paramFormats[3];</span>
<a name="l00612"></a>00612 <span class="comment"></span>
<a name="l00613"></a>00613 <span class="comment">        std::string=filehandle2 filehandle.tostring();</span>
<a name="l00614"></a>00614 <span class="comment">        std::string=key2 key.tostring();</span>
<a name="l00615"></a>00615 <span class="comment">        std::string=data2 data.tostring();</span>
<a name="l00616"></a>00616 <span class="comment"></span>
<a name="l00617"></a>00617 <span class="comment">        paramValues[0] = filehandle2.data();//filename</span>
<a name="l00618"></a>00618 <span class="comment">    paramValues[1] = key2.data();//key</span>
<a name="l00619"></a>00619 <span class="comment">    paramValues[2] = data2.data();//data</span>
<a name="l00620"></a>00620 <span class="comment"></span>
<a name="l00621"></a>00621 <span class="comment">    paramLengths[0] = filehandle2.length();//filename</span>
<a name="l00622"></a>00622 <span class="comment">    paramLengths[1] = key2.length();//key</span>
<a name="l00623"></a>00623 <span class="comment">    paramLengths[2] = data2.length();//data</span>
<a name="l00624"></a>00624 <span class="comment"></span>
<a name="l00625"></a>00625 <span class="comment">    paramFormats[0] = 1;//binary</span>
<a name="l00626"></a>00626 <span class="comment">    paramFormats[1] = 1;//binary</span>
<a name="l00627"></a>00627 <span class="comment">    paramFormats[2] = 1;//binary</span>
<a name="l00628"></a>00628 <span class="comment"></span>
<a name="l00629"></a>00629 <span class="comment">//      PGresult *PQexecPrepared(PGconn *thread_pgconn,</span>
<a name="l00630"></a>00630 <span class="comment">//                         const wchar_t *stmtName,</span>
<a name="l00631"></a>00631 <span class="comment">//                         int nParams,</span>
<a name="l00632"></a>00632 <span class="comment">//                         const wchar_t * const *paramValues,</span>
<a name="l00633"></a>00633 <span class="comment">//                         const int *paramLengths,</span>
<a name="l00634"></a>00634 <span class="comment">//                         const int *paramFormats,</span>
<a name="l00635"></a>00635 <span class="comment">//                         int resultFormat);</span>
<a name="l00636"></a>00636 <span class="comment">        PGresult* result;</span>
<a name="l00637"></a>00637 <span class="comment">        result = PQexecPrepared(thread_pgconn,</span>
<a name="l00638"></a>00638 <span class="comment">                                                &quot;PREPAREDINSERT&quot;,</span>
<a name="l00639"></a>00639 <span class="comment">                                                3,</span>
<a name="l00640"></a>00640 <span class="comment">                                                paramValues,</span>
<a name="l00641"></a>00641 <span class="comment">                                                paramLengths,</span>
<a name="l00642"></a>00642 <span class="comment">                                                paramFormats,</span>
<a name="l00643"></a>00643 <span class="comment">                                                1);      // ask for binary results</span>
<a name="l00644"></a>00644 <span class="comment"></span>
<a name="l00645"></a>00645 <span class="comment">//    if (PQntuples(result) != 1)</span>
<a name="l00646"></a>00646 <span class="comment">        if (PQresultStatus(result) != PGRES_COMMAND_OK)</span>
<a name="l00647"></a>00647 <span class="comment">    {</span>
<a name="l00648"></a>00648 <span class="comment">        cerr&lt;&lt;L&quot;var::write() failed: &quot;&lt;&lt;PQntuples(result)&lt;&lt;L&quot; &quot;&lt;&lt;PQerrorMessage(thread_pgconn)&lt;&lt;endl;</span>
<a name="l00649"></a>00649 <span class="comment">        PQclear(result);</span>
<a name="l00650"></a>00650 <span class="comment">        return false;</span>
<a name="l00651"></a>00651 <span class="comment">    }</span>
<a name="l00652"></a>00652 <span class="comment"></span>
<a name="l00653"></a>00653 <span class="comment">//    if (PQntuples(result) != 1)</span>
<a name="l00654"></a>00654 <span class="comment">//    {</span>
<a name="l00655"></a>00655 <span class="comment">//        cerr&lt;&lt;L&quot;var::write() failed: &quot;&lt;&lt;PQntuples(result)&lt;&lt;L&quot; rows returned&quot;&lt;&lt;endl;</span>
<a name="l00656"></a>00656 <span class="comment">//        PQclear(result);</span>
<a name="l00657"></a>00657 <span class="comment">//        return false;</span>
<a name="l00658"></a>00658 <span class="comment">//    }</span>
<a name="l00659"></a>00659 <span class="comment"></span>
<a name="l00660"></a>00660 <span class="comment">    PQclear(result);</span>
<a name="l00661"></a>00661 <span class="comment"></span>
<a name="l00662"></a>00662 <span class="comment">        return true;</span>
<a name="l00663"></a>00663 <span class="comment"></span>
<a name="l00664"></a>00664 <span class="comment">}</span>
<a name="l00665"></a>00665 <span class="comment">*/</span>
<a name="l00666"></a>00666 
<a name="l00667"></a>00667 <span class="keywordtype">bool</span> var::write(const var&amp; filehandle, const var&amp; key)<span class="keyword"> const</span>
<a name="l00668"></a>00668 <span class="keyword"></span>{
<a name="l00669"></a>00669         THISIS(L<span class="stringliteral">&quot;bool var::write(const var&amp; filehandle, const var&amp; key) const&quot;</span>)
<a name="l00670"></a>00670         THISISSTRING()
<a name="l00671"></a>00671         ISSTRING(filehandle)
<a name="l00672"></a>00672         ISSTRING(key)
<a name="l00673"></a>00673 
<a name="l00674"></a>00674         const <span class="keywordtype">wchar_t</span>* mode=L&quot;write()&quot;;
<a name="l00675"></a>00675 
<a name="l00676"></a>00676     const <span class="keywordtype">char</span>* paramValues[2];
<a name="l00677"></a>00677     <span class="keywordtype">int</span>         paramLengths[2];
<a name="l00678"></a>00678     <span class="keywordtype">int</span>         paramFormats[2];
<a name="l00679"></a>00679     <span class="comment">//uint32_t    binaryIntVal;</span>
<a name="l00680"></a>00680 
<a name="l00681"></a>00681         std::<span class="keywordtype">string</span> key2=key.tostring();
<a name="l00682"></a>00682         std::<span class="keywordtype">string</span> data2=(*this).tostring();
<a name="l00683"></a>00683 
<a name="l00684"></a>00684     paramValues[0] = key2.data();
<a name="l00685"></a>00685     paramValues[1] = data2.data();
<a name="l00686"></a>00686 
<a name="l00687"></a>00687     paramLengths[0] = <span class="keywordtype">int</span>(key2.length());
<a name="l00688"></a>00688     paramLengths[1] = <span class="keywordtype">int</span>(data2.length());
<a name="l00689"></a>00689 
<a name="l00690"></a>00690     paramFormats[0] = 1;<span class="comment">//binary</span>
<a name="l00691"></a>00691     paramFormats[1] = 1;<span class="comment">//binary</span>
<a name="l00692"></a>00692 
<a name="l00693"></a>00693         var sql;
<a name="l00694"></a>00694 
<a name="l00695"></a>00695         <span class="comment">//try update first and if it fails then try insert</span>
<a name="l00696"></a>00696 
<a name="l00697"></a>00697         sql = L&quot;UPDATE &quot; PGDATAFILEPREFIX ^ filehandle ^ L&quot; SET data = $2 WHERE key = $1&quot;;
<a name="l00698"></a>00698 
<a name="l00699"></a>00699         PGconn* thread_pgconn=(PGconn*) connection();
<a name="l00700"></a>00700         DEBUG_LOG_SQL1
<a name="l00701"></a>00701     PGresult* result = PQexecParams(thread_pgconn,
<a name="l00702"></a>00702                                         <span class="comment">//TODO: parameterise filename</span>
<a name="l00703"></a>00703                        sql.tostring().c_str(),
<a name="l00704"></a>00704                        2,                               <span class="comment">// two params (key and data)</span>
<a name="l00705"></a>00705                        NULL,                    <span class="comment">// let the backend deduce param type</span>
<a name="l00706"></a>00706                        paramValues,
<a name="l00707"></a>00707                        paramLengths,
<a name="l00708"></a>00708                        paramFormats,
<a name="l00709"></a>00709                        1);                              <span class="comment">// ask for binary results</span>
<a name="l00710"></a>00710         if (PQresultStatus(result) != PGRES_COMMAND_OK)
<a name="l00711"></a>00711         {
<a name="l00712"></a>00712                 PQclear(result);
<a name="l00713"></a>00713         exodus::errputln(L<span class="stringliteral">&quot;var::write() failed: &quot;</span> ^ var(PQntuples(result)) ^ L<span class="stringliteral">&quot; &quot;</span> ^ var(PQerrorMessage(thread_pgconn)));
<a name="l00714"></a>00714                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00715"></a>00715         }
<a name="l00716"></a>00716 
<a name="l00717"></a>00717         <span class="comment">//if updated 1 then OK because update worked and no need to try insert below</span>
<a name="l00718"></a>00718     <span class="keywordflow">if</span> (strcmp(PQcmdTuples(result),<span class="stringliteral">&quot;1&quot;</span>) == 0)
<a name="l00719"></a>00719     {
<a name="l00720"></a>00720                 PQclear(result);
<a name="l00721"></a>00721                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00722"></a>00722         }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724         <span class="comment">//if update fails then try insert</span>
<a name="l00725"></a>00725 
<a name="l00726"></a>00726     PQclear(result);
<a name="l00727"></a>00727         sql = L<span class="stringliteral">&quot;INSERT INTO &quot;</span> PGDATAFILEPREFIX ^ filehandle ^ L<span class="stringliteral">&quot; (key,data) values( $1 , $2)&quot;</span>;
<a name="l00728"></a>00728         DEBUG_LOG_SQL1
<a name="l00729"></a>00729         result = PQexecParams(thread_pgconn,
<a name="l00730"></a>00730                 sql.tostring().c_str(),
<a name="l00731"></a>00731                 2,                              <span class="comment">// two params (key and data)</span>
<a name="l00732"></a>00732                 NULL,                   <span class="comment">// let the backend deduce param type</span>
<a name="l00733"></a>00733                 paramValues,
<a name="l00734"></a>00734                 paramLengths,
<a name="l00735"></a>00735                 paramFormats,   <span class="comment">// bytea</span>
<a name="l00736"></a>00736                 1);                             <span class="comment">// ask for binary results</span>
<a name="l00737"></a>00737 
<a name="l00738"></a>00738         <span class="keywordflow">if</span> (PQresultStatus(result) != PGRES_COMMAND_OK)
<a name="l00739"></a>00739     {
<a name="l00740"></a>00740                 PQclear(result);
<a name="l00741"></a>00741         exodus::errputln(L<span class="stringliteral">&quot;var::write() INSERT failed: &quot;</span> ^ var(PQntuples(result)) ^ L<span class="stringliteral">&quot; &quot;</span> ^ var(PQerrorMessage(thread_pgconn)));
<a name="l00742"></a>00742         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00743"></a>00743     }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745         <span class="comment">//if not updated 1 then fail</span>
<a name="l00746"></a>00746     <span class="keywordflow">if</span> (strcmp(PQcmdTuples(result),<span class="stringliteral">&quot;1&quot;</span>) != 0)
<a name="l00747"></a>00747     {
<a name="l00748"></a>00748                 PQclear(result);
<a name="l00749"></a>00749                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00750"></a>00750         }
<a name="l00751"></a>00751 
<a name="l00752"></a>00752         PQclear(result);
<a name="l00753"></a>00753         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00754"></a>00754 
<a name="l00755"></a>00755 }
<a name="l00756"></a>00756 
<a name="l00757"></a>00757 <span class="comment">//&quot;updaterecord&quot; is non-standard for pick - but allows &quot;write only if already exists&quot; logic</span>
<a name="l00758"></a>00758 
<a name="l00759"></a>00759 <span class="keywordtype">bool</span> var::updaterecord(<span class="keyword">const</span> var&amp; filehandle,<span class="keyword">const</span> var&amp; key)<span class="keyword"> const</span>
<a name="l00760"></a>00760 <span class="keyword"></span>{
<a name="l00761"></a>00761         THISIS(L<span class="stringliteral">&quot;bool var::updaterecord(const var&amp; filehandle,const var&amp; key) const&quot;</span>)
<a name="l00762"></a>00762         THISISSTRING()
<a name="l00763"></a>00763         ISSTRING(filehandle)
<a name="l00764"></a>00764         ISSTRING(key)
<a name="l00765"></a>00765 
<a name="l00766"></a>00766         const <span class="keywordtype">wchar_t</span>* mode=L&quot;updaterecord()&quot;;
<a name="l00767"></a>00767 
<a name="l00768"></a>00768     const <span class="keywordtype">char</span>* paramValues[2];
<a name="l00769"></a>00769     <span class="keywordtype">int</span>         paramLengths[2];
<a name="l00770"></a>00770     <span class="keywordtype">int</span>         paramFormats[2];
<a name="l00771"></a>00771     <span class="comment">//uint32_t    binaryIntVal;</span>
<a name="l00772"></a>00772 
<a name="l00773"></a>00773         std::<span class="keywordtype">string</span> key2=key.tostring();
<a name="l00774"></a>00774         std::<span class="keywordtype">string</span> data2=(*this).tostring();
<a name="l00775"></a>00775 
<a name="l00776"></a>00776     paramValues[0] = key2.data();
<a name="l00777"></a>00777     paramValues[1] = data2.data();
<a name="l00778"></a>00778 
<a name="l00779"></a>00779     paramLengths[0] = <span class="keywordtype">int</span>(key2.length());
<a name="l00780"></a>00780     paramLengths[1] = <span class="keywordtype">int</span>(data2.length());
<a name="l00781"></a>00781 
<a name="l00782"></a>00782     paramFormats[0] = 1;<span class="comment">//binary</span>
<a name="l00783"></a>00783     paramFormats[1] = 1;<span class="comment">//binary</span>
<a name="l00784"></a>00784 
<a name="l00785"></a>00785         var sql = L&quot;UPDATE &quot; PGDATAFILEPREFIX ^ filehandle ^ L&quot; SET data = $2 WHERE key = $1&quot;;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787         PGconn* thread_pgconn=(PGconn*) connection();
<a name="l00788"></a>00788         DEBUG_LOG_SQL1
<a name="l00789"></a>00789     PGresult* result = PQexecParams(thread_pgconn,
<a name="l00790"></a>00790                 <span class="comment">//TODO: parameterise filename</span>
<a name="l00791"></a>00791                                                           sql.tostring().c_str(),
<a name="l00792"></a>00792                 2,                              <span class="comment">// two params (key and data)</span>
<a name="l00793"></a>00793                 NULL,                   <span class="comment">// let the backend deduce param type</span>
<a name="l00794"></a>00794                 paramValues,
<a name="l00795"></a>00795                 paramLengths,
<a name="l00796"></a>00796                 paramFormats,   <span class="comment">// bytea</span>
<a name="l00797"></a>00797                 1);                             <span class="comment">// ask for binary results</span>
<a name="l00798"></a>00798         if (PQresultStatus(result) != PGRES_COMMAND_OK)
<a name="l00799"></a>00799         {
<a name="l00800"></a>00800                 PQclear(result);
<a name="l00801"></a>00801                 exodus::errputln(L<span class="stringliteral">&quot;var::update failed: &quot;</span> ^ var(PQntuples(result)) ^ L<span class="stringliteral">&quot; &quot;</span> ^ var(PQerrorMessage(thread_pgconn)));
<a name="l00802"></a>00802                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00803"></a>00803         }
<a name="l00804"></a>00804 
<a name="l00805"></a>00805         <span class="comment">//if not updated 1 then fail</span>
<a name="l00806"></a>00806     <span class="keywordflow">if</span> (strcmp(PQcmdTuples(result),<span class="stringliteral">&quot;1&quot;</span>) != 0)
<a name="l00807"></a>00807     {
<a name="l00808"></a>00808                 PQclear(result);
<a name="l00809"></a>00809                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00810"></a>00810         }
<a name="l00811"></a>00811 
<a name="l00812"></a>00812         PQclear(result);
<a name="l00813"></a>00813         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00814"></a>00814 
<a name="l00815"></a>00815 }
<a name="l00816"></a>00816 
<a name="l00817"></a>00817 <span class="comment">//&quot;insertrecord&quot; is non-standard for pick - but allows faster writes under &quot;write only if doesnt already exist&quot; logic</span>
<a name="l00818"></a>00818 
<a name="l00819"></a>00819 <span class="keywordtype">bool</span> var::insertrecord(<span class="keyword">const</span> var&amp; filehandle,<span class="keyword">const</span> var&amp; key)<span class="keyword"> const</span>
<a name="l00820"></a>00820 <span class="keyword"></span>{
<a name="l00821"></a>00821         THISIS(L<span class="stringliteral">&quot;bool var::insertrecord(const var&amp; filehandle,const var&amp; key) const&quot;</span>)
<a name="l00822"></a>00822         THISISSTRING()
<a name="l00823"></a>00823         ISSTRING(filehandle)
<a name="l00824"></a>00824         ISSTRING(key)
<a name="l00825"></a>00825 
<a name="l00826"></a>00826         const <span class="keywordtype">wchar_t</span>* mode=L&quot;insertrecord()&quot;;
<a name="l00827"></a>00827 
<a name="l00828"></a>00828         const <span class="keywordtype">char</span>* paramValues[2];
<a name="l00829"></a>00829     <span class="keywordtype">int</span>         paramLengths[2];
<a name="l00830"></a>00830     <span class="keywordtype">int</span>         paramFormats[2];
<a name="l00831"></a>00831     <span class="comment">//uint32_t    binaryIntVal;</span>
<a name="l00832"></a>00832 
<a name="l00833"></a>00833         std::<span class="keywordtype">string</span> key2=key.tostring();
<a name="l00834"></a>00834         std::<span class="keywordtype">string</span> data2=(*this).tostring();
<a name="l00835"></a>00835 
<a name="l00836"></a>00836     paramValues[0] = key2.data();
<a name="l00837"></a>00837     paramValues[1] = data2.data();
<a name="l00838"></a>00838 
<a name="l00839"></a>00839     paramLengths[0] = <span class="keywordtype">int</span>(key2.length());
<a name="l00840"></a>00840     paramLengths[1] = <span class="keywordtype">int</span>(data2.length());
<a name="l00841"></a>00841 
<a name="l00842"></a>00842     paramFormats[0] = 1;<span class="comment">//binary</span>
<a name="l00843"></a>00843     paramFormats[1] = 1;<span class="comment">//binary</span>
<a name="l00844"></a>00844 
<a name="l00845"></a>00845         var sql = L&quot;INSERT INTO &quot; PGDATAFILEPREFIX ^ filehandle ^ L&quot; (key,data) values( $1 , $2)&quot;;
<a name="l00846"></a>00846 
<a name="l00847"></a>00847         PGconn* thread_pgconn=(PGconn*) connection();
<a name="l00848"></a>00848         DEBUG_LOG_SQL1
<a name="l00849"></a>00849         PGresult* result = PQexecParams(thread_pgconn,
<a name="l00850"></a>00850                 <span class="comment">//TODO: parameterise filename</span>
<a name="l00851"></a>00851                 sql.tostring().c_str(),
<a name="l00852"></a>00852                 2,                              <span class="comment">// two params (key and data)</span>
<a name="l00853"></a>00853                 NULL,                   <span class="comment">// let the backend deduce param type</span>
<a name="l00854"></a>00854                 paramValues,
<a name="l00855"></a>00855                 paramLengths,
<a name="l00856"></a>00856                 paramFormats,   <span class="comment">// bytea</span>
<a name="l00857"></a>00857                 1);                             <span class="comment">// ask for binary results</span>
<a name="l00858"></a>00858 
<a name="l00859"></a>00859         if (PQresultStatus(result) != PGRES_COMMAND_OK)
<a name="l00860"></a>00860     {
<a name="l00861"></a>00861                 exodus::errputln(L<span class="stringliteral">&quot;var::insertrecord INSERT failed: &quot;</span> ^ var(PQntuples(result)) ^ L<span class="stringliteral">&quot; &quot;</span> ^ var(PQerrorMessage(thread_pgconn)));
<a name="l00862"></a>00862         PQclear(result);
<a name="l00863"></a>00863         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00864"></a>00864     }
<a name="l00865"></a>00865 
<a name="l00866"></a>00866         <span class="comment">//if not updated 1 then fail</span>
<a name="l00867"></a>00867     <span class="keywordflow">if</span> (strcmp(PQcmdTuples(result),<span class="stringliteral">&quot;1&quot;</span>) != 0)
<a name="l00868"></a>00868     {
<a name="l00869"></a>00869                 PQclear(result);
<a name="l00870"></a>00870                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00871"></a>00871         }
<a name="l00872"></a>00872 
<a name="l00873"></a>00873         PQclear(result);
<a name="l00874"></a>00874         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00875"></a>00875 
<a name="l00876"></a>00876 }
<a name="l00877"></a>00877 
<a name="l00878"></a>00878 <span class="keywordtype">bool</span> var::deleterecord(<span class="keyword">const</span> var&amp; key)<span class="keyword"> const</span>
<a name="l00879"></a>00879 <span class="keyword"></span>{
<a name="l00880"></a>00880         THISIS(L<span class="stringliteral">&quot;bool var::deleterecord(const var&amp; key) const&quot;</span>)
<a name="l00881"></a>00881         THISISSTRING()
<a name="l00882"></a>00882         ISSTRING(key)
<a name="l00883"></a>00883 
<a name="l00884"></a>00884     const <span class="keywordtype">char</span>* paramValues[1];
<a name="l00885"></a>00885     <span class="keywordtype">int</span>         paramLengths[1];
<a name="l00886"></a>00886     <span class="keywordtype">int</span>         paramFormats[1];
<a name="l00887"></a>00887     <span class="comment">//uint32_t    binaryIntVal;</span>
<a name="l00888"></a>00888 
<a name="l00889"></a>00889         std::<span class="keywordtype">string</span> key2=key.tostring();
<a name="l00890"></a>00890 
<a name="l00891"></a>00891     paramValues[0] = key2.data();
<a name="l00892"></a>00892 
<a name="l00893"></a>00893     paramLengths[0] = <span class="keywordtype">int</span>(key2.length());
<a name="l00894"></a>00894 
<a name="l00895"></a>00895     paramFormats[0] = 1;<span class="comment">//binary</span>
<a name="l00896"></a>00896 
<a name="l00897"></a>00897         var sql=L&quot;DELETE FROM &quot; PGDATAFILEPREFIX ^ var_mvstr ^ L&quot; WHERE KEY = $1&quot;;
<a name="l00898"></a>00898 
<a name="l00899"></a>00899         PGconn* thread_pgconn=(PGconn*) connection();
<a name="l00900"></a>00900         DEBUG_LOG_SQL1
<a name="l00901"></a>00901     PGresult* result = PQexecParams(thread_pgconn,
<a name="l00902"></a>00902                 sql.tostring().c_str(),
<a name="l00903"></a>00903                 1,       <span class="comment">/* two param */</span>
<a name="l00904"></a>00904                 NULL,    <span class="comment">/* let the backend deduce param type */</span>
<a name="l00905"></a>00905                 paramValues,
<a name="l00906"></a>00906                 paramLengths,
<a name="l00907"></a>00907                 paramFormats,
<a name="l00908"></a>00908                 1);      <span class="comment">/* ask for binary results */</span>
<a name="l00909"></a>00909 
<a name="l00910"></a>00910         if (PQresultStatus(result) != PGRES_COMMAND_OK)
<a name="l00911"></a>00911     {
<a name="l00912"></a>00912                 exodus::errputln(L<span class="stringliteral">&quot;var::deleterecord failed: &quot;</span> ^ var(PQntuples(result)) ^ L<span class="stringliteral">&quot; &quot;</span> ^ var(PQerrorMessage(thread_pgconn)));
<a name="l00913"></a>00913         PQclear(result);
<a name="l00914"></a>00914         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00915"></a>00915     }
<a name="l00916"></a>00916 
<a name="l00917"></a>00917         <span class="comment">//if not updated 1 then fail</span>
<a name="l00918"></a>00918     <span class="keywordflow">if</span> (strcmp(PQcmdTuples(result),<span class="stringliteral">&quot;1&quot;</span>) != 0)
<a name="l00919"></a>00919     {
<a name="l00920"></a>00920                 PQclear(result);
<a name="l00921"></a>00921                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00922"></a>00922         }
<a name="l00923"></a>00923 
<a name="l00924"></a>00924 
<a name="l00925"></a>00925     PQclear(result);
<a name="l00926"></a>00926 
<a name="l00927"></a>00927         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00928"></a>00928 }
<a name="l00929"></a>00929 
<a name="l00930"></a>00930 var var::xlate(<span class="keyword">const</span> var&amp; filename,<span class="keyword">const</span> var&amp; fieldno, <span class="keyword">const</span> var&amp; mode)<span class="keyword"> const</span>
<a name="l00931"></a>00931 <span class="keyword"></span>{
<a name="l00932"></a>00932         THISIS(L<span class="stringliteral">&quot;var var::xlate(const var&amp; filename,const var&amp; fieldno, const var&amp; mode) const&quot;</span>)
<a name="l00933"></a>00933         ISSTRING(mode)
<a name="l00934"></a>00934 
<a name="l00935"></a>00935         return xlate(filename,fieldno,mode.towstring().c_str());
<a name="l00936"></a>00936 }
<a name="l00937"></a>00937 
<a name="l00938"></a>00938 <span class="comment">//TODO provide a version with int fieldno to handle the most frequent case</span>
<a name="l00939"></a>00939 <span class="comment">// although may also support dictid (of target file) instead of fieldno</span>
<a name="l00940"></a>00940 
<a name="l00941"></a>00941 var var::xlate(const var&amp; filename,const var&amp; fieldno, const <span class="keywordtype">wchar_t</span>* mode)<span class="keyword"> const</span>
<a name="l00942"></a>00942 <span class="keyword"></span>{
<a name="l00943"></a>00943         THISIS(L<span class="stringliteral">&quot;var var::xlate(const var&amp; filename,const var&amp; fieldno, const wchar_t* mode) const&quot;</span>)
<a name="l00944"></a>00944         THISISSTRING()
<a name="l00945"></a>00945         ISSTRING(filename)
<a name="l00946"></a>00946         ISSTRING(fieldno)
<a name="l00947"></a>00947 
<a name="l00948"></a>00948         <span class="comment">//open the file (skip this for now since sql doesnt need &quot;open&quot;</span>
<a name="l00949"></a>00949         var file;
<a name="l00950"></a>00950         var record;
<a name="l00951"></a>00951         <span class="comment">//if (!file.open(filename))</span>
<a name="l00952"></a>00952         <span class="comment">//{</span>
<a name="l00953"></a>00953         <span class="comment">//      _STATUS=filename^L&quot; does not exist&quot;;</span>
<a name="l00954"></a>00954         <span class="comment">//      record=L&quot;&quot;;</span>
<a name="l00955"></a>00955         <span class="comment">//      return record;</span>
<a name="l00956"></a>00956         <span class="comment">//}</span>
<a name="l00957"></a>00957         file=filename;
<a name="l00958"></a>00958 
<a name="l00959"></a>00959         <span class="comment">//read the record</span>
<a name="l00960"></a>00960         if (!record.read(file,var_mvstr))
<a name="l00961"></a>00961         {
<a name="l00962"></a>00962                 <span class="comment">//if record doesnt exist then &quot;&quot;, or original key if mode is &quot;C&quot;</span>
<a name="l00963"></a>00963          <span class="keywordflow">if</span> (mode==L<span class="stringliteral">&quot;C&quot;</span>)
<a name="l00964"></a>00964                         record=*<span class="keyword">this</span>;
<a name="l00965"></a>00965                 <span class="keywordflow">else</span>
<a name="l00966"></a>00966                         record=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l00967"></a>00967         }
<a name="l00968"></a>00968         <span class="keywordflow">else</span>
<a name="l00969"></a>00969         {
<a name="l00970"></a>00970                 <span class="comment">//extract the field or field 0 means return the whole record</span>
<a name="l00971"></a>00971                 <span class="keywordflow">if</span> (fieldno)
<a name="l00972"></a>00972                         record=record.extract(fieldno);
<a name="l00973"></a>00973         }
<a name="l00974"></a>00974         <span class="keywordflow">return</span> record;
<a name="l00975"></a>00975 }
<a name="l00976"></a>00976 
<a name="l00977"></a>00977 <span class="keywordtype">bool</span> var::begin()<span class="keyword"> const</span>
<a name="l00978"></a>00978 <span class="keyword"></span>{
<a name="l00979"></a>00979         THISIS(L<span class="stringliteral">&quot;bool var::begin() const&quot;</span>)
<a name="l00980"></a>00980 
<a name="l00981"></a>00981         <span class="comment">// *this is not used</span>
<a name="l00982"></a>00982         THISISDEFINED()
<a name="l00983"></a>00983 
<a name="l00984"></a>00984         <span class="comment">//begin a transaction</span>
<a name="l00985"></a>00985         var sql=L&quot;BEGIN&quot;;
<a name="l00986"></a>00986 
<a name="l00987"></a>00987         <span class="comment">//execute the sql</span>
<a name="l00988"></a>00988         connection();
<a name="l00989"></a>00989         PGresultptr result;
<a name="l00990"></a>00990         if (!pqexec(sql,result))
<a name="l00991"></a>00991                 return false;
<a name="l00992"></a>00992 
<a name="l00993"></a>00993         PQclear(result);
<a name="l00994"></a>00994         return true;
<a name="l00995"></a>00995 }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997 <span class="keywordtype">bool</span> var::rollback()<span class="keyword"> const</span>
<a name="l00998"></a>00998 <span class="keyword"></span>{
<a name="l00999"></a>00999         THISIS(L<span class="stringliteral">&quot;bool var::rollback() const&quot;</span>)
<a name="l01000"></a>01000 
<a name="l01001"></a>01001         <span class="comment">// *this is not used</span>
<a name="l01002"></a>01002         THISISDEFINED()
<a name="l01003"></a>01003 
<a name="l01004"></a>01004         <span class="comment">// Rollback a transaction</span>
<a name="l01005"></a>01005         var sql=L&quot;BEGIN&quot;;
<a name="l01006"></a>01006 
<a name="l01007"></a>01007         <span class="comment">//execute the sql</span>
<a name="l01008"></a>01008         connection();
<a name="l01009"></a>01009         PGresultptr result;
<a name="l01010"></a>01010         if (!pqexec(sql,result))
<a name="l01011"></a>01011                 return false;
<a name="l01012"></a>01012 
<a name="l01013"></a>01013         PQclear(result);
<a name="l01014"></a>01014         return true;
<a name="l01015"></a>01015 
<a name="l01016"></a>01016 }
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 <span class="keywordtype">bool</span> var::end()<span class="keyword"> const</span>
<a name="l01019"></a>01019 <span class="keyword"></span>{
<a name="l01020"></a>01020         THISIS(L<span class="stringliteral">&quot;bool var::end() const&quot;</span>)
<a name="l01021"></a>01021 
<a name="l01022"></a>01022         <span class="comment">// *this is not used</span>
<a name="l01023"></a>01023         THISISDEFINED()
<a name="l01024"></a>01024 
<a name="l01025"></a>01025         <span class="comment">//end (commit) a transaction</span>
<a name="l01026"></a>01026         var sql=L&quot;END&quot;;
<a name="l01027"></a>01027 
<a name="l01028"></a>01028         <span class="comment">//execute the sql</span>
<a name="l01029"></a>01029         connection();
<a name="l01030"></a>01030         PGresultptr result;
<a name="l01031"></a>01031         if (!pqexec(sql,result))
<a name="l01032"></a>01032                 return false;
<a name="l01033"></a>01033 
<a name="l01034"></a>01034         PQclear(result);
<a name="l01035"></a>01035         return true;
<a name="l01036"></a>01036 
<a name="l01037"></a>01037 }
<a name="l01038"></a>01038 
<a name="l01039"></a>01039 <span class="keywordtype">bool</span> var::createfile(const var&amp; filename, const var&amp; options)
<a name="l01040"></a>01040 {
<a name="l01041"></a>01041         THISIS(L<span class="stringliteral">&quot;bool var::createfile(const var&amp; filename, const var&amp; options)&quot;</span>)
<a name="l01042"></a>01042         <span class="comment">// *this is not used</span>
<a name="l01043"></a>01043         THISISDEFINED()
<a name="l01044"></a>01044         ISSTRING(filename)
<a name="l01045"></a>01045         ISSTRING(options)
<a name="l01046"></a>01046 
<a name="l01047"></a>01047         <span class="comment">//var tablename = L&quot;TEMP&quot; ^ var(100000000).rnd();</span>
<a name="l01048"></a>01048         <span class="comment">//Postgres The ON COMMIT clause for temporary tables also resembles the SQL standard, but has some differences. If the ON COMMIT clause is omitted, SQL specifies that the default behavior is ON COMMIT DELETE ROWS. However, the default behavior in PostgreSQL is ON COMMIT PRESERVE ROWS. The ON COMMIT DROP option does not exist in SQL.</span>
<a name="l01049"></a>01049 
<a name="l01050"></a>01050         var sql = L&quot;CREATE&quot;;
<a name="l01051"></a>01051         <span class="comment">//if (options.ucase().index(L&quot;TEMPORARY&quot;)) sql ^= L&quot; TEMPORARY&quot;;</span>
<a name="l01052"></a>01052         sql ^= L&quot; TABLE &quot; PGDATAFILEPREFIX ^ filename.convert(L&quot;.&quot;,L&quot;_&quot;);
<a name="l01053"></a>01053         sql ^= L&quot; (key bytea primary key, data bytea)&quot;;
<a name="l01054"></a>01054 
<a name="l01055"></a>01055         <span class="comment">//execute the sql</span>
<a name="l01056"></a>01056         connection();
<a name="l01057"></a>01057         PGresultptr pgresult;
<a name="l01058"></a>01058         if (!pqexec(sql,pgresult))
<a name="l01059"></a>01059                 return false;
<a name="l01060"></a>01060 
<a name="l01061"></a>01061         PQclear(pgresult);
<a name="l01062"></a>01062         return true;
<a name="l01063"></a>01063 
<a name="l01064"></a>01064 }
<a name="l01065"></a>01065 
<a name="l01066"></a>01066 <span class="keywordtype">bool</span> var::deletefile()<span class="keyword"> const</span>
<a name="l01067"></a>01067 <span class="keyword"></span>{
<a name="l01068"></a>01068         THISIS(L<span class="stringliteral">&quot;bool var::deletefile() const&quot;</span>)
<a name="l01069"></a>01069         THISISSTRING()
<a name="l01070"></a>01070 
<a name="l01071"></a>01071         var sql = L&quot;DROP TABLE &quot; PGDATAFILEPREFIX ^ *this;
<a name="l01072"></a>01072 
<a name="l01073"></a>01073         <span class="comment">//execute the sql</span>
<a name="l01074"></a>01074         connection();
<a name="l01075"></a>01075         PGresultptr pgresult;
<a name="l01076"></a>01076         if (!pqexec(sql,pgresult))
<a name="l01077"></a>01077                 return false;
<a name="l01078"></a>01078 
<a name="l01079"></a>01079         PQclear(pgresult);
<a name="l01080"></a>01080         return true;
<a name="l01081"></a>01081 
<a name="l01082"></a>01082 }
<a name="l01083"></a>01083 
<a name="l01084"></a>01084 <span class="keywordtype">bool</span> var::clearfile()<span class="keyword"> const</span>
<a name="l01085"></a>01085 <span class="keyword"></span>{
<a name="l01086"></a>01086         THISIS(L<span class="stringliteral">&quot;bool var::clearfile() const&quot;</span>)
<a name="l01087"></a>01087         THISISSTRING()
<a name="l01088"></a>01088 
<a name="l01089"></a>01089         var sql = L&quot;DELETE FROM &quot; PGDATAFILEPREFIX ^ *this;
<a name="l01090"></a>01090 
<a name="l01091"></a>01091         <span class="comment">//execute the sql</span>
<a name="l01092"></a>01092         connection();
<a name="l01093"></a>01093         PGresultptr pgresult;
<a name="l01094"></a>01094         if (!pqexec(sql,pgresult))
<a name="l01095"></a>01095                 return false;
<a name="l01096"></a>01096 
<a name="l01097"></a>01097         PQclear(pgresult);
<a name="l01098"></a>01098         return true;
<a name="l01099"></a>01099 }
<a name="l01100"></a>01100 
<a name="l01101"></a>01101 inline <span class="keywordtype">void</span> unquoter(var&amp; <span class="keywordtype">string</span>)
<a name="l01102"></a>01102 {
<a name="l01103"></a>01103         <span class="comment">//remove &quot;&quot;, &#39;&#39; and {}</span>
<a name="l01104"></a>01104         <span class="keyword">static</span> var quotecharacters(L<span class="stringliteral">&quot;\&quot;&#39;{&quot;</span>);
<a name="l01105"></a>01105         <span class="keywordflow">if</span> (quotecharacters.index(<span class="keywordtype">string</span>.substr(1,1)))
<a name="l01106"></a>01106                 <span class="keywordtype">string</span>=<span class="keywordtype">string</span>.substr(2,<span class="keywordtype">string</span>.length()-2);
<a name="l01107"></a>01107 }
<a name="l01108"></a>01108 
<a name="l01109"></a>01109 <span class="keyword">inline</span> <span class="keywordtype">void</span> tosqlstring(var&amp; string1)
<a name="l01110"></a>01110 {
<a name="l01111"></a>01111     <span class="comment">//convert to sql style strings</span>
<a name="l01112"></a>01112     <span class="comment">//use single quotes and double up any internal single quotes</span>
<a name="l01113"></a>01113     <span class="keywordflow">if</span> (string1.substr(1,1)==L<span class="stringliteral">&quot;\&quot;&quot;</span>)
<a name="l01114"></a>01114     {
<a name="l01115"></a>01115         string1.swapper(L<span class="stringliteral">&quot;&#39;&quot;</span>,L<span class="stringliteral">&quot;&#39;&#39;&quot;</span>);
<a name="l01116"></a>01116         string1.splicer(1,1,L<span class="stringliteral">&quot;&#39;&quot;</span>);
<a name="l01117"></a>01117         string1.splicer(-1,1,L<span class="stringliteral">&quot;&#39;&quot;</span>);
<a name="l01118"></a>01118     }
<a name="l01119"></a>01119 }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121 <span class="keyword">inline</span> var fileexpression(<span class="keyword">const</span> var&amp; mainfilename, <span class="keyword">const</span> var&amp; filename, <span class="keyword">const</span> var&amp; keyordata)
<a name="l01122"></a>01122 {
<a name="l01123"></a>01123         var expression=filename ^ L<span class="stringliteral">&quot;.&quot;</span> ^ keyordata;
<a name="l01124"></a>01124         <span class="keywordflow">return</span> expression;
<a name="l01125"></a>01125 
<a name="l01126"></a>01126         <span class="comment">//if you dont use STRICT in the postgres function declaration/definitions then NULL parameters do not abort functions</span>
<a name="l01127"></a>01127 
<a name="l01128"></a>01128         <span class="comment">//use COALESCE function in case this is a joined but missing record (and therefore null)</span>
<a name="l01129"></a>01129         <span class="comment">//in MYSQL this is the ISNULL expression?</span>
<a name="l01130"></a>01130         <span class="comment">//fromdictexpression=L&quot;exodus_extract_bytea(coalesce(L&quot; ^ filename ^ L&quot;.data,&#39;&#39;::bytea), &quot; ^ xlatefromfieldname.substr(9);</span>
<a name="l01131"></a>01131         <span class="comment">//if (filename==mainfilename) return expression;</span>
<a name="l01132"></a>01132         <span class="comment">//return &quot;coalesce(L&quot; ^ expression ^&quot;, &#39;&#39;::bytea)&quot;;</span>
<a name="l01133"></a>01133 }
<a name="l01134"></a>01134 
<a name="l01135"></a>01135 var getdictexpression(<span class="keyword">const</span> var&amp; mainfilename, <span class="keyword">const</span> var&amp; filename, <span class="keyword">const</span> var&amp; dictfile, <span class="keyword">const</span> var&amp; fieldname, var&amp; joins, <span class="keywordtype">bool</span> forsort_or_select_or_index=<span class="keyword">false</span>)
<a name="l01136"></a>01136 {
<a name="l01137"></a>01137 
<a name="l01138"></a>01138         var actualdictfile=dictfile;
<a name="l01139"></a>01139         <span class="keywordflow">if</span> (!actualdictfile)
<a name="l01140"></a>01140         {
<a name="l01141"></a>01141                 var dictfilename;
<a name="l01142"></a>01142                 <span class="keywordflow">if</span> (mainfilename.substr(1,5).ucase() == L<span class="stringliteral">&quot;DICT_&quot;</span>)
<a name="l01143"></a>01143                         dictfilename=L<span class="stringliteral">&quot;dict_voc&quot;</span>;
<a name="l01144"></a>01144                 <span class="keywordflow">else</span>
<a name="l01145"></a>01145                         dictfilename=L<span class="stringliteral">&quot;dict_&quot;</span>^mainfilename;
<a name="l01146"></a>01146                 <span class="keywordflow">if</span> (!actualdictfile.open(dictfilename))
<a name="l01147"></a>01147                 {
<a name="l01148"></a>01148                         <span class="keywordflow">throw</span> MVDBException(L<span class="stringliteral">&quot;getdictexpression() cannot open &quot;</span> ^ dictfilename.quote());
<a name="l01149"></a>01149                 }
<a name="l01150"></a>01150         }
<a name="l01151"></a>01151         <span class="comment">//given a file and dictionary id</span>
<a name="l01152"></a>01152     <span class="comment">//returns a postgres sql expression like (textextract(filename.data,99,0,0))</span>
<a name="l01153"></a>01153     <span class="comment">//using one of the neosys backend functions installed in postgres like textextract, dateextract etc.</span>
<a name="l01154"></a>01154     var dictrec;
<a name="l01155"></a>01155     <span class="keywordflow">if</span> (!dictrec.read(actualdictfile,fieldname))
<a name="l01156"></a>01156         {
<a name="l01157"></a>01157                 <span class="keywordflow">if</span> (not dictrec.read(L<span class="stringliteral">&quot;dict_voc&quot;</span>, fieldname))
<a name="l01158"></a>01158                 {
<a name="l01159"></a>01159                         <span class="keywordflow">if</span> (fieldname==L<span class="stringliteral">&quot;@ID&quot;</span>)
<a name="l01160"></a>01160                                 dictrec = L<span class="stringliteral">&quot;F&quot;</span> ^ FM ^ L<span class="stringliteral">&quot;0&quot;</span> ^ FM ^ L<span class="stringliteral">&quot;Ref&quot;</span> ^ FM ^ FM ^ FM ^ FM ^ FM ^ FM ^ L<span class="stringliteral">&quot;L&quot;</span> ^ FM ^ 15;
<a name="l01161"></a>01161                         <span class="keywordflow">else</span>
<a name="l01162"></a>01162                                 <span class="keywordflow">throw</span> MVDBException(L<span class="stringliteral">&quot;getdictexpression() cannot read &quot;</span> ^ fieldname.quote() ^ L<span class="stringliteral">&quot; from &quot;</span> ^ actualdictfile.quote());
<a name="l01163"></a>01163                 }
<a name="l01164"></a>01164         }
<a name="l01165"></a>01165     var sqlexpression;
<a name="l01166"></a>01166         var dicttype=dictrec.extract(1);
<a name="l01167"></a>01167     <span class="keywordflow">if</span> (dicttype==L<span class="stringliteral">&quot;F&quot;</span>)
<a name="l01168"></a>01168     {
<a name="l01169"></a>01169         var conversion=dictrec.extract(7);
<a name="l01170"></a>01170         var fieldno=dictrec.extract(2);
<a name="l01171"></a>01171                 var params;
<a name="l01172"></a>01172                 <span class="keywordflow">if</span> (fieldno)
<a name="l01173"></a>01173                         params=fileexpression(mainfilename, filename, L<span class="stringliteral">&quot;data&quot;</span>) ^ L<span class="stringliteral">&quot;,&quot;</span> ^ fieldno ^ L<span class="stringliteral">&quot;, 0, 0)&quot;</span>;
<a name="l01174"></a>01174                 <span class="keywordflow">else</span>
<a name="l01175"></a>01175                         params=fileexpression(mainfilename, filename,L<span class="stringliteral">&quot;key&quot;</span>) ^ L<span class="stringliteral">&quot;,0,0,0)&quot;</span>;
<a name="l01176"></a>01176 
<a name="l01177"></a>01177                 <span class="keywordflow">if</span> (conversion.substr(1,9)==L<span class="stringliteral">&quot;[DATETIME&quot;</span>)
<a name="l01178"></a>01178                         sqlexpression=L<span class="stringliteral">&quot;exodus_extract_datetime(&quot;</span> ^ params;
<a name="l01179"></a>01179                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (conversion.substr(1,1)==L<span class="stringliteral">&quot;D&quot;</span> || conversion.substr(1,5)==L<span class="stringliteral">&quot;[DATE&quot;</span>)
<a name="l01180"></a>01180                         sqlexpression=L<span class="stringliteral">&quot;exodus_extract_date(&quot;</span> ^ params;
<a name="l01181"></a>01181                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (conversion.substr(1,2)==L<span class="stringliteral">&quot;MT&quot;</span> || conversion.substr(1,5)==L<span class="stringliteral">&quot;[TIME&quot;</span>)
<a name="l01182"></a>01182                         sqlexpression=L<span class="stringliteral">&quot;exodus_extract_time(&quot;</span> ^  params;
<a name="l01183"></a>01183 
<a name="l01184"></a>01184                 <span class="comment">//for now (until we have a extract_number/integer/float) that doesnt fail on non-numeric like cast &quot;as integer&quot; and &quot;as float&quot; does</span>
<a name="l01185"></a>01185                 <span class="comment">//note that we could use exodus_extract_sort for EVERYTHING inc dates/time/numbers etc.</span>
<a name="l01186"></a>01186                 <span class="comment">//but its large size is perhaps a disadvantage</span>
<a name="l01187"></a>01187                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (forsort_or_select_or_index)
<a name="l01188"></a>01188                         sqlexpression=L<span class="stringliteral">&quot;exodus_extract_sort(&quot;</span> ^  params;
<a name="l01189"></a>01189 
<a name="l01190"></a>01190                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (conversion==L<span class="stringliteral">&quot;[NUMBER,0]&quot;</span> || dictrec.extract(11)==L<span class="stringliteral">&quot;0N&quot;</span> || dictrec.extract(11).substr(1,3)==L<span class="stringliteral">&quot;0N_&quot;</span>)
<a name="l01191"></a>01191                 sqlexpression=L<span class="stringliteral">&quot;cast( exodus_extract_text(&quot;</span> ^ params ^ L<span class="stringliteral">&quot; as integer)&quot;</span>;
<a name="l01192"></a>01192                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (conversion.substr(1,2)==L<span class="stringliteral">&quot;MD&quot;</span> || conversion.substr(1,7)==L<span class="stringliteral">&quot;[NUMBER&quot;</span> || dictrec.extract(12)==L<span class="stringliteral">&quot;FLOAT&quot;</span> || dictrec.extract(11).index(L<span class="stringliteral">&quot;0N&quot;</span>))
<a name="l01193"></a>01193                                 sqlexpression=L<span class="stringliteral">&quot;cast( exodus_extract_text(&quot;</span> ^ params ^ L<span class="stringliteral">&quot; as float)&quot;</span>;
<a name="l01194"></a>01194                 <span class="keywordflow">else</span>
<a name="l01195"></a>01195                         sqlexpression=L<span class="stringliteral">&quot;exodus_extract_text(&quot;</span> ^ params;
<a name="l01196"></a>01196     }
<a name="l01197"></a>01197     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dicttype==L<span class="stringliteral">&quot;S&quot;</span>)
<a name="l01198"></a>01198     {
<a name="l01199"></a>01199                 var functionx=dictrec.extract(8).trim().ucase();
<a name="l01200"></a>01200                 <span class="keywordflow">if</span> (functionx.substr(1,11)==L<span class="stringliteral">&quot;@ANS=XLATE(&quot;</span>)
<a name="l01201"></a>01201                 {
<a name="l01202"></a>01202                         functionx.splicer(1,11,L<span class="stringliteral">&quot;&quot;</span>);
<a name="l01203"></a>01203                         var xlatetofilename=functionx.field(L<span class="stringliteral">&quot;,&quot;</span>,1).trim();
<a name="l01204"></a>01204                         unquoter(xlatetofilename);
<a name="l01205"></a>01205                         var xlatefromfieldname=functionx.field(L<span class="stringliteral">&quot;,&quot;</span>,2).trim();
<a name="l01206"></a>01206                         var xlatetofieldname=functionx.field(L<span class="stringliteral">&quot;,&quot;</span>,3).trim();
<a name="l01207"></a>01207                         var xlatemode=functionx.field(L<span class="stringliteral">&quot;,&quot;</span>,4).trim().convert(L<span class="stringliteral">&quot;&#39;\&quot; )&quot;</span>,L<span class="stringliteral">&quot;&quot;</span>);
<a name="l01208"></a>01208                         <span class="comment">//if the fourth field is &#39;X&#39;, L&quot;X&quot;, L&quot;C&quot; or &#39;C&#39; then</span>
<a name="l01209"></a>01209                         <span class="comment">//assume we have a good simple xlate functionx and can convert to a JOIN</span>
<a name="l01210"></a>01210                         <span class="keywordflow">if</span> (xlatemode==L<span class="stringliteral">&quot;X&quot;</span> || xlatemode==L<span class="stringliteral">&quot;C&quot;</span>)
<a name="l01211"></a>01211                         {
<a name="l01212"></a>01212 
<a name="l01213"></a>01213 
<a name="l01214"></a>01214                                 <span class="comment">//determine the expression in the xlate file</span>
<a name="l01215"></a>01215                                 var&amp; todictexpression=sqlexpression;
<a name="l01216"></a>01216                                 <span class="keywordflow">if</span> (xlatetofieldname.isnum())
<a name="l01217"></a>01217                                 {
<a name="l01218"></a>01218                                         todictexpression=L<span class="stringliteral">&quot;exodus_extract_text(&quot;</span> ^ fileexpression(mainfilename, xlatetofilename, L<span class="stringliteral">&quot;data&quot;</span>) ^ L<span class="stringliteral">&quot;, &quot;</span> ^ xlatetofieldname ^ L<span class="stringliteral">&quot;, 0, 0)&quot;</span>;
<a name="l01219"></a>01219                                 }
<a name="l01220"></a>01220                                 <span class="keywordflow">else</span>
<a name="l01221"></a>01221                                 {
<a name="l01222"></a>01222                                         var dictxlatetofile=xlatetofilename;
<a name="l01223"></a>01223                                 <span class="comment">//if (!dictxlatetofile.open(L&quot;DICT&quot;,xlatetofilename))</span>
<a name="l01224"></a>01224                                         <span class="comment">//      throw MVDBException(L&quot;getdictexpression() DICT&quot; ^ xlatetofilename ^ L&quot; file cannot be opened&quot;);</span>
<a name="l01225"></a>01225                                         todictexpression=getdictexpression(filename,xlatetofilename, dictxlatetofile, xlatetofieldname, joins,forsort_or_select_or_index);
<a name="l01226"></a>01226                                 }
<a name="l01227"></a>01227 
<a name="l01228"></a>01228                                 <span class="comment">//determine the join details</span>
<a name="l01229"></a>01229                                 var fromdictexpression;
<a name="l01230"></a>01230                                 <span class="keywordflow">if</span> (xlatefromfieldname.substr(1,8)==L<span class="stringliteral">&quot;@RECORD&lt;&quot;</span>)
<a name="l01231"></a>01231                                 {
<a name="l01232"></a>01232                                         fromdictexpression=L<span class="stringliteral">&quot;exodus_extract_bytea(&quot;</span>;
<a name="l01233"></a>01233                                         fromdictexpression ^= fileexpression(mainfilename, filename,L<span class="stringliteral">&quot;data&quot;</span>);
<a name="l01234"></a>01234                                         fromdictexpression ^= L<span class="stringliteral">&quot;, &quot;</span> ^ xlatefromfieldname.substr(9);
<a name="l01235"></a>01235                                         fromdictexpression.splicer(-1,1,L<span class="stringliteral">&quot;&quot;</span>);
<a name="l01236"></a>01236                                         fromdictexpression ^= var(L<span class="stringliteral">&quot;, 0&quot;</span>).str(3-fromdictexpression.count(<span class="charliteral">&#39;,&#39;</span>)) ^ L<span class="stringliteral">&quot;)&quot;</span>;
<a name="l01237"></a>01237                                 }
<a name="l01238"></a>01238 <span class="comment">//TODO                          if (xlatefromfieldname.substr(1,8)==L&quot;FIELD(@ID)</span>
<a name="l01239"></a>01239                                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (xlatefromfieldname.substr(1,1)==L<span class="stringliteral">&quot;{&quot;</span>)
<a name="l01240"></a>01240                                 {
<a name="l01241"></a>01241                                         xlatefromfieldname=xlatefromfieldname.substr(2).splicer(-1,1,L<span class="stringliteral">&quot;&quot;</span>);
<a name="l01242"></a>01242                                         fromdictexpression=getdictexpression(filename,filename, dictfile, xlatefromfieldname, joins);
<a name="l01243"></a>01243                                 }
<a name="l01244"></a>01244                                 <span class="keywordflow">else</span>
<a name="l01245"></a>01245                                 {
<a name="l01246"></a>01246                                         <span class="keywordflow">throw</span>  MVDBException(L<span class="stringliteral">&quot;getdictexpression() &quot;</span> ^ filename.quote() ^ L<span class="stringliteral">&quot; &quot;</span> ^ fieldname.quote() ^ L<span class="stringliteral">&quot; - INVALID DICTIONARY EXPRESSION - &quot;</span> ^ dictrec.extract(8).quote());
<a name="l01247"></a>01247                                 }
<a name="l01248"></a>01248 
<a name="l01249"></a>01249                                 <span class="comment">//add the join</span>
<a name="l01250"></a>01250                                 var join=L<span class="stringliteral">&quot;LEFT JOIN &quot;</span> ^ xlatetofilename ^ L<span class="stringliteral">&quot; ON &quot;</span> ^ fromdictexpression ^ L<span class="stringliteral">&quot; = &quot;</span> ^ xlatetofilename ^ L<span class="stringliteral">&quot;.key&quot;</span>;
<a name="l01251"></a>01251                                 var xx;
<a name="l01252"></a>01252                                 <span class="keywordflow">if</span> (!joins.locate(join,xx,1))
<a name="l01253"></a>01253                                         joins.replacer(1,-1,0,join);
<a name="l01254"></a>01254 
<a name="l01255"></a>01255                         }
<a name="l01256"></a>01256                 }
<a name="l01257"></a>01257                 <span class="keywordflow">else</span>
<a name="l01258"></a>01258                 {
<a name="l01259"></a>01259                         sqlexpression=L<span class="stringliteral">&quot;&#39;&quot;</span> ^ fieldname ^ L<span class="stringliteral">&quot;&#39;&quot;</span>;
<a name="l01260"></a>01260                         sqlexpression=L<span class="stringliteral">&quot;exodus_call(&#39;exodusservice-&quot;</span> ^ getprocessn() ^ L<span class="stringliteral">&quot;.&quot;</span> ^ getenvironmentn() ^ L<span class="stringliteral">&quot;&#39;::bytea, &#39;&quot;</span> ^ filename ^ L<span class="stringliteral">&quot;&#39;::bytea, &#39;&quot;</span> ^ fieldname ^ L<span class="stringliteral">&quot;&#39;::bytea, &quot;</span>^ filename ^ L<span class="stringliteral">&quot;.key, &quot;</span> ^ filename ^ L<span class="stringliteral">&quot;.data,0,0)&quot;</span>;
<a name="l01261"></a>01261                         <span class="comment">//TODO apply naturalorder conversion by passing forsort_or_select_or_index option to exodus_call</span>
<a name="l01262"></a>01262                 }
<a name="l01263"></a>01263         }
<a name="l01264"></a>01264         <span class="keywordflow">else</span>
<a name="l01265"></a>01265         {
<a name="l01266"></a>01266                 <span class="comment">//throw  filename ^ L&quot; &quot; ^ fieldname ^ L&quot; - INVALID DICTIONARY ITEM&quot;;</span>
<a name="l01267"></a>01267                 <span class="keywordflow">throw</span>  MVDBException(L<span class="stringliteral">&quot;getdictexpression(&quot;</span> ^ filename.quote() ^ L<span class="stringliteral">&quot;, &quot;</span> ^ fieldname.quote() ^ L<span class="stringliteral">&quot;) invalid dictionary type &quot;</span> ^ dicttype.quote());
<a name="l01268"></a>01268         }
<a name="l01269"></a>01269     <span class="keywordflow">return</span> sqlexpression;
<a name="l01270"></a>01270 }
<a name="l01271"></a>01271 
<a name="l01272"></a>01272 var getword(var&amp; remainingwords)
<a name="l01273"></a>01273 {
<a name="l01274"></a>01274 
<a name="l01275"></a>01275     <span class="comment">//gets the next word (or series of words separated by FM while they are numbers or quoted strings)</span>
<a name="l01276"></a>01276     <span class="comment">//converts to sql quoted strings</span>
<a name="l01277"></a>01277     <span class="comment">//and clips them from the input string</span>
<a name="l01278"></a>01278 
<a name="l01279"></a>01279         <span class="keyword">static</span> <span class="keyword">const</span> var valuechars(L<span class="stringliteral">&quot;\&quot;&#39;.0123456789-+&quot;</span>);
<a name="l01280"></a>01280 
<a name="l01281"></a>01281         var word1=remainingwords.field(L<span class="stringliteral">&quot; &quot;</span>,1);
<a name="l01282"></a>01282         remainingwords=remainingwords.field(L<span class="stringliteral">&quot; &quot;</span>,2,99999);
<a name="l01283"></a>01283 
<a name="l01284"></a>01284         <span class="comment">//join quoted words together</span>
<a name="l01285"></a>01285         var char1=word1.substr(1,1);
<a name="l01286"></a>01286         <span class="keywordflow">if</span> ((char1==DQ||char1==SQ))
<a name="l01287"></a>01287         {
<a name="l01288"></a>01288                 <span class="keywordflow">while</span> (word1.substr(-1,1)!=char1)
<a name="l01289"></a>01289                 {
<a name="l01290"></a>01290                         <span class="keywordflow">if</span> (remainingwords.length())
<a name="l01291"></a>01291                         {
<a name="l01292"></a>01292                                 word1^=L<span class="stringliteral">&quot; &quot;</span>^remainingwords.field(L<span class="stringliteral">&quot; &quot;</span>,1);
<a name="l01293"></a>01293                                 remainingwords=remainingwords.field(L<span class="stringliteral">&quot; &quot;</span>,2,99999);
<a name="l01294"></a>01294                         }
<a name="l01295"></a>01295                         <span class="keywordflow">else</span>
<a name="l01296"></a>01296                         {
<a name="l01297"></a>01297                                 word1^=char1;
<a name="l01298"></a>01298                                 <span class="keywordflow">break</span>;
<a name="l01299"></a>01299                         }
<a name="l01300"></a>01300                 }
<a name="l01301"></a>01301         }
<a name="l01302"></a>01302 
<a name="l01303"></a>01303     tosqlstring(word1);
<a name="l01304"></a>01304 
<a name="l01305"></a>01305     <span class="comment">//grab multiple values (numbers or strings) separated by FM</span>
<a name="l01306"></a>01306         <span class="keywordflow">if</span> (valuechars.index(word1.substr(1,1)))
<a name="l01307"></a>01307         {
<a name="l01308"></a>01308                 word1 = SQ ^ word1.unquote() ^ SQ;
<a name="l01309"></a>01309 
<a name="l01310"></a>01310                 var nextword=remainingwords.field(L<span class="stringliteral">&quot; &quot;</span>,1);
<a name="l01311"></a>01311 
<a name="l01312"></a>01312                 <span class="comment">//&#39;x&#39; and &#39;y&#39; and &#39;z&#39; becomes &#39;x&#39; &#39;y&#39; &#39;z&#39;</span>
<a name="l01313"></a>01313                 <span class="comment">//to cater for WITH fieldname NOT &#39;X&#39; AND &#39;Y&#39; AND &#39;Z&#39;</span>
<a name="l01314"></a>01314                 <span class="comment">//duplicated above/below</span>
<a name="l01315"></a>01315                 <span class="keywordflow">if</span> (nextword==L<span class="stringliteral">&quot;AND&quot;</span>)
<a name="l01316"></a>01316                 {
<a name="l01317"></a>01317                         var nextword2=remainingwords;
<a name="l01318"></a>01318                         <span class="keywordflow">if</span> (valuechars.index(nextword2.substr(1,1)))
<a name="l01319"></a>01319                         {
<a name="l01320"></a>01320                                 nextword=nextword2;
<a name="l01321"></a>01321                                 remainingwords=remainingwords.field(L<span class="stringliteral">&quot; &quot;</span>,2,99999);
<a name="l01322"></a>01322                         }
<a name="l01323"></a>01323                 }
<a name="l01324"></a>01324 
<a name="l01325"></a>01325                 <span class="keywordflow">while</span> (nextword &amp;&amp; valuechars.index(nextword.substr(1,1)))
<a name="l01326"></a>01326                 {
<a name="l01327"></a>01327                         tosqlstring(nextword);
<a name="l01328"></a>01328                         <span class="keywordflow">if</span> (word1!=L<span class="stringliteral">&quot;&quot;</span>)
<a name="l01329"></a>01329                                 word1^=FM;
<a name="l01330"></a>01330                         word1 ^= SQ ^ nextword.unquote() ^ SQ;
<a name="l01331"></a>01331 
<a name="l01332"></a>01332                         remainingwords=remainingwords.field(L<span class="stringliteral">&quot; &quot;</span>,2,99999);
<a name="l01333"></a>01333                         nextword=remainingwords.field(L<span class="stringliteral">&quot; &quot;</span>,1);
<a name="l01334"></a>01334 
<a name="l01335"></a>01335                         <span class="comment">//&#39;x&#39; and &#39;y&#39; and &#39;z&#39; becomes &#39;x&#39; &#39;y&#39; &#39;z&#39;</span>
<a name="l01336"></a>01336                         <span class="comment">//to cater for WITH fieldname NOT &#39;X&#39; AND &#39;Y&#39; AND &#39;Z&#39;</span>
<a name="l01337"></a>01337                         <span class="comment">//duplicated above/below</span>
<a name="l01338"></a>01338                         <span class="keywordflow">if</span> (nextword==L<span class="stringliteral">&quot;AND&quot;</span>)
<a name="l01339"></a>01339                         {
<a name="l01340"></a>01340                                 var nextword2=remainingwords;
<a name="l01341"></a>01341                                 <span class="keywordflow">if</span> (valuechars.index(nextword2.substr(1,1)))
<a name="l01342"></a>01342                                 {
<a name="l01343"></a>01343                                         nextword=nextword2;
<a name="l01344"></a>01344                                         remainingwords=remainingwords.field(L<span class="stringliteral">&quot; &quot;</span>,2,99999);
<a name="l01345"></a>01345                                 }
<a name="l01346"></a>01346                         }
<a name="l01347"></a>01347 
<a name="l01348"></a>01348                 }
<a name="l01349"></a>01349         }<span class="keywordflow">else</span>{
<a name="l01350"></a>01350                 word1.ucaser();
<a name="l01351"></a>01351         }
<a name="l01352"></a>01352 
<a name="l01353"></a>01353     <span class="keywordflow">return</span> word1;
<a name="l01354"></a>01354 }
<a name="l01355"></a>01355 
<a name="l01356"></a>01356 <span class="keywordtype">bool</span> var::selectrecord(<span class="keyword">const</span> var&amp; sortselectclause)<span class="keyword"> const</span>
<a name="l01357"></a>01357 <span class="keyword"></span>{
<a name="l01358"></a>01358         THISIS(L<span class="stringliteral">&quot;bool var::selectrecord(const var&amp; sortselectclause) const&quot;</span>)
<a name="l01359"></a>01359         <span class="comment">//?allow undefined usage like var xyz=xyz.select();</span>
<a name="l01360"></a>01360         <span class="comment">//THISISDEFINED()</span>
<a name="l01361"></a>01361         ISSTRING(sortselectclause)
<a name="l01362"></a>01362 
<a name="l01363"></a>01363         return const_cast&lt;const var&amp;&gt;(*this).selectx(L&quot;key, data&quot;,sortselectclause);
<a name="l01364"></a>01364 }
<a name="l01365"></a>01365 
<a name="l01366"></a>01366 <span class="keywordtype">bool</span> var::select(const var&amp; sortselectclause)<span class="keyword"> const</span>
<a name="l01367"></a>01367 <span class="keyword"></span>{
<a name="l01368"></a>01368         THISIS(L<span class="stringliteral">&quot;bool var::select(const var&amp; sortselectclause) const&quot;</span>)
<a name="l01369"></a>01369         <span class="comment">//?allow undefined usage like var xyz=xyz.select();</span>
<a name="l01370"></a>01370         THISISDEFINED()
<a name="l01371"></a>01371         ISSTRING(sortselectclause)
<a name="l01372"></a>01372 
<a name="l01373"></a>01373         return selectx(L&quot;key&quot;,sortselectclause);
<a name="l01374"></a>01374 }
<a name="l01375"></a>01375 
<a name="l01376"></a>01376 <span class="keywordtype">bool</span> var::selectx(const var&amp; fieldnames, const var&amp; sortselectclause)<span class="keyword"> const</span>
<a name="l01377"></a>01377 <span class="keyword"></span>{
<a name="l01378"></a>01378         <span class="comment">//private unchecked</span>
<a name="l01379"></a>01379 
<a name="l01380"></a>01380         <span class="comment">//?allow undefined usage like var xyz=xyz.select();</span>
<a name="l01381"></a>01381         <span class="keywordflow">if</span> (var_mvtype&amp;mvtypemask)
<a name="l01382"></a>01382         {
<a name="l01383"></a>01383                 <span class="comment">//throw MVUndefined(L&quot;selectx()&quot;);</span>
<a name="l01384"></a>01384                 var_mvstr=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l01385"></a>01385                 var_mvtype=pimpl::MVTYPE_STR;
<a name="l01386"></a>01386         }
<a name="l01387"></a>01387 
<a name="l01388"></a>01388         <span class="keywordflow">if</span> (!(var_mvtype&amp;pimpl::MVTYPE_STR))
<a name="l01389"></a>01389         {
<a name="l01390"></a>01390                 <span class="keywordflow">if</span> (!var_mvtype)
<a name="l01391"></a>01391                 {
<a name="l01392"></a>01392                         var_mvstr=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l01393"></a>01393                         var_mvtype=pimpl::MVTYPE_STR;
<a name="l01394"></a>01394                 }
<a name="l01395"></a>01395                 <span class="keywordflow">else</span>
<a name="l01396"></a>01396                         createString();
<a name="l01397"></a>01397         }
<a name="l01398"></a>01398 
<a name="l01399"></a>01399         <span class="comment">//TODO only do this if cursor already exists</span>
<a name="l01400"></a>01400         <span class="comment">//clearselect();</span>
<a name="l01401"></a>01401 
<a name="l01402"></a>01402         var actualfilename=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l01403"></a>01403         var actualfieldnames=fieldnames;
<a name="l01404"></a>01404         var dictfile=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l01405"></a>01405         var keycodes=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l01406"></a>01406         var bykey=0;
<a name="l01407"></a>01407         var wordn;
<a name="l01408"></a>01408 
<a name="l01409"></a>01409         var whereclause=L<span class="stringliteral">&quot;&quot;</span>;<span class="comment">//exodus_call(&#39;NAME&#39;, &quot;^ filename ^ L&quot;.data, &quot; ^ filename ^ L&quot;.key,0,0) &lt;&gt; &#39;&#39; AND &quot;;</span>
<a name="l01410"></a>01410         var orderclause=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l01411"></a>01411         var joins=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l01412"></a>01412 
<a name="l01413"></a>01413         var maxnrecs=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l01414"></a>01414 
<a name="l01415"></a>01415         var remainingsortselectclause=sortselectclause;
<a name="l01416"></a>01416 
<a name="l01417"></a>01417         <span class="comment">//sortselectclause may start with {SELECT|SSELECT {maxnrecs} filename}</span>
<a name="l01418"></a>01418         var word=remainingsortselectclause.field(L<span class="stringliteral">&quot; &quot;</span>,1).ucase();
<a name="l01419"></a>01419     <span class="keywordflow">if</span> (word==L<span class="stringliteral">&quot;SELECT&quot;</span>||word==L<span class="stringliteral">&quot;SSELECT&quot;</span>)
<a name="l01420"></a>01420     {
<a name="l01421"></a>01421                 <span class="keywordflow">if</span> (word==L<span class="stringliteral">&quot;SSELECT&quot;</span>)
<a name="l01422"></a>01422                         bykey=1;
<a name="l01423"></a>01423 
<a name="l01424"></a>01424                 <span class="comment">//discard it and get the second word which is either max number of records or filename</span>
<a name="l01425"></a>01425                 getword(remainingsortselectclause);
<a name="l01426"></a>01426                 word=getword(remainingsortselectclause);
<a name="l01427"></a>01427 
<a name="l01428"></a>01428                 <span class="comment">//the second word can be a limiting number of records</span>
<a name="l01429"></a>01429                 <span class="keywordflow">if</span> (word.isnum())
<a name="l01430"></a>01430                 {
<a name="l01431"></a>01431                         maxnrecs=word;
<a name="l01432"></a>01432                         word=getword(remainingsortselectclause);
<a name="l01433"></a>01433                 }
<a name="l01434"></a>01434 
<a name="l01435"></a>01435                 actualfilename=word;
<a name="l01436"></a>01436 
<a name="l01437"></a>01437     }
<a name="l01438"></a>01438 
<a name="l01439"></a>01439         <span class="comment">//optionally get filename from the current var</span>
<a name="l01440"></a>01440         <span class="keywordflow">if</span> (!actualfilename)
<a name="l01441"></a>01441         {
<a name="l01442"></a>01442                 <span class="keywordflow">if</span> (!assigned())
<a name="l01443"></a>01443                         <span class="keywordflow">throw</span> MVUnassigned(L<span class="stringliteral">&quot;select() unassigned filehandle and sort/select clause doesnt start \&quot;SELECT filename\&quot;&quot;</span>);
<a name="l01444"></a>01444                 actualfilename=*<span class="keyword">this</span>;
<a name="l01445"></a>01445         }
<a name="l01446"></a>01446 
<a name="l01447"></a>01447     <span class="keywordflow">while</span> (remainingsortselectclause.length())
<a name="l01448"></a>01448     {
<a name="l01449"></a>01449 
<a name="l01450"></a>01450         var word1=getword(remainingsortselectclause);
<a name="l01451"></a>01451 
<a name="l01452"></a>01452         <span class="comment">//initial numbers or strings mean record keys</span>
<a name="l01453"></a>01453         <span class="keywordflow">if</span> (word1.substr(1,1).index(L<span class="stringliteral">&quot;\&quot;&#39;0123456789.&quot;</span>))
<a name="l01454"></a>01454         {
<a name="l01455"></a>01455             <span class="keywordflow">if</span> (keycodes)
<a name="l01456"></a>01456                 keycodes ^= FM;
<a name="l01457"></a>01457             keycodes ^= word1;
<a name="l01458"></a>01458             <span class="keywordflow">continue</span>;
<a name="l01459"></a>01459         }
<a name="l01460"></a>01460         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word1==L<span class="stringliteral">&quot;USING&quot;</span>)
<a name="l01461"></a>01461         {
<a name="l01462"></a>01462                         var dictfilename=getword(remainingsortselectclause);
<a name="l01463"></a>01463                         <span class="keywordflow">if</span> (!dictfile.open(L<span class="stringliteral">&quot;DICT&quot;</span>,dictfilename))
<a name="l01464"></a>01464                                 <span class="keywordflow">throw</span> MVDBException(L<span class="stringliteral">&quot;select() dict_&quot;</span> ^ dictfilename ^ L<span class="stringliteral">&quot; file cannot be opened&quot;</span>);
<a name="l01465"></a>01465         }
<a name="l01466"></a>01466         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word1==L<span class="stringliteral">&quot;BY&quot;</span> || word1==L<span class="stringliteral">&quot;BY-DSND&quot;</span>)
<a name="l01467"></a>01467         {
<a name="l01468"></a>01468             <span class="keywordflow">if</span> (orderclause)
<a name="l01469"></a>01469                 orderclause^=L<span class="stringliteral">&quot;, &quot;</span>;
<a name="l01470"></a>01470             var dictexpression=getdictexpression(actualfilename,actualfilename,dictfile,getword(remainingsortselectclause),joins,<span class="keyword">true</span>);
<a name="l01471"></a>01471             orderclause ^= dictexpression;
<a name="l01472"></a>01472             <span class="keywordflow">if</span> (word1==L<span class="stringliteral">&quot;BY-DSND&quot;</span>)
<a name="l01473"></a>01473                 orderclause^=L<span class="stringliteral">&quot; DESC&quot;</span>;
<a name="l01474"></a>01474         }
<a name="l01475"></a>01475 <span class="comment">//           else if (word1==L&quot;BETWEEN&quot;)</span>
<a name="l01476"></a>01476 <span class="comment">//           {</span>
<a name="l01477"></a>01477 <span class="comment">//               var word2=getword(remainingsortselectclause);</span>
<a name="l01478"></a>01478 <span class="comment">//               whereclause ^= word2;</span>
<a name="l01479"></a>01479 <span class="comment">//           }</span>
<a name="l01480"></a>01480                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word1==L<span class="stringliteral">&quot;WITH&quot;</span>)
<a name="l01481"></a>01481                 {
<a name="l01482"></a>01482 
<a name="l01483"></a>01483                         <span class="comment">//add the dictionary id</span>
<a name="l01484"></a>01484             var word2=getword(remainingsortselectclause);
<a name="l01485"></a>01485                         var dictexpression=getdictexpression(actualfilename,actualfilename,dictfile,word2,joins,<span class="keyword">true</span>);
<a name="l01486"></a>01486                         var usingnaturalorder=dictexpression.index(L<span class="stringliteral">&quot;exodus_extract_sort&quot;</span>);
<a name="l01487"></a>01487             whereclause ^= L<span class="stringliteral">&quot; &quot;</span> ^ dictexpression;
<a name="l01488"></a>01488 
<a name="l01489"></a>01489                         <span class="comment">//handle STARTING, ENDING and CONTAINING</span>
<a name="l01490"></a>01490             word2=getword(remainingsortselectclause);
<a name="l01491"></a>01491                         var startingpercent=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l01492"></a>01492                         var endingpercent=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l01493"></a>01493                         <span class="keywordflow">if</span> (word2==L<span class="stringliteral">&quot;CONTAINING&quot;</span>)
<a name="l01494"></a>01494                         {
<a name="l01495"></a>01495                                 word2=L<span class="stringliteral">&quot;LIKE&quot;</span>;
<a name="l01496"></a>01496                                 startingpercent=L<span class="stringliteral">&quot;%&quot;</span>;
<a name="l01497"></a>01497                                 endingpercent=L<span class="stringliteral">&quot;%&quot;</span>;
<a name="l01498"></a>01498                         }
<a name="l01499"></a>01499                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word2==L<span class="stringliteral">&quot;STARTING&quot;</span>)
<a name="l01500"></a>01500                         {
<a name="l01501"></a>01501                                 word2=L<span class="stringliteral">&quot;LIKE&quot;</span>;
<a name="l01502"></a>01502                                 endingpercent=L<span class="stringliteral">&quot;%&quot;</span>;
<a name="l01503"></a>01503                         }
<a name="l01504"></a>01504                         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word2==L<span class="stringliteral">&quot;ENDING&quot;</span>)
<a name="l01505"></a>01505                         {
<a name="l01506"></a>01506                                 word2=L<span class="stringliteral">&quot;LIKE&quot;</span>;
<a name="l01507"></a>01507                                 startingpercent=L<span class="stringliteral">&quot;%&quot;</span>;
<a name="l01508"></a>01508                         }
<a name="l01509"></a>01509                         <span class="keywordflow">if</span> (word2==L<span class="stringliteral">&quot;LIKE&quot;</span>)
<a name="l01510"></a>01510                         {
<a name="l01511"></a>01511 
<a name="l01512"></a>01512                                 var word2=getword(remainingsortselectclause);
<a name="l01513"></a>01513                                 <span class="keywordflow">if</span> (endingpercent)
<a name="l01514"></a>01514                                 {
<a name="l01515"></a>01515                                         word2.swapper(L<span class="stringliteral">&quot;&#39;&quot;</span> ^ FM, L<span class="stringliteral">&quot;%&#39;&quot;</span> ^ FM);
<a name="l01516"></a>01516                                         word2.splicer(-1,0,L<span class="stringliteral">&quot;%&quot;</span>);
<a name="l01517"></a>01517                                 }
<a name="l01518"></a>01518                                 <span class="keywordflow">if</span> (startingpercent)
<a name="l01519"></a>01519                                 {
<a name="l01520"></a>01520                                         word2.swapper(FM ^ L<span class="stringliteral">&quot;&#39;&quot;</span>, FM ^ L<span class="stringliteral">&quot;&#39;%&quot;</span>);
<a name="l01521"></a>01521                                         word2.splicer(2,0,L<span class="stringliteral">&quot;%&quot;</span>);
<a name="l01522"></a>01522                                 }
<a name="l01523"></a>01523 
<a name="l01524"></a>01524                                 whereclause ^= L<span class="stringliteral">&quot; LIKE &quot;</span> ^ word2;
<a name="l01525"></a>01525 
<a name="l01526"></a>01526                                 <span class="keywordflow">continue</span>;
<a name="l01527"></a>01527                         }
<a name="l01528"></a>01528 
<a name="l01529"></a>01529             <span class="comment">//convert neosys relational operators to standard relational operators</span>
<a name="l01530"></a>01530                 var aliasno;
<a name="l01531"></a>01531                     <span class="keywordflow">if</span> (var(L<span class="stringliteral">&quot;EQ,NE,NOT,GT,LT,GE,LE&quot;</span>).locateusing(word2,L<span class="stringliteral">&quot;,&quot;</span>,aliasno))
<a name="l01532"></a>01532                         {
<a name="l01533"></a>01533                                 word2=var(L<span class="stringliteral">&quot;=,&lt;&gt;,&lt;&gt;,&gt;,&lt;,&gt;=,&lt;=&quot;</span>).field(L<span class="stringliteral">&quot;,&quot;</span>,aliasno);
<a name="l01534"></a>01534                         }
<a name="l01535"></a>01535 
<a name="l01536"></a>01536                         <span class="comment">//output relational operators and get the value</span>
<a name="l01537"></a>01537                     <span class="keywordflow">if</span> (var(L<span class="stringliteral">&quot;=,&lt;&gt;,&gt;,&lt;,&gt;=,&lt;=&quot;</span>).locateusing(word2,L<span class="stringliteral">&quot;,&quot;</span>,aliasno))
<a name="l01538"></a>01538                         {
<a name="l01539"></a>01539                                 whereclause ^= L<span class="stringliteral">&quot; &quot;</span> ^ word2 ^ L<span class="stringliteral">&quot; &quot;</span>;
<a name="l01540"></a>01540                                 word2=getword(remainingsortselectclause);
<a name="l01541"></a>01541                         }
<a name="l01542"></a>01542                         <span class="keywordflow">else</span>
<a name="l01543"></a>01543                         {
<a name="l01544"></a>01544                                 <span class="comment">//if value follows dictionary id without a relational operator then insert =</span>
<a name="l01545"></a>01545                                 <span class="keywordflow">if</span> (word2.substr(1,1)==L<span class="stringliteral">&quot;&#39;&quot;</span>)
<a name="l01546"></a>01546                                         whereclause ^= L<span class="stringliteral">&quot; = &quot;</span>;
<a name="l01547"></a>01547                         }
<a name="l01548"></a>01548 
<a name="l01549"></a>01549                         <span class="keywordflow">if</span> (word2==L<span class="stringliteral">&quot;BETWEEN&quot;</span>)
<a name="l01550"></a>01550                         {
<a name="l01551"></a>01551                                 <span class="comment">//get and append &quot;from&quot; value</span>
<a name="l01552"></a>01552                 word2=getword(remainingsortselectclause);
<a name="l01553"></a>01553                                 <span class="keywordflow">if</span> (usingnaturalorder)
<a name="l01554"></a>01554                                         word2=naturalorder(word2.tostring());
<a name="l01555"></a>01555                                 whereclause ^= L<span class="stringliteral">&quot; BETWEEN &quot;</span> ^ word2;
<a name="l01556"></a>01556 
<a name="l01557"></a>01557                                 <span class="comment">//get, check, discard AND</span>
<a name="l01558"></a>01558                                 word2=getword(remainingsortselectclause);
<a name="l01559"></a>01559                                 <span class="keywordflow">if</span> (word2 != L<span class="stringliteral">&quot;AND&quot;</span>)
<a name="l01560"></a>01560                                         <span class="keywordflow">throw</span> MVDBException(L<span class="stringliteral">&quot;SELECT STATEMENT SYNTAX IS &#39;BETWEEN x *AND* y&#39;&quot;</span>);
<a name="l01561"></a>01561 
<a name="l01562"></a>01562                                 whereclause ^= L<span class="stringliteral">&quot; AND &quot;</span>;
<a name="l01563"></a>01563 
<a name="l01564"></a>01564                                 <span class="comment">//get &quot;to&quot; value</span>
<a name="l01565"></a>01565                                 word2=getword(remainingsortselectclause);
<a name="l01566"></a>01566 
<a name="l01567"></a>01567                         }
<a name="l01568"></a>01568 
<a name="l01569"></a>01569                         <span class="comment">//TODO how to get sql to understand &#39;&#39; and 0 as nothing without resorting to numerics</span>
<a name="l01570"></a>01570                         <span class="comment">//WITH X becomes WITH X &lt;&gt; &#39;&#39;</span>
<a name="l01571"></a>01571                         <span class="keywordflow">if</span> (!word2.length() &amp;&amp; !var(L<span class="stringliteral">&quot;.0123456789&#39;\&quot;&quot;</span>).index(word2.substr(1,1)))
<a name="l01572"></a>01572                         {
<a name="l01573"></a>01573                                 <span class="comment">//put the current word back on the pending</span>
<a name="l01574"></a>01574                                 <span class="keywordflow">if</span> (word.length())
<a name="l01575"></a>01575                                         remainingsortselectclause.splicer(1,0,word2 ^ L<span class="stringliteral">&quot; &quot;</span>);
<a name="l01576"></a>01576                                 word2=L<span class="stringliteral">&quot; &lt;&gt; &#39;&#39;&quot;</span>;
<a name="l01577"></a>01577                         }
<a name="l01578"></a>01578 
<a name="l01579"></a>01579                         <span class="comment">//convert to IN clause if multiple values</span>
<a name="l01580"></a>01580             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (word2.index(FM))
<a name="l01581"></a>01581                         {
<a name="l01582"></a>01582 
<a name="l01583"></a>01583                                 <span class="comment">//prevent  &quot; = IN ( ... )&quot;</span>
<a name="l01584"></a>01584                                 <span class="keywordflow">if</span> (whereclause.substr(-3,3)==L<span class="stringliteral">&quot; = &quot;</span>)
<a name="l01585"></a>01585                                         whereclause.splicer(-3,3,L<span class="stringliteral">&quot;&quot;</span>);
<a name="l01586"></a>01586 
<a name="l01587"></a>01587                                 word2=L<span class="stringliteral">&quot; IN ( &quot;</span> ^ word2.swap(FM, L<span class="stringliteral">&quot;, &quot;</span>) ^ L<span class="stringliteral">&quot; ) &quot;</span>;
<a name="l01588"></a>01588                         }
<a name="l01589"></a>01589 
<a name="l01590"></a>01590                         <span class="comment">//append value(s)</span>
<a name="l01591"></a>01591                         <span class="keywordflow">if</span> (usingnaturalorder)
<a name="l01592"></a>01592                                 word2=naturalorder(word2.tostring());
<a name="l01593"></a>01593             whereclause ^= word2;
<a name="l01594"></a>01594 
<a name="l01595"></a>01595         }
<a name="l01596"></a>01596         <span class="keywordflow">else</span>
<a name="l01597"></a>01597         {
<a name="l01598"></a>01598                         <span class="comment">//todo exclude any ordinary fields included in select?</span>
<a name="l01599"></a>01599 
<a name="l01600"></a>01600                         <span class="comment">//and or ( ) and anything else is copied to the where clause</span>
<a name="l01601"></a>01601             whereclause ^= L<span class="stringliteral">&quot; &quot;</span> ^ word1;
<a name="l01602"></a>01602         }
<a name="l01603"></a>01603     }<span class="comment">//getword loop</span>
<a name="l01604"></a>01604 
<a name="l01605"></a>01605     <span class="keywordflow">if</span> (keycodes)
<a name="l01606"></a>01606     {
<a name="l01607"></a>01607         <span class="keywordflow">if</span> (keycodes.count(FM))
<a name="l01608"></a>01608         {
<a name="l01609"></a>01609             keycodes=L<span class="stringliteral">&quot;key IN ( &quot;</span> ^ keycodes.swap(FM,L<span class="stringliteral">&quot;, &quot;</span>) ^ L<span class="stringliteral">&quot; )&quot;</span>;
<a name="l01610"></a>01610             <span class="keywordflow">if</span> (whereclause)
<a name="l01611"></a>01611                 whereclause=L<span class="stringliteral">&quot; AND ( &quot;</span> ^ whereclause ^ L<span class="stringliteral">&quot; ) &quot;</span>;
<a name="l01612"></a>01612             whereclause=keycodes ^ whereclause;
<a name="l01613"></a>01613         }
<a name="l01614"></a>01614     }
<a name="l01615"></a>01615 
<a name="l01616"></a>01616         <span class="comment">//sselect add by key on the end of any specific order bys</span>
<a name="l01617"></a>01617         <span class="keywordflow">if</span> (bykey)
<a name="l01618"></a>01618         {
<a name="l01619"></a>01619                 <span class="keywordflow">if</span> (orderclause)
<a name="l01620"></a>01620                     orderclause^=L<span class="stringliteral">&quot;, &quot;</span>;
<a name="l01621"></a>01621                 orderclause^=L<span class="stringliteral">&quot;key&quot;</span>;
<a name="l01622"></a>01622         }
<a name="l01623"></a>01623 
<a name="l01624"></a>01624         <span class="comment">//assemble the full sql select statement</span>
<a name="l01625"></a>01625     var sql=L<span class="stringliteral">&quot;DECLARE CURSOR1_&quot;</span> ^ (*this) ^ L<span class="stringliteral">&quot; CURSOR FOR SELECT &quot;</span> ^ actualfieldnames ^ L<span class="stringliteral">&quot; FROM &quot;</span>;
<a name="l01626"></a>01626     sql ^= PGDATAFILEPREFIX ^ actualfilename;
<a name="l01627"></a>01627         <span class="keywordflow">if</span> (joins)
<a name="l01628"></a>01628                 sql ^= L<span class="stringliteral">&quot; &quot;</span> ^ joins.swap(VM,L<span class="stringliteral">&quot; &quot;</span>);
<a name="l01629"></a>01629         <span class="keywordflow">if</span> (whereclause)
<a name="l01630"></a>01630                 sql ^= L<span class="stringliteral">&quot; WHERE &quot;</span> ^ whereclause;
<a name="l01631"></a>01631         <span class="keywordflow">if</span> (orderclause)
<a name="l01632"></a>01632                 sql ^= L<span class="stringliteral">&quot; ORDER BY &quot;</span> ^ orderclause;
<a name="l01633"></a>01633         <span class="keywordflow">if</span> (maxnrecs)
<a name="l01634"></a>01634                 sql ^= L<span class="stringliteral">&quot; LIMIT &quot;</span> ^ maxnrecs;
<a name="l01635"></a>01635 
<a name="l01636"></a>01636 <span class="comment">//outputln(sql);</span>
<a name="l01637"></a>01637 
<a name="l01638"></a>01638         <span class="comment">//Start a transaction block because postgres select requires to be inside one</span>
<a name="l01639"></a>01639         <span class="keywordflow">if</span> (!begin())
<a name="l01640"></a>01640                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01641"></a>01641 
<a name="l01642"></a>01642         <span class="comment">//execute the sql</span>
<a name="l01643"></a>01643         connection();
<a name="l01644"></a>01644         PGresultptr pgresult;
<a name="l01645"></a>01645         <span class="keywordflow">if</span> (!pqexec(sql,pgresult))
<a name="l01646"></a>01646                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01647"></a>01647 
<a name="l01648"></a>01648         PQclear(pgresult);
<a name="l01649"></a>01649 
<a name="l01650"></a>01650         <span class="comment">//allow select to be an assignment where filename becomes the cursor name</span>
<a name="l01651"></a>01651         <span class="comment">//if actual file is in the sortselectclause</span>
<a name="l01652"></a>01652         <span class="comment">//blank doesnt result in assignment so it can be used as a default &quot;anonymous&quot; cursor</span>
<a name="l01653"></a>01653         <span class="keywordflow">if</span> (unassigned())
<a name="l01654"></a>01654         {
<a name="l01655"></a>01655                 <span class="comment">//(*this)=actualfilename;</span>
<a name="l01656"></a>01656                 <span class="comment">//changed to allow select to be const so allowing file vars to be passed as const (&quot;in&quot;) function parameters</span>
<a name="l01657"></a>01657                 var_mvstr=actualfilename.var_mvstr;
<a name="l01658"></a>01658                 var_mvtype=pimpl::MVTYPE_STR;
<a name="l01659"></a>01659         }
<a name="l01660"></a>01660         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01661"></a>01661 }
<a name="l01662"></a>01662 
<a name="l01663"></a>01663 <span class="keywordtype">void</span> var::clearselect()<span class="keyword"> const</span>
<a name="l01664"></a>01664 <span class="keyword"></span>{
<a name="l01665"></a>01665         THISIS(L<span class="stringliteral">&quot;void var::clearselect() const&quot;</span>)
<a name="l01666"></a>01666         THISISSTRING()
<a name="l01667"></a>01667 
<a name="l01668"></a>01668     var sql=L&quot;CLOSE CURSOR1_&quot;;
<a name="l01669"></a>01669     if (var_mvtype)
<a name="l01670"></a>01670                 sql ^= *this;
<a name="l01671"></a>01671 
<a name="l01672"></a>01672         <span class="comment">//execute the sql</span>
<a name="l01673"></a>01673         connection();
<a name="l01674"></a>01674         PGresultptr result;
<a name="l01675"></a>01675         if (!pqexec(sql,result))
<a name="l01676"></a>01676                 return;
<a name="l01677"></a>01677 
<a name="l01678"></a>01678         PQclear(result);
<a name="l01679"></a>01679 
<a name="l01680"></a>01680         <span class="comment">// end the transaction</span>
<a name="l01681"></a>01681         end();
<a name="l01682"></a>01682 
<a name="l01683"></a>01683         return;
<a name="l01684"></a>01684 
<a name="l01685"></a>01685 }
<a name="l01686"></a>01686 
<a name="l01687"></a>01687 <span class="keywordtype">bool</span> var::readnext(var&amp; key)<span class="keyword"> const</span>
<a name="l01688"></a>01688 <span class="keyword"></span>{
<a name="l01689"></a>01689         var valuen;
<a name="l01690"></a>01690         <span class="keywordflow">return</span> readnext(key, valuen);
<a name="l01691"></a>01691 }
<a name="l01692"></a>01692 
<a name="l01693"></a>01693 <span class="keywordtype">bool</span> readnextx(<span class="keyword">const</span> std::wstring&amp; cursor, PGresultptr&amp; pgresult)
<a name="l01694"></a>01694 {
<a name="l01695"></a>01695     var sql=L<span class="stringliteral">&quot;FETCH NEXT in CURSOR1_&quot;</span> ^ cursor;
<a name="l01696"></a>01696 
<a name="l01697"></a>01697         <span class="comment">//execute the sql</span>
<a name="l01698"></a>01698         <span class="keywordflow">if</span> (!pqexec(sql,pgresult))
<a name="l01699"></a>01699                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01700"></a>01700 
<a name="l01701"></a>01701     <span class="comment">//close cursor if no more</span>
<a name="l01702"></a>01702         <span class="keywordflow">if</span> (PQntuples(pgresult) &lt; 1)
<a name="l01703"></a>01703         {
<a name="l01704"></a>01704                 PQclear(pgresult);
<a name="l01705"></a>01705 
<a name="l01706"></a>01706                 <span class="comment">// close the cursor - we don&#39;t bother to check for errors</span>
<a name="l01707"></a>01707                 var sql=L<span class="stringliteral">&quot;CLOSE CURSOR1_&quot;</span> ^ cursor;
<a name="l01708"></a>01708 
<a name="l01709"></a>01709                 <span class="comment">//execute the sql</span>
<a name="l01710"></a>01710                 <span class="keywordflow">if</span> (pqexec(sql,pgresult))
<a name="l01711"></a>01711                         PQclear(pgresult);
<a name="l01712"></a>01712 
<a name="l01713"></a>01713                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01714"></a>01714 
<a name="l01715"></a>01715         }
<a name="l01716"></a>01716 
<a name="l01717"></a>01717         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01718"></a>01718 
<a name="l01719"></a>01719 }
<a name="l01720"></a>01720 
<a name="l01721"></a>01721 <span class="keywordtype">bool</span> var::readnext(var&amp; key, var&amp; valuen)<span class="keyword"> const</span>
<a name="l01722"></a>01722 <span class="keyword"></span>{
<a name="l01723"></a>01723         <span class="comment">//?allow undefined usage like var xyz=xyz.readnext();</span>
<a name="l01724"></a>01724         <span class="keywordflow">if</span> (var_mvtype&amp;mvtypemask)
<a name="l01725"></a>01725         {
<a name="l01726"></a>01726                 <span class="comment">//throw MVUndefined(L&quot;selectx()&quot;);</span>
<a name="l01727"></a>01727                 var_mvstr=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l01728"></a>01728                 var_mvtype=pimpl::MVTYPE_STR;
<a name="l01729"></a>01729         }
<a name="l01730"></a>01730 
<a name="l01731"></a>01731         THISIS(L<span class="stringliteral">&quot;bool var::readnext(var&amp; key, var&amp; valuen) const&quot;</span>)
<a name="l01732"></a>01732         THISISSTRING()
<a name="l01733"></a>01733 
<a name="l01734"></a>01734         connection();
<a name="l01735"></a>01735         PGresultptr pgresult;
<a name="l01736"></a>01736         if (!readnextx(var_mvstr, pgresult))
<a name="l01737"></a>01737         {
<a name="l01738"></a>01738                 <span class="comment">// end the transaction and quit</span>
<a name="l01739"></a>01739                 end();
<a name="l01740"></a>01740                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01741"></a>01741         }
<a name="l01742"></a>01742 
<a name="l01743"></a>01743         <span class="comment">//get the key from the first and only column</span>
<a name="l01744"></a>01744         <span class="comment">//char* data = PQgetvalue(result, 0, 0);</span>
<a name="l01745"></a>01745         <span class="comment">//int datalen = PQgetlength(result, 0, 0);</span>
<a name="l01746"></a>01746         <span class="comment">//key=std::string(data,datalen);</span>
<a name="l01747"></a>01747         key=wstringfromUTF8((UTF8*)PQgetvalue(pgresult, 0, 0), PQgetlength(pgresult, 0, 0));
<a name="l01748"></a>01748 
<a name="l01749"></a>01749         <span class="comment">//TODO implement order by multivalue</span>
<a name="l01750"></a>01750         valuen = 0;
<a name="l01751"></a>01751 
<a name="l01752"></a>01752         PQclear(pgresult);
<a name="l01753"></a>01753 
<a name="l01754"></a>01754         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01755"></a>01755 
<a name="l01756"></a>01756 <span class="comment">/*how to access multiple records and fields*/</span>
<a name="l01757"></a>01757 <span class="preprocessor">#if 0</span>
<a name="l01758"></a>01758 <span class="preprocessor"></span>    <span class="comment">/* first, print out the attribute names */</span>
<a name="l01759"></a>01759     <span class="keywordtype">int</span> nFields = PQnfields(result);
<a name="l01760"></a>01760     <span class="keywordflow">for</span> (i = 0; i &lt; nFields; i++)
<a name="l01761"></a>01761         wprintf(L<span class="stringliteral">&quot;%-15s&quot;</span>, PQfname(result, i));
<a name="l01762"></a>01762     wprintf(L<span class="stringliteral">&quot;\n\n&quot;</span>);
<a name="l01763"></a>01763 
<a name="l01764"></a>01764     <span class="comment">/* next, print out the rows */</span>
<a name="l01765"></a>01765     <span class="keywordflow">for</span> (i = 0; i &lt; PQntuples(result); i++)
<a name="l01766"></a>01766     {
<a name="l01767"></a>01767         <span class="keywordflow">for</span> (j = 0; j &lt; nFields; j++)
<a name="l01768"></a>01768             wprintf(L<span class="stringliteral">&quot;%-15s&quot;</span>, PQgetvalue(result, i, j));
<a name="l01769"></a>01769         wprintf(L<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l01770"></a>01770     }
<a name="l01771"></a>01771 <span class="preprocessor">#endif</span>
<a name="l01772"></a>01772 <span class="preprocessor"></span>
<a name="l01773"></a>01773 }
<a name="l01774"></a>01774 
<a name="l01775"></a>01775 <span class="comment">//TODO</span>
<a name="l01776"></a>01776 var var::calculate()<span class="keyword"> const</span>
<a name="l01777"></a>01777 <span class="keyword"></span>{
<a name="l01778"></a>01778         <span class="keywordflow">return</span> L<span class="stringliteral">&quot;&quot;</span>;
<a name="l01779"></a>01779 }
<a name="l01780"></a>01780 
<a name="l01781"></a>01781 <span class="keywordtype">bool</span> var::readnextrecord(var&amp; key, var&amp; record)<span class="keyword"> const</span>
<a name="l01782"></a>01782 <span class="keyword"></span>{
<a name="l01783"></a>01783 
<a name="l01784"></a>01784         <span class="comment">//?allow undefined usage like var xyz=xyz.readnext();</span>
<a name="l01785"></a>01785         <span class="keywordflow">if</span> (var_mvtype&amp;mvtypemask || !var_mvtype)
<a name="l01786"></a>01786         {
<a name="l01787"></a>01787                 <span class="comment">//throw MVUndefined(L&quot;selectx()&quot;);</span>
<a name="l01788"></a>01788                 var_mvstr=L<span class="stringliteral">&quot;&quot;</span>;
<a name="l01789"></a>01789                 var_mvtype=pimpl::MVTYPE_STR;
<a name="l01790"></a>01790         }
<a name="l01791"></a>01791 
<a name="l01792"></a>01792         THISIS(L<span class="stringliteral">&quot;bool var::readnextrecord(var&amp; key, var&amp; record) const&quot;</span>)
<a name="l01793"></a>01793         THISISSTRING()
<a name="l01794"></a>01794         ISDEFINED(key)
<a name="l01795"></a>01795         ISDEFINED(record)
<a name="l01796"></a>01796 
<a name="l01797"></a>01797         connection();
<a name="l01798"></a>01798         PGresultptr pgresult;
<a name="l01799"></a>01799         if (!readnextx(var_mvstr, pgresult))
<a name="l01800"></a>01800         {
<a name="l01801"></a>01801                 <span class="comment">// end the transaction</span>
<a name="l01802"></a>01802                 end();
<a name="l01803"></a>01803                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01804"></a>01804         }
<a name="l01805"></a>01805 
<a name="l01806"></a>01806         <span class="comment">//key is first column</span>
<a name="l01807"></a>01807         <span class="comment">//char* data = PQgetvalue(result, 0, 0);</span>
<a name="l01808"></a>01808         <span class="comment">//int datalen = PQgetlength(result, 0, 0);</span>
<a name="l01809"></a>01809         <span class="comment">//key=std::string(data,datalen);</span>
<a name="l01810"></a>01810         key=wstringfromUTF8((UTF8*)PQgetvalue(pgresult, 0, 0), PQgetlength(pgresult, 0, 0));
<a name="l01811"></a>01811         
<a name="l01812"></a>01812         <span class="comment">//record is second column</span>
<a name="l01813"></a>01813         <span class="comment">//data = PQgetvalue(result, 0, 1);</span>
<a name="l01814"></a>01814         <span class="comment">//datalen = PQgetlength(result, 0, 1);</span>
<a name="l01815"></a>01815         <span class="comment">//record=std::string(data,datalen);</span>
<a name="l01816"></a>01816         record=wstringfromUTF8((UTF8*)PQgetvalue(pgresult, 0, 1), PQgetlength(pgresult, 0, 1));
<a name="l01817"></a>01817 
<a name="l01818"></a>01818     PQclear(pgresult);
<a name="l01819"></a>01819 
<a name="l01820"></a>01820         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01821"></a>01821 
<a name="l01822"></a>01822 }
<a name="l01823"></a>01823 
<a name="l01824"></a>01824 <span class="keywordtype">bool</span> var::createindex(<span class="keyword">const</span> var&amp; fieldname, <span class="keyword">const</span> var&amp; dictfile)<span class="keyword"> const</span>
<a name="l01825"></a>01825 <span class="keyword"></span>{
<a name="l01826"></a>01826         THISIS(L<span class="stringliteral">&quot;bool var::createindex(const var&amp; fieldname, const var&amp; dictfile) const&quot;</span>)
<a name="l01827"></a>01827         THISISSTRING()
<a name="l01828"></a>01828         ISSTRING(fieldname)
<a name="l01829"></a>01829         ISSTRING(dictfile)
<a name="l01830"></a>01830 
<a name="l01831"></a>01831         var filename=*this;
<a name="l01832"></a>01832 
<a name="l01833"></a>01833         <span class="comment">//actual dictfile to use is either given or defaults to that of the filename</span>
<a name="l01834"></a>01834         var actualdictfile;
<a name="l01835"></a>01835         if (dictfile.assigned() and dictfile != L&quot;&quot;)
<a name="l01836"></a>01836                 actualdictfile=dictfile;
<a name="l01837"></a>01837         else
<a name="l01838"></a>01838                 actualdictfile=L&quot;dict_&quot; ^ filename;
<a name="l01839"></a>01839 
<a name="l01840"></a>01840         <span class="comment">//example sql</span>
<a name="l01841"></a>01841         <span class="comment">//create index ads__brand_code on ads (exodus_extract_text(data,3,0,0));</span>
<a name="l01842"></a>01842 
<a name="l01843"></a>01843         <span class="comment">//throws if cannot find dict file or record</span>
<a name="l01844"></a>01844         var joins=L&quot;&quot;;<span class="comment">//throw away - cant index on joined fields at the moment</span>
<a name="l01845"></a>01845         var dictexpression=getdictexpression(filename,filename,actualdictfile,fieldname,joins,true);
<a name="l01846"></a>01846 
<a name="l01847"></a>01847         var sql=L&quot;create index index__&quot; ^ filename ^ L&quot;__&quot; ^ fieldname ^ L&quot; on &quot; ^ filename;
<a name="l01848"></a>01848         sql^=L&quot; (&quot;;
<a name="l01849"></a>01849         sql^=dictexpression;
<a name="l01850"></a>01850         sql^=L&quot;)&quot;;
<a name="l01851"></a>01851 
<a name="l01852"></a>01852         <span class="comment">//execute the command</span>
<a name="l01853"></a>01853         connection();
<a name="l01854"></a>01854         PGresultptr result;
<a name="l01855"></a>01855         if (!pqexec(sql,result))
<a name="l01856"></a>01856                 return false;
<a name="l01857"></a>01857 
<a name="l01858"></a>01858         PQclear(result);
<a name="l01859"></a>01859         return true;
<a name="l01860"></a>01860 
<a name="l01861"></a>01861 }
<a name="l01862"></a>01862 
<a name="l01863"></a>01863 <span class="keywordtype">bool</span> var::deleteindex(const var&amp; fieldname)<span class="keyword"> const</span>
<a name="l01864"></a>01864 <span class="keyword"></span>{
<a name="l01865"></a>01865         THISIS(L<span class="stringliteral">&quot;bool var::deleteindex(const var&amp; fieldname) const&quot;</span>)
<a name="l01866"></a>01866         THISISSTRING()
<a name="l01867"></a>01867         ISSTRING(fieldname)
<a name="l01868"></a>01868 
<a name="l01869"></a>01869         <span class="comment">//var filename=*this;</span>
<a name="l01870"></a>01870         var sql=L&quot;drop index index__&quot; ^ *this ^ L&quot;__&quot; ^ fieldname;
<a name="l01871"></a>01871 
<a name="l01872"></a>01872         <span class="comment">//execute the sql</span>
<a name="l01873"></a>01873         connection();
<a name="l01874"></a>01874         PGresultptr result;
<a name="l01875"></a>01875         if (!pqexec(sql,result))
<a name="l01876"></a>01876                 return false;
<a name="l01877"></a>01877 
<a name="l01878"></a>01878         PQclear(result);
<a name="l01879"></a>01879         return true;
<a name="l01880"></a>01880         
<a name="l01881"></a>01881 }
<a name="l01882"></a>01882 
<a name="l01883"></a>01883 <span class="comment">/*</span>
<a name="l01884"></a>01884 <span class="comment">http://www.petefreitag.com/item/666.cfm</span>
<a name="l01885"></a>01885 <span class="comment">information_schema is am SQL-92 standard for accessinging information about the tables etc in a database</span>
<a name="l01886"></a>01886 <span class="comment">    * Microsoft SQL Server - Supported in Version 7 and up</span>
<a name="l01887"></a>01887 <span class="comment">    * MySQL - Supported in Version 5 and up</span>
<a name="l01888"></a>01888 <span class="comment">    * PostgreSQL - Supported in Version 7.4 and up</span>
<a name="l01889"></a>01889 <span class="comment"></span>
<a name="l01890"></a>01890 <span class="comment">    * Oracle - Does not appear to be supported</span>
<a name="l01891"></a>01891 <span class="comment">    * Apache Derby - NOT Supported As of Version 10.3</span>
<a name="l01892"></a>01892 <span class="comment">        * DB2 - NOT supported?</span>
<a name="l01893"></a>01893 <span class="comment">*/</span>
<a name="l01894"></a>01894 
<a name="l01895"></a>01895 var var::listfiles()<span class="keyword"> const</span>
<a name="l01896"></a>01896 <span class="keyword"></span>{
<a name="l01897"></a>01897         THISIS(L<span class="stringliteral">&quot;var var::listfiles() const&quot;</span>)
<a name="l01898"></a>01898         <span class="comment">//could allow undefined usage since *this isnt used?</span>
<a name="l01899"></a>01899         THISISDEFINED()
<a name="l01900"></a>01900 
<a name="l01901"></a>01901         <span class="comment">//from http://www.alberton.info/postgresql_meta_info.html</span>
<a name="l01902"></a>01902 
<a name="l01903"></a>01903         var sql=L&quot;SELECT table_name FROM information_schema.tables WHERE table_type = &#39;BASE TABLE&#39; AND table_schema NOT IN (&#39;pg_catalog&#39;, &#39;information_schema&#39;); &quot;;
<a name="l01904"></a>01904 
<a name="l01905"></a>01905         <span class="comment">//execute command or return empty string</span>
<a name="l01906"></a>01906         connection();
<a name="l01907"></a>01907         PGresultptr result;
<a name="l01908"></a>01908         if (!pqexec(sql,result))
<a name="l01909"></a>01909                 return L&quot;&quot;;
<a name="l01910"></a>01910 
<a name="l01911"></a>01911         var filenames=L&quot;&quot;;
<a name="l01912"></a>01912         <span class="keywordtype">int</span> nfiles=PQntuples(result);
<a name="l01913"></a>01913         for (<span class="keywordtype">int</span> filen=0; filen&lt;nfiles; filen++)
<a name="l01914"></a>01914         {
<a name="l01915"></a>01915                 <span class="keywordflow">if</span>      (!PQgetisnull(result, filen, 0))
<a name="l01916"></a>01916                         filenames^= FM ^ wstringfromUTF8((UTF8*)PQgetvalue(result, filen, 0), PQgetlength(result, filen, 0));
<a name="l01917"></a>01917         }
<a name="l01918"></a>01918         filenames.splicer(1,1,L<span class="stringliteral">&quot;&quot;</span>);
<a name="l01919"></a>01919 
<a name="l01920"></a>01920         PQclear(result);
<a name="l01921"></a>01921 
<a name="l01922"></a>01922         <span class="keywordflow">return</span> filenames;
<a name="l01923"></a>01923 }
<a name="l01924"></a>01924 
<a name="l01925"></a>01925 var var::listindexes(<span class="keyword">const</span> var&amp; filename)<span class="keyword"> const</span>
<a name="l01926"></a>01926 <span class="keyword"></span>{
<a name="l01927"></a>01927         THISIS(L<span class="stringliteral">&quot;var var::listindexes(const var&amp; filename) const&quot;</span>)
<a name="l01928"></a>01928         <span class="comment">//could allow undefined usage since *this isnt used?</span>
<a name="l01929"></a>01929         THISISDEFINED()
<a name="l01930"></a>01930         ISSTRING(filename)
<a name="l01931"></a>01931 
<a name="l01932"></a>01932         <span class="comment">//TODO for some reason doesnt return the exodus index_file__fieldname records</span>
<a name="l01933"></a>01933         <span class="comment">//perhaps you have to be connected with sufficient postgres rights</span>
<a name="l01934"></a>01934         var sql=
<a name="l01935"></a>01935                 L&quot;SELECT relname&quot;
<a name="l01936"></a>01936                 L&quot; FROM pg_class&quot;
<a name="l01937"></a>01937                 L&quot; WHERE oid IN (&quot;
<a name="l01938"></a>01938                         L&quot; SELECT indexrelid&quot;
<a name="l01939"></a>01939                         L&quot; FROM pg_index, pg_class&quot;
<a name="l01940"></a>01940                         L&quot; WHERE&quot;;
<a name="l01941"></a>01941         if (filename)
<a name="l01942"></a>01942                 sql^=L&quot; relname = &#39;&quot; ^ filename ^  L&quot;&#39; AND &quot;;
<a name="l01943"></a>01943         sql^=L&quot; pg_class.oid=pg_index.indrelid&quot;
<a name="l01944"></a>01944                  L&quot; AND indisunique != &#39;t&#39;&quot;
<a name="l01945"></a>01945                  L&quot; AND indisprimary != &#39;t&#39;&quot;
<a name="l01946"></a>01946                  L&quot;);&quot;;
<a name="l01947"></a>01947 
<a name="l01948"></a>01948         <span class="comment">//execute command or return empty string</span>
<a name="l01949"></a>01949         connection();
<a name="l01950"></a>01950         PGresultptr result;
<a name="l01951"></a>01951         if (!pqexec(sql,result))
<a name="l01952"></a>01952                 return L&quot;&quot;;
<a name="l01953"></a>01953 
<a name="l01954"></a>01954         var tt;
<a name="l01955"></a>01955         var indexname;
<a name="l01956"></a>01956         var indexnames=L&quot;&quot;;
<a name="l01957"></a>01957         <span class="keywordtype">int</span> nindexes=PQntuples(result);
<a name="l01958"></a>01958         for (<span class="keywordtype">int</span> indexn=0; indexn&lt;nindexes; indexn++)
<a name="l01959"></a>01959         {
<a name="l01960"></a>01960                 <span class="keywordflow">if</span>      (!PQgetisnull(result, indexn, 0))
<a name="l01961"></a>01961                 {
<a name="l01962"></a>01962                         indexname=wstringfromUTF8((UTF8*)PQgetvalue(result, indexn, 0), PQgetlength(result, indexn, 0));
<a name="l01963"></a>01963                         <span class="keywordflow">if</span> (indexname.substr(1,6)==L<span class="stringliteral">&quot;index_&quot;</span>)
<a name="l01964"></a>01964                         {
<a name="l01965"></a>01965                                 tt=indexname.index(L<span class="stringliteral">&quot;__&quot;</span>);
<a name="l01966"></a>01966                                 <span class="keywordflow">if</span> (tt)
<a name="l01967"></a>01967                                 {
<a name="l01968"></a>01968                                         indexnames^=FM^indexname.substr(7,999999).swap(L<span class="stringliteral">&quot;__&quot;</span>,VM);
<a name="l01969"></a>01969                                 }
<a name="l01970"></a>01970                         }
<a name="l01971"></a>01971                 }
<a name="l01972"></a>01972         }
<a name="l01973"></a>01973         indexnames.splicer(1,1,L<span class="stringliteral">&quot;&quot;</span>);
<a name="l01974"></a>01974 
<a name="l01975"></a>01975         PQclear(result);
<a name="l01976"></a>01976 
<a name="l01977"></a>01977         <span class="keywordflow">return</span> indexnames;
<a name="l01978"></a>01978 }
<a name="l01979"></a>01979 
<a name="l01980"></a>01980 <span class="comment">//returns 1 for success and PGresult points to result WHICH MUST BE PQclear(result)&#39;ed</span>
<a name="l01981"></a>01981 <span class="comment">//returns 0 for failure</span>
<a name="l01982"></a>01982 <span class="keywordtype">int</span> pqexec(<span class="keyword">const</span> var&amp; sql, PGresultptr&amp; pgresult)
<a name="l01983"></a>01983 {
<a name="l01984"></a>01984         <span class="keywordtype">int</span> retcode = 1;
<a name="l01985"></a>01985 
<a name="l01986"></a>01986         <span class="comment">//get the current thread connection</span>
<a name="l01987"></a>01987         PGconn* thread_pgconn=tss_pgconns.get();
<a name="l01988"></a>01988         <span class="keywordflow">if</span> (!thread_pgconn)
<a name="l01989"></a>01989                 <span class="keywordflow">throw</span> MVDBException(L<span class="stringliteral">&quot;pqexec missing tss connection&quot;</span>);
<a name="l01990"></a>01990 
<a name="l01991"></a>01991         <span class="comment">//will contain any result IF successful</span>
<a name="l01992"></a>01992         <span class="comment">//MUST do PQclear(local_result) after using it;</span>
<a name="l01993"></a>01993         PGresult *local_result;
<a name="l01994"></a>01994 
<a name="l01995"></a>01995         <span class="comment">//execute the command</span>
<a name="l01996"></a>01996         DEBUG_LOG_SQL
<a name="l01997"></a>01997         local_result = PQexec(thread_pgconn, sql.tostring().c_str());
<a name="l01998"></a>01998         pgresult = local_result;
<a name="l01999"></a>01999 
<a name="l02000"></a>02000         <span class="keywordflow">if</span> (!local_result) {
<a name="l02001"></a>02001 <span class="preprocessor">                #if TRACING &gt;=1</span>
<a name="l02002"></a>02002 <span class="preprocessor"></span>                        exodus::errputln(L<span class="stringliteral">&quot;PQexec command failed, no error code: &quot;</span>);
<a name="l02003"></a>02003 <span class="preprocessor">                #endif</span>
<a name="l02004"></a>02004 <span class="preprocessor"></span>                retcode = 0;
<a name="l02005"></a>02005         } <span class="keywordflow">else</span> {
<a name="l02006"></a>02006 
<a name="l02007"></a>02007                 <span class="keywordflow">switch</span> (PQresultStatus(local_result)) {
<a name="l02008"></a>02008                 <span class="keywordflow">case</span> PGRES_COMMAND_OK:
<a name="l02009"></a>02009 <span class="preprocessor">                        #if TRACING &gt;= 3</span>
<a name="l02010"></a>02010 <span class="preprocessor"></span>                                <span class="keyword">const</span> <span class="keywordtype">char</span> *str_res;
<a name="l02011"></a>02011                                 str_res = PQcmdTuples(local_result);
<a name="l02012"></a>02012                                 <span class="keywordflow">if</span> (strlen(str_res) &gt; 0) {
<a name="l02013"></a>02013                                         exodus::logputln(L<span class="stringliteral">&quot;Command executed OK, &quot;</span> ^ var(str_res) ^ L<span class="stringliteral">&quot; rows.&quot;</span>);
<a name="l02014"></a>02014                                 } <span class="keywordflow">else</span> {
<a name="l02015"></a>02015                                         exodus::logputln(L<span class="stringliteral">&quot;Command executed OK, 0 rows.&quot;</span>);
<a name="l02016"></a>02016                                 }
<a name="l02017"></a>02017 <span class="preprocessor">                        #endif</span>
<a name="l02018"></a>02018 <span class="preprocessor"></span>                        <span class="keywordflow">break</span>;
<a name="l02019"></a>02019                 <span class="keywordflow">case</span> PGRES_TUPLES_OK:
<a name="l02020"></a>02020 <span class="preprocessor">                        #if TRACING &gt;= 3</span>
<a name="l02021"></a>02021 <span class="preprocessor"></span>                                exodus::logputln(L<span class="stringliteral">&quot;Select executed OK, &quot;</span> ^ var(PQntuples(local_result)) ^ L<span class="stringliteral">&quot; rows found.&quot;</span>);
<a name="l02022"></a>02022 <span class="preprocessor">                        #endif</span>
<a name="l02023"></a>02023 <span class="preprocessor"></span>                        <span class="keywordflow">break</span>;
<a name="l02024"></a>02024                 <span class="keywordflow">case</span> PGRES_NONFATAL_ERROR:
<a name="l02025"></a>02025 <span class="preprocessor">                        #if TRACING &gt;= 2</span>
<a name="l02026"></a>02026 <span class="preprocessor"></span>                                exodus::errputln(L<span class="stringliteral">&quot;SQL non-fatal error code &quot;</span> ^ var(PQresStatus(PQresultStatus(local_result))) ^ L<span class="stringliteral">&quot;, &quot;</span> ^ var(PQresultErrorMessage(local_result)));
<a name="l02027"></a>02027 <span class="preprocessor">                        #endif</span>
<a name="l02028"></a>02028 <span class="preprocessor"></span>                        <span class="keywordflow">break</span>;
<a name="l02029"></a>02029                 <span class="keywordflow">default</span>:
<a name="l02030"></a>02030 <span class="preprocessor">                        #if TRACING &gt;= 1</span>
<a name="l02031"></a>02031 <span class="preprocessor"></span>                        exodus::errputln(var(PQresStatus(PQresultStatus(local_result))) ^ L<span class="stringliteral">&quot;: &quot;</span> ^ var(PQresultErrorMessage(local_result)));
<a name="l02032"></a>02032 <span class="preprocessor">                        #endif</span>
<a name="l02033"></a>02033 <span class="preprocessor"></span>                        PQclear(local_result);
<a name="l02034"></a>02034                         retcode = 0;
<a name="l02035"></a>02035                         <span class="keywordflow">break</span>;
<a name="l02036"></a>02036                 }
<a name="l02037"></a>02037 
<a name="l02038"></a>02038         }
<a name="l02039"></a>02039 
<a name="l02040"></a>02040         <span class="keywordflow">return</span> retcode;
<a name="l02041"></a>02041 
<a name="l02042"></a>02042 } <span class="comment">/* pqexec */</span>
<a name="l02043"></a>02043 
<a name="l02044"></a>02044 <span class="comment">/* create sql view from dict</span>
<a name="l02045"></a>02045 <span class="comment">#include &lt;exodus/mv.h&gt;</span>
<a name="l02046"></a>02046 <span class="comment">using namespace exodus;</span>
<a name="l02047"></a>02047 <span class="comment"></span>
<a name="l02048"></a>02048 <span class="comment">int main() {</span>
<a name="l02049"></a>02049 <span class="comment"></span>
<a name="l02050"></a>02050 <span class="comment">        var crlf=&quot;\r\n&quot;;</span>
<a name="l02051"></a>02051 <span class="comment"></span>
<a name="l02052"></a>02052 <span class="comment">        var textfile;</span>
<a name="l02053"></a>02053 <span class="comment">        var dictfilename;</span>
<a name="l02054"></a>02054 <span class="comment">        var extractvarno;</span>
<a name="l02055"></a>02055 <span class="comment">        var expression;</span>
<a name="l02056"></a>02056 <span class="comment"></span>
<a name="l02057"></a>02057 <span class="comment">        //datafileprefix=&#39;DATA_&#39;</span>
<a name="l02058"></a>02058 <span class="comment">        var datafileprefix = &quot;&quot;;</span>
<a name="l02059"></a>02059 <span class="comment">        //viewsuffix=&#39;_VIEW&#39;</span>
<a name="l02060"></a>02060 <span class="comment">        var viewsuffix = &quot;&quot;;</span>
<a name="l02061"></a>02061 <span class="comment">        var viewprefix = &quot;VIEW_&quot;;</span>
<a name="l02062"></a>02062 <span class="comment">        //syntax is DICT2SQL filename,...volumename</span>
<a name="l02063"></a>02063 <span class="comment"></span>
<a name="l02064"></a>02064 <span class="comment">        var filename = filenames.extract(filen);</span>
<a name="l02065"></a>02065 <span class="comment">        if (filename == &quot;&quot;)</span>
<a name="l02066"></a>02066 <span class="comment">                goto exit;</span>
<a name="l02067"></a>02067 <span class="comment"></span>
<a name="l02068"></a>02068 <span class="comment">        var sqlfilename = filename;</span>
<a name="l02069"></a>02069 <span class="comment">        sqlfilename.converter(&quot;.&quot;, &quot;_&quot;);</span>
<a name="l02070"></a>02070 <span class="comment"></span>
<a name="l02071"></a>02071 <span class="comment">        if (filename.substr(1, 5) == &quot;DICT.&quot;)</span>
<a name="l02072"></a>02072 <span class="comment">                dictfilename = &quot;DICT.ACCESSIBLE_COLUMNS&quot;;</span>
<a name="l02073"></a>02073 <span class="comment">        else</span>
<a name="l02074"></a>02074 <span class="comment">                dictfilename = &quot;DICT.&quot; ^ filename;</span>
<a name="l02075"></a>02075 <span class="comment">        }</span>
<a name="l02076"></a>02076 <span class="comment"></span>
<a name="l02077"></a>02077 <span class="comment">        if (_DICT.open(dictfilename, &quot;&quot;))</span>
<a name="l02078"></a>02078 <span class="comment">                var(&quot;SSELECT &quot; ^ dictfilename ^ &quot; BY TYPE BY FMC BY PART (S)&quot;).perform();</span>
<a name="l02079"></a>02079 <span class="comment">        else</span>
<a name="l02080"></a>02080 <span class="comment">                var().clearselect();</span>
<a name="l02081"></a>02081 <span class="comment"></span>
<a name="l02082"></a>02082 <span class="comment">                sql ^= crlf ^ &quot;-- DROP TABLE &quot; ^ datafileprefix ^ sqlfilename;</span>
<a name="l02083"></a>02083 <span class="comment">                sql ^= crlf ^ &quot;-- ;&quot;;</span>
<a name="l02084"></a>02084 <span class="comment"></span>
<a name="l02085"></a>02085 <span class="comment">                sql ^= crlf ^ &quot;CREATE TABLE &quot; ^ datafileprefix ^ sqlfilename;</span>
<a name="l02086"></a>02086 <span class="comment">                sql ^= crlf ^ &quot;(&quot;;</span>
<a name="l02087"></a>02087 <span class="comment">                sql ^= crlf ^ &quot; key bytea primary key,&quot;;</span>
<a name="l02088"></a>02088 <span class="comment">                sql ^= crlf ^ &quot; data bytea&quot;;</span>
<a name="l02089"></a>02089 <span class="comment">                sql ^= crlf ^ &quot;)&quot;;</span>
<a name="l02090"></a>02090 <span class="comment">                sql ^= crlf ^ &quot;;&quot;;</span>
<a name="l02091"></a>02091 <span class="comment"></span>
<a name="l02092"></a>02092 <span class="comment">                sql ^= crlf ^ &quot;--DROP VIEW &quot; ^ viewprefix ^ sqlfilename ^ viewsuffix;</span>
<a name="l02093"></a>02093 <span class="comment">                sql ^= crlf ^ &quot;--;&quot;;</span>
<a name="l02094"></a>02094 <span class="comment"></span>
<a name="l02095"></a>02095 <span class="comment">                //sql:=crlf:&#39;CREATE OR REPLACE VIEW &#39;:viewprefix:sqlfilename:viewsuffix:&#39; AS SELECT &#39;</span>
<a name="l02096"></a>02096 <span class="comment">                sql ^= crlf ^ &quot;CREATE VIEW &quot; ^ viewprefix ^ sqlfilename ^ viewsuffix ^ &quot; AS SELECT &quot;;</span>
<a name="l02097"></a>02097 <span class="comment"></span>
<a name="l02098"></a>02098 <span class="comment">                var nsvs = 0;</span>
<a name="l02099"></a>02099 <span class="comment"></span>
<a name="l02100"></a>02100 <span class="comment">                //table and view for multivalues</span>
<a name="l02101"></a>02101 <span class="comment">                var anyvar = 0;</span>
<a name="l02102"></a>02102 <span class="comment">                var nvars = 0;</span>
<a name="l02103"></a>02103 <span class="comment">                var sql2 = &quot;&quot;;</span>
<a name="l02104"></a>02104 <span class="comment">                sql2 ^= crlf ^ &quot;-- DROP TABLE &quot; ^ datafileprefix ^ sqlfilename ^ &quot;_LINES&quot;;</span>
<a name="l02105"></a>02105 <span class="comment">                sql2 ^= crlf ^ &quot;-- ;&quot;;</span>
<a name="l02106"></a>02106 <span class="comment"></span>
<a name="l02107"></a>02107 <span class="comment">                sql2 ^= crlf ^ var(&quot;CREATE TABLE &quot;).oconv(datafileprefix) ^ sqlfilename ^ &quot;_LINES&quot;;</span>
<a name="l02108"></a>02108 <span class="comment">                sql2 ^= crlf ^ &quot;(&quot;;</span>
<a name="l02109"></a>02109 <span class="comment">                sql2 ^= crlf ^ &quot; key bytea,&quot;;</span>
<a name="l02110"></a>02110 <span class="comment">                sql2 ^= crlf ^ &quot; lineno integer,&quot;;</span>
<a name="l02111"></a>02111 <span class="comment">                sql2 ^= crlf ^ &quot; PRIMARY KEY (key, lineno)&quot;;</span>
<a name="l02112"></a>02112 <span class="comment">                sql2 ^= crlf ^ &quot;)&quot;;</span>
<a name="l02113"></a>02113 <span class="comment">                sql2 ^= crlf ^ &quot;;&quot;;</span>
<a name="l02114"></a>02114 <span class="comment"></span>
<a name="l02115"></a>02115 <span class="comment">                sql2 ^= crlf ^ &quot;--DROP VIEW &quot; ^ viewprefix ^ sqlfilename ^ &quot;_LINES&quot; ^ viewsuffix;</span>
<a name="l02116"></a>02116 <span class="comment">                sql2 ^= crlf ^ &quot;--;&quot;;</span>
<a name="l02117"></a>02117 <span class="comment"></span>
<a name="l02118"></a>02118 <span class="comment">                //sql:=crlf:&#39;CREATE OR REPLACE VIEW &#39;:viewprefix:sqlfilename:&#39;_LINES&#39;:viewsuffix:&#39; AS SELECT &#39;</span>
<a name="l02119"></a>02119 <span class="comment">                sql2 ^= crlf ^ &quot;CREATE VIEW &quot; ^ viewprefix ^ sqlfilename ^ &quot;_LINES&quot; ^ viewsuffix ^ &quot; AS SELECT &quot;;</span>
<a name="l02120"></a>02120 <span class="comment"></span>
<a name="l02121"></a>02121 <span class="comment">                var ndicts = 0;</span>
<a name="l02122"></a>02122 <span class="comment"></span>
<a name="l02123"></a>02123 <span class="comment">nextdict:</span>
<a name="l02124"></a>02124 <span class="comment">        while (true)</span>
<a name="l02125"></a>02125 <span class="comment">        {</span>
<a name="l02126"></a>02126 <span class="comment">                var dictid;</span>
<a name="l02127"></a>02127 <span class="comment">                if (!dictid.readnext())</span>
<a name="l02128"></a>02128 <span class="comment">                        break;</span>
<a name="l02129"></a>02129 <span class="comment"></span>
<a name="l02130"></a>02130 <span class="comment">                var dict;</span>
<a name="l02131"></a>02131 <span class="comment">                if (!(dict.read(_DICT, dictid)))</span>
<a name="l02132"></a>02132 <span class="comment">                        continue;</span>
<a name="l02133"></a>02133 <span class="comment"></span>
<a name="l02134"></a>02134 <span class="comment">                if (dictfilename == &quot;DICT.ACCESSIBLE_COLUMNS&quot;) {</span>
<a name="l02135"></a>02135 <span class="comment">                        if (dictid == &quot;TABLE_NAME&quot;)</span>
<a name="l02136"></a>02136 <span class="comment">                                goto continue;</span>
<a name="l02137"></a>02137 <span class="comment">                        //ordinary dictionaries dictid is not multipart</span>
<a name="l02138"></a>02138 <span class="comment">                        if (dictid == &quot;COLUMN_NAME&quot;)</span>
<a name="l02139"></a>02139 <span class="comment">                                dict.replacer(5, 0, 0, &quot;&quot;);</span>
<a name="l02140"></a>02140 <span class="comment">                }</span>
<a name="l02141"></a>02141 <span class="comment"></span>
<a name="l02142"></a>02142 <span class="comment">                dictitem2sql(dict,sql);</span>
<a name="l02143"></a>02143 <span class="comment"></span>
<a name="l02144"></a>02144 <span class="comment">                if (dict.extract(1) not_eq &quot;F&quot;)</span>
<a name="l02145"></a>02145 <span class="comment">                        continue;</span>
<a name="l02146"></a>02146 <span class="comment"></span>
<a name="l02147"></a>02147 <span class="comment">                //skip duplicates</span>
<a name="l02148"></a>02148 <span class="comment">                //if dict&lt;28&gt; then continue</span>
<a name="l02149"></a>02149 <span class="comment"></span>
<a name="l02150"></a>02150 <span class="comment">                ndicts += 1;</span>
<a name="l02151"></a>02151 <span class="comment"></span>
<a name="l02152"></a>02152 <span class="comment">                //sql^=crlf;</span>
<a name="l02153"></a>02153 <span class="comment"></span>
<a name="l02154"></a>02154 <span class="comment">                var ismv = dict.extract(4).substr(1, 1) == &quot;M&quot;;</span>
<a name="l02155"></a>02155 <span class="comment">                if (ismv) {</span>
<a name="l02156"></a>02156 <span class="comment">                        anyvar = 1;</span>
<a name="l02157"></a>02157 <span class="comment">                        extractvarno = &quot;lineno&quot;;</span>
<a name="l02158"></a>02158 <span class="comment">                }else{</span>
<a name="l02159"></a>02159 <span class="comment">                        extractvarno = &quot;0&quot;;</span>
<a name="l02160"></a>02160 <span class="comment">                }</span>
<a name="l02161"></a>02161 <span class="comment"></span>
<a name="l02162"></a>02162 <span class="comment">                if (dict.extract(2) == &quot;0&quot;) {</span>
<a name="l02163"></a>02163 <span class="comment">                        if (not dict.extract(5)) {</span>
<a name="l02164"></a>02164 <span class="comment">                                expression = &quot;key&quot;;</span>
<a name="l02165"></a>02165 <span class="comment">                        }else{</span>
<a name="l02166"></a>02166 <span class="comment">                                //needs pgneosys function not written as yet</span>
<a name="l02167"></a>02167 <span class="comment">                                //sql:=&#39;text_field(key,&quot;*&quot;,&#39;:dict&lt;5&gt;:&#39;)&#39;</span>
<a name="l02168"></a>02168 <span class="comment">                                //postgres only probably</span>
<a name="l02169"></a>02169 <span class="comment">                                expression = &quot;split_part(key,\&#39;*\&#39;,&quot; ^ dict.extract(5) ^ &quot;)&quot;;</span>
<a name="l02170"></a>02170 <span class="comment">                        }</span>
<a name="l02171"></a>02171 <span class="comment">                }else{</span>
<a name="l02172"></a>02172 <span class="comment">                        //if dict&lt;7&gt; then</span>
<a name="l02173"></a>02173 <span class="comment">                        //needs pgneosys functions installed in server</span>
<a name="l02174"></a>02174 <span class="comment">                        expression = &quot;exodus_extract_text(data,&quot; ^ dict.extract(2) ^ &quot;,&quot; ^ extractvarno ^ &quot;,0)&quot;;</span>
<a name="l02175"></a>02175 <span class="comment">                        //end else</span>
<a name="l02176"></a>02176 <span class="comment">                        // sql:=&#39;bytea_extract(data,&#39;:dict&lt;2&gt;:&#39;,&#39;:extractvarno:&#39;,0)&#39;</span>
<a name="l02177"></a>02177 <span class="comment">                        // end</span>
<a name="l02178"></a>02178 <span class="comment">                }</span>
<a name="l02179"></a>02179 <span class="comment"></span>
<a name="l02180"></a>02180 <span class="comment">                var conversion = dict.extract(7);</span>
<a name="l02181"></a>02181 <span class="comment">                if (conversion.substr(1, 9) == &quot;[DATETIME&quot;) {</span>
<a name="l02182"></a>02182 <span class="comment">                        expression.swapper(&quot;exodus_extract_text(&quot;, &quot;exodus_extract_datetime(&quot;);</span>
<a name="l02183"></a>02183 <span class="comment"></span>
<a name="l02184"></a>02184 <span class="comment">                }else if (conversion.substr(1, 1) == &quot;D&quot; or conversion.substr(1, 5) == &quot;[DATE&quot;) {</span>
<a name="l02185"></a>02185 <span class="comment">                        //expression[1,0]=&quot;date &#39;1967-12-31&#39; + cast(&quot;</span>
<a name="l02186"></a>02186 <span class="comment">                        //expression:=&#39; as integer)&#39;</span>
<a name="l02187"></a>02187 <span class="comment">                        expression.swapper(&quot;exodus_extract_text(&quot;, &quot;exodus_extract_date(&quot;);</span>
<a name="l02188"></a>02188 <span class="comment"></span>
<a name="l02189"></a>02189 <span class="comment">                }else if (conversion == &quot;[NUMBER,0]&quot; or dict.extract(11) == &quot;0N&quot; or (dict.extract(11)).substr(1, 3) == &quot;0N_&quot;) {</span>
<a name="l02190"></a>02190 <span class="comment">                        expression.splicer(1, 0, &quot;cast(&quot;);</span>
<a name="l02191"></a>02191 <span class="comment">                        expression ^= &quot; as integer)&quot;;</span>
<a name="l02192"></a>02192 <span class="comment">                        //zero length string to be treated as null</span>
<a name="l02193"></a>02193 <span class="comment">                        expression.swapper(&quot;exodus_extract_text(&quot;, &quot;exodus_extract_text2(&quot;);</span>
<a name="l02194"></a>02194 <span class="comment"></span>
<a name="l02195"></a>02195 <span class="comment">                }else if (conversion.substr(1, 2) == &quot;MD&quot; or conversion.substr(1, 7) == &quot;[NUMBER&quot; or (dict.extract(11)).substr(1, 7) == &quot;[NUMBER&quot; or dict.extract(12) == &quot;FLOAT&quot; or (dict.extract(11)).index(&quot;0N&quot;, 1)) {</span>
<a name="l02196"></a>02196 <span class="comment">                        expression.splicer(1, 0, &quot;cast(&quot;);</span>
<a name="l02197"></a>02197 <span class="comment">                        expression ^= &quot; as float)&quot;;</span>
<a name="l02198"></a>02198 <span class="comment">                        //zero length string to be treated as null</span>
<a name="l02199"></a>02199 <span class="comment">                        expression.swapper(&quot;exodus_extract_text(&quot;, &quot;exodus_extract_text2(&quot;);</span>
<a name="l02200"></a>02200 <span class="comment"></span>
<a name="l02201"></a>02201 <span class="comment">                }else if (conversion.substr(1, 2) == &quot;MT&quot; or conversion.substr(1, 5) == &quot;[TIME&quot;) {</span>
<a name="l02202"></a>02202 <span class="comment">                        //expression[1,0]=&quot;cast(&quot;</span>
<a name="l02203"></a>02203 <span class="comment">                        //expression:=&#39; as interval)&#39;</span>
<a name="l02204"></a>02204 <span class="comment">                        expression.swapper(&quot;exodus_extract_text(&quot;, &quot;exodus_extract_time(&quot;);</span>
<a name="l02205"></a>02205 <span class="comment"></span>
<a name="l02206"></a>02206 <span class="comment">                }else if (dict.extract(9) == &quot;R&quot;) {</span>
<a name="l02207"></a>02207 <span class="comment">                        //expression[1,0]=&quot;cast(&quot;</span>
<a name="l02208"></a>02208 <span class="comment">                        //expression:=&#39; as numeric)&#39;</span>
<a name="l02209"></a>02209 <span class="comment">                        //zero length string to be treated as null</span>
<a name="l02210"></a>02210 <span class="comment">                        expression.swapper(&quot;exodus_extract_text(&quot;, &quot;exodus_extract_text2(&quot;);</span>
<a name="l02211"></a>02211 <span class="comment"></span>
<a name="l02212"></a>02212 <span class="comment">                }</span>
<a name="l02213"></a>02213 <span class="comment"></span>
<a name="l02214"></a>02214 <span class="comment">                if (ismv) {</span>
<a name="l02215"></a>02215 <span class="comment">                        nvars += 1;</span>
<a name="l02216"></a>02216 <span class="comment">                        sql2 ^= crlf ^ expression ^ &quot; as &quot; ^ dictid;</span>
<a name="l02217"></a>02217 <span class="comment">                        sql2 ^= &quot;, &quot;;</span>
<a name="l02218"></a>02218 <span class="comment">                }else{</span>
<a name="l02219"></a>02219 <span class="comment">                        nsvs += 1;</span>
<a name="l02220"></a>02220 <span class="comment">                        sql ^= crlf ^ expression ^ &quot; as &quot; ^ dictid;</span>
<a name="l02221"></a>02221 <span class="comment">                        sql ^= &quot;, &quot;;</span>
<a name="l02222"></a>02222 <span class="comment">                }</span>
<a name="l02223"></a>02223 <span class="comment"></span>
<a name="l02224"></a>02224 <span class="comment">        }//dicts</span>
<a name="l02225"></a>02225 <span class="comment"></span>
<a name="l02226"></a>02226 <span class="comment"></span>
<a name="l02227"></a>02227 <span class="comment">        if (nsvs) {</span>
<a name="l02228"></a>02228 <span class="comment">                sql.trimmerb();</span>
<a name="l02229"></a>02229 <span class="comment">                if (sql.substr(-1, 1) == &quot;,&quot;)</span>
<a name="l02230"></a>02230 <span class="comment">                        sql.splicer(-1, 1, &quot;&quot;);</span>
<a name="l02231"></a>02231 <span class="comment">        }else{</span>
<a name="l02232"></a>02232 <span class="comment">                sql ^= &quot; *&quot;;</span>
<a name="l02233"></a>02233 <span class="comment">        }</span>
<a name="l02234"></a>02234 <span class="comment"></span>
<a name="l02235"></a>02235 <span class="comment">        if (nvars) {</span>
<a name="l02236"></a>02236 <span class="comment">                sql2.trimmerb();</span>
<a name="l02237"></a>02237 <span class="comment">                if (sql2.substr(-1, 1) == &quot;,&quot;)</span>
<a name="l02238"></a>02238 <span class="comment">                        sql2.splicer(-1, 1, &quot;&quot;);</span>
<a name="l02239"></a>02239 <span class="comment">        }</span>
<a name="l02240"></a>02240 <span class="comment"></span>
<a name="l02241"></a>02241 <span class="comment">        sql ^= crlf ^ &quot; from &quot; ^ datafileprefix ^ sqlfilename;</span>
<a name="l02242"></a>02242 <span class="comment">        sql ^= crlf ^ &quot;;&quot;;</span>
<a name="l02243"></a>02243 <span class="comment"></span>
<a name="l02244"></a>02244 <span class="comment">        if (anyvar) {</span>
<a name="l02245"></a>02245 <span class="comment"></span>
<a name="l02246"></a>02246 <span class="comment">                sql2 ^= crlf ^ &quot; from &quot; ^ datafileprefix ^ sqlfilename ^ &quot;_LINES&quot;;</span>
<a name="l02247"></a>02247 <span class="comment">                sql2 ^= crlf ^ &quot; LEFT JOIN &quot; ^ datafileprefix ^ sqlfilename;</span>
<a name="l02248"></a>02248 <span class="comment">                sql2 ^= &quot; ON &quot; ^ datafileprefix ^ sqlfilename ^ &quot;_LINES.KEY = &quot; ^ datafileprefix ^ sqlfilename ^ &quot;.key&quot;;</span>
<a name="l02249"></a>02249 <span class="comment">                sql2 ^= crlf ^ &quot;;&quot;;</span>
<a name="l02250"></a>02250 <span class="comment"></span>
<a name="l02251"></a>02251 <span class="comment">                sql ^= crlf ^ sql2;</span>
<a name="l02252"></a>02252 <span class="comment">                sql2 = &quot;&quot;;</span>
<a name="l02253"></a>02253 <span class="comment">        }</span>
<a name="l02254"></a>02254 <span class="comment"></span>
<a name="l02255"></a>02255 <span class="comment">        sql ^= crlf ^ &quot;COMMIT;&quot;;</span>
<a name="l02256"></a>02256 <span class="comment"></span>
<a name="l02257"></a>02257 <span class="comment">        sql.swapper(_FM, crlf);</span>
<a name="l02258"></a>02258 <span class="comment"></span>
<a name="l02259"></a>02259 <span class="comment">        if (!textptr)</span>
<a name="l02260"></a>02260 <span class="comment">                sql.splicer(1, 0, &quot;BEGIN;&quot; ^ (crlf));</span>
<a name="l02261"></a>02261 <span class="comment"></span>
<a name="l02262"></a>02262 <span class="comment">        osbwritex(sql, textfile, textfilename, textptr);</span>
<a name="l02263"></a>02263 <span class="comment">        textptr += sql.length();</span>
<a name="l02264"></a>02264 <span class="comment"></span>
<a name="l02265"></a>02265 <span class="comment">        sql = &quot;&quot;;</span>
<a name="l02266"></a>02266 <span class="comment"></span>
<a name="l02267"></a>02267 <span class="comment">        var().stop();</span>
<a name="l02268"></a>02268 <span class="comment">}</span>
<a name="l02269"></a>02269 <span class="comment"></span>
<a name="l02270"></a>02270 <span class="comment">}</span>
<a name="l02271"></a>02271 <span class="comment"></span>
<a name="l02272"></a>02272 <span class="comment">*/</span>
<a name="l02273"></a>02273 
<a name="l02274"></a>02274 
<a name="l02275"></a>02275 }<span class="comment">//of namespace exodus</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Sun Sep 12 2010 01:29:11 for exodus by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
