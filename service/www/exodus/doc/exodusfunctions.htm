<meta content="True" id="vs_showGrid">
<H2>EXODUS javascript for MV Database compatibility</H2>
<P>EXODUS has provided a series of method, functions and objects to simplify the 
	recoding of Basic into javascript (also known as jscript)</P>
<H2>Methods</H2>
<H3>array/string.exodusextract(fieldno,valueno,subvalueno)</H3>
<P>Extracts the field (1 based!) or '' if not defined</P>
<P>fieldno, valueno and subvalue are all optional</P>
<P>If fieldno is undefined then returns input as output
</P>
<P>If fieldn is 0 then returns an array (string split by fm if necessary)</P>
<P>and so on for the values and subvalues</P>
<P>NB fieldno,valueno,subvalueno are 1 based not zero based</P>
<H3>string.exodusreplace(fieldno,valueno,subvalueno,newdata)</H3>
<P>returns a string with the newdata inserted</P>
<P>NB&nbsp;does not handle valueno or subvalueno yet</P>
<P>NB fieldno,valueno,subvalueno are 1 based not zero based</P>
<H3>
	<H3>array/string.exodusfield(sep,start,length)</H3>
</H3>
<P>sep can be a single character to define the fields or&nbsp;'' to indicate 
	characterwise operation</P>
<P>if an array then the fieldstore is performed on each element of the array and 
	returns an array</P>
<P>NB&nbsp;start is 1 based not zero based</P>
<H3>
	<H3>array/string.exodusfieldstore(sep,start,length,insertstring)</H3>
</H3>
<P>sep can be a single character to define the fields or&nbsp;'' to indicate 
	characterwise operation</P>
<P>NB does not follow the DOS convention of keeping the number of fields constant 
	unless the length is negative. ie the part defined by the start and length is 
	simply deleted and replaced with the insertstring as you would expect.</P>
<P>if an array then the fieldstore is performed on each element of the array</P>
<P>NB start is&nbsp;1 based not zero based</P>
<H3>string.exoduslocate(string,order,sep,startfrom)</H3>
<H3>array.exoduslocate(string,order,startfrom)</H3>
<P>NB ... returns 1 based index NOT 0 based</P>
<P>returns 0 if string not found in array/string otherwise 1 if found in first 
	position etc</P>
<P>order null&nbsp;... exact locate<br />
	order D ... best position in descending order<br />
	order A ... best position in ascending order<br />
	order is alphabetic or numeric depending on string/numeric type of data
</P>
<P>sep defaults to vm for string objects</P>
<P>startfrom defaults to 1 (again 1 based!)</P>
<H3>array.exodusdelete(fieldno,valueno,subvalueno)</H3>
<P>removes the nth element of the array</P>
<P>NB fieldno,valueno,subvalueno are 1 based not zero based</P>
<P>NB&nbsp;does not handle valueno or subvalueno yet</P>
<P>NB fieldno,valueno,subvalueno are 1 based not zero based</P>
<H3>string.exodusright(nchars)</H3>
<P>returns a string representing the rightmost nchars of the string</P>
<H3>string/array.exodusswap(string1,string2)</H3>
<P>returns an array if given an array</P>
<H3>string/array.exodusconvert(string1,string2)</H3>
<P>converts the characters in string1 to the respective characters in string3 or 
	deletes them if string2 is shorter than string1</P>
<P>returns an array if given an array</P>
<H3>string/array.exoduscount(string2)</H3>
<P>returns the number of times that string2 occurs in a string or arrays of strings</P>
<H3>
	<H3>string/array.exodusdcount(string2)</H3>
</H3>
<P>returns the number of&nbsp;fields separated by&nbsp;string2 that occur in a 
	string or arrays of strings</P>
<H3>string.exodusaddcent(type)</H3>
<P>type is ICONV or defaults to OCONV</P>
<H3>string.exoduscapitalise()</H3>
<P>converts the first character of each word to capitals and the rest to lower case 
	and returns a string</P>
<H3>string.exodusplural(n,suffix)</H3>
<P>returns a string with the suffix added if n is not 1 or is boolean false. suffix 
	defaults to "s"</P>
<H3>array1.tostatement()</H3>
<H3>array1.exodusadd(array2)</H3>
<P>like +++ adds two arrays in parallel and returns an array</P>
<H3>array1.exodussubtract(array2)</H3>
<P>like&nbsp;---&nbsp;subtracts array2 from array1&nbsp;in parallel and returns an 
	array</P>
<H3>array1.exodusmultiply(array2)</H3>
<P>like *** multiplies&nbsp;two arrays in parallel and returns an array</P>
<H3>array1.exodusdivide(array2)</H3>
<P>like&nbsp;/// divides array1 by array2&nbsp;in parallel and returns an array</P>
<H3>number.exodusdivide0isblank(divisor)</H3>
<P>returns the number divided by the divisor or&nbsp;"" if the divisor is zero</P>
<H3>string/number/array.exodussum(sepchar)</H3>
<P>adds all elements and returns a number</P>
<H3>string/array.exodussplit(sepchars,invert)</H3>
<P>returns an array with the element split into subelements (multiple levels, one 
	for each character in sepchars)</P>
<P><EM>invert</EM> defaults to false, otherwise if <EM>sepchars</EM> is two 
	characters the rows and columns of the returned array are inverted</P>
<P>used to convert fm, vm etc separated strings to multilevel arrays</P>
<H3>array/string.exodusjoin(sepchars)</H3>
<P>returns an string with elements of an array and any subelements joined with 
	sepchars .. one char for each level</P>
<P>used to&nbsp;convert multilevel arrays to fm, vm etc separated strings</P>
<H3>string.exodustrim(char,mode)</H3>
<P>removes leading, trailing and excess char or spaces if char is not defined and 
	returns a string</P>
<P>mode A or undefined means trim all leading, trailing and excess inner characters<br />
	mode&nbsp;L means trim all leading characters<br />
	mode&nbsp;R means trim all trailing characters</P>
<H3>string.exodustrimf(char)<br />
	string.exodustriml(char)</H3>
<P>removes leading (leftmost) chars or spaces if char not defined and returns a 
	string</P>
<H3>string.exodustrimb(char)<br />
	string.exodustrimr(char)</H3>
<P>removes trailing (rightmost) chars or spaces if char not defined and returns a 
	string</P>
<H3>array.exodustrim()</H3>
<P>removes blank or unassigned elements of an array</P>
<h3>
    array.exodustrimr()</h3>
<P>
    removes blank or unassigned elements at the end of an array</p>
<H3>number/string/array.exodusquote(char)</H3>
<P>if provided an array, returns a string separated by spaces eg "AAA" "BBB" "CCC"</P>
<H3>number/string/array.exodusoconv(conversion)</H3>
<P>returns the external format of the object</P>
<H3>number/string/array.exodusiconv(conversion)</H3>
<P>returns the&nbsp;internal format of the object</P>
<H3>array.exodusunique()</H3>
<P>//returns an array of unique array elements from an array (removes 
	duplicates)&nbsp;
</P>
<H2>Functions</H2>
<H3>function exodusconv(type,value,conversion)</H3>
<P>returns a&nbsp;value or array of values after conversion(s)</P>
<P>type is ICONV or OCONV</P>
<P>value is a value or array of values</P>
<P>conversion is a conversion or array of conversions</P>
<P>each value is converted by all conversions</P>
<H3>function exodusnumber(arg1)</H3>
<P>returns anything converted to a number or systemerror if cannot</P>
<H3>function exodusnum(arg1)</H3>
<P>return&nbsp;true if numeric&nbsp; false if not</P>
<P>a number is&nbsp;one or more&nbsp;digits and optionally one "." and optionally 
	one prefixed "-"&nbsp;
</P>
<H3>function exodusround(number,ndecimals)</H3>
<P>returns a number rounded to a given number of decimal places
</P>
<H3>function exodusquote(string)</H3>
<P>return the argument surrounded by double quotes</P>
<H3>function exodusspace(length)
</H3>
<P>returns a&nbsp;string of N spaces
</P>
<H3>function exodusstr(str1,length)
</H3>
<P>returns a&nbsp;string of N strings
</P>
<H3>function decodehtmlcodes(string1)</H3>
<H3>function joinarrays(array1,array2)</H3>
<P>join an array with string sep (standard join() is single char sep)</P>
<H3>function exodusmod(number1,number2)</H3>
<P>returns modulus of number1 and number2 (number1%number2)</P>
<H3>function exodusint(number)</H3>
<P>returns the mathematical floor of the number (Math.floor(number)</P>
<P>exodusint(2.7) is 2</P>
<P>exodusint(-2.7 is 3</P>
<H3>function exodussingular(string)</H3>
<P>returns the singular form of the plural noun in string according to some common 
	English rules. Not correct for all cases.</P>
<H3>function no(value)</H3>
<P>equivalent to !is()</P>
<H3>function is(value)</H3>
<P>returns true if not empty string or not zero or any element of an array is not 
	the same</P>
<H3>function isnt(value)</H3>
<P>equivalent to !is()</P>
<H3>function exodusosread(filename)</H3>
<P>returns the unmodified contents of any given operating system file</P>
<P>not available in web mode</P>
<H3>function exodusoswrite(filename,string)</H3>
<P>creates or replaces any given operating system file</P>
<P>not available in web mode</P>
<H3>function exodusdate(year,month,day)</H3>
<P>if <EM>mode</EM>&nbsp; is undefined returns the current 
	system&nbsp;date&nbsp;as&nbsp;seconds&nbsp;since midnight otherwise returns the 
	current date in external format defined by mode. See DATE()</P>
<H3>function exodustime(mode)</H3>
<P>if <EM>mode</EM>&nbsp; is undefined returns the current system 
	time&nbsp;as&nbsp;seconds&nbsp;since midnight otherwise returns the current 
	time in external format defined by mode. See TIME()</P>
<H3>function exodusjulianperiod(period,maxperiodno)</H3>
<P>given a period in format pp/YY or pp/YYYY</P>
<P>return the julian period (eg 9/2002 is 2002*maxperiod+9)
</P>
<H2>Datatype Conversion Functions</H2>
<H3>DATE(type,input,mode)</H3>
<P>returns input converted to internal or external format depending on mode</P>
<P>type must be ICONV or defaults to OCONV</P>
<P>input internal format is a number of days since 31/1/1967. external format is 
	31/1/2002 with no leading zeros. input can be an array of the same.</P>
<P>In ICONV mode can be:</P>
<UL>
	<LI>
	A&nbsp;default date in external format (eg 31/1/2004)
	<LI>
		FROM=XXXXX or UPTO=XXXXX<br />
		in which case the default date is obtained from yield* gds.get1("XXXXX",grecn)</LI></UL>
<P>If the month and/or year is missing from the input then the month and year will 
	be obtained from the default date</P>
<P>If mode is FROM or UPTO and the entered date is less than the FROM date or 
	greater than the UPTO date then the FROM or UPTO date is changed to be the same 
	using yield* gds.setx("XXXXX",input)</P>
<P>In OCONV mode can be:</P>
<P>DOW returns the day of the week&nbsp;1=Monday&nbsp;etc<br />
	DAYNAME returns the name of the day of week eg Monday<br />
	DOM returns the day of the month 1=1st etc<br />
	MONTH returns the month of the year 1=Jan etc<br />
	YEAR returns the year eg 2004<br />
	YEAR2 returns the year as two final digit eg 04<br />
	PERIOD returns the current system month and year in the format MM/YYYY eg 
	1/2004 with no leading zero<br />
	PERIOD2 returns the current system month and year in the format MM/YY eg 1/04 
	with no leading zero</P>
<P>anything else&nbsp;returns d/m/9999 (International format) eg 31/1/2004</P>
<H3>TIME(type,input,mode)
</H3>
<P>return the&nbsp;input in internal&nbsp;external format depending on type ICONV 
	or OCONV. returns an array if input is an array</P>
<P>internal format is number of seconds since midnight. can handle greater than one 
	day.</P>
<P>external format is&nbsp;like&nbsp;00:00, 23:59, 11:59:59, 24:00, 25:00</P>
<H3>
	<H3>PERIOD_OF_TIME(type,input,mode)
	</H3>
</H3>
<P>internal format is number of minutes</P>
<P>external format is HH:MM?
</P>
<H3>TIME_DATE(type,input,mode)</H3>
<P>type OCONV</P>
<P>internal format&nbsp;is a number like 9999.9999&nbsp;the first part is the date 
	in number of days since 1/1/67 and the fractional part is the time in number of 
	seconds since midnight</P>
<P>external format&nbsp;is like d/m/yyyy hh:mm</P>
<H3>NUMBER(type,input,mode)</H3>
<P>type must be ICONV or defaults to OCONV</P>
<P>input must be something that can be parsed as a number or an array of the same 
	or will return null indicating that the conversion has failed</P>
<P>mode can be a comma separated list of parameters</P>
<P>mode1 can be:</P>
<P>a number of decimals eg. 2</P>
<P>BASE in which case the number of decimal places&nbsp;will be taken from the 
	third character of the base currency format in gbasefmt&nbsp;(eg MD20P)&nbsp;</P>
<P>NDECS in which case the number of decimal places will be taken from the global 
	variable gndecs if defined or getrecord('NDECS') if not</P>
<P>ICONV</P>
<P>mode2 can be "POSITIVE" in which case the conversion will fail if the input is 
	negative</P>
<H3>PERIOD_OF_YEAR(type,input,mode)</H3>
<P>type=ICONV/OCONV<br />
	input internal format is 1/99<br />
	input external format is 1/1999<br />
	mode is&nbsp;default period eg 1/2002 (defaults to the current period)</P>
<P>input conversion will accept month only (1-12) and add the current year or if 
	the period is after the current period, then will add the previous year.</P>
<P>leading zeros on the month are trimmed</P>
<P>two digit years are converted to four digit years by the ADDCENT function</P>
<H3>YEARPERIOD(type,input,mode)</H3>
<P>similar to PERIOD_OF_YEAR but internal&nbsp;format is YY.MM eg 99.01 or 9999.01
    if mode is xxxx,4</P>
<H3>CENTURY(type,input,mode)</H3>
<P>type="OCONV' only</P>
<P>given a year in two or four digit format return a four digit century</P>
<P>year 0-49 returns 2000-2049<br />
	year 50-99 returns 1950-1999</P>
<H3>ADDCENT(type,input,mode)</H3>
<P>type must be ICONV or defaults to OCONV</P>
<P>input internal format is 99 and external format is 9999</P>
<P>mode is not used</P>
<H2>Objects</H2>
<H3>exodusamount(string)</H3>
<P>given a string like "999USD"</P>
<P>returns an object</P>
<P>object.amount=999<br />
	object.unit="USD"<br />
	object.string="999USD"</P>
<H3>exodustimers(ntimers)</H3>
<P>returns an array of timers</P>
<P>object.start(timern)</P>
<P>object.stop(timern)</P>
<P>object.display()</P>
<H3>exodustimer()</H3>
<P>object.start()</P>
<P>object.stop()</P>
<P>object.elapsedtime</P>
<P>&nbsp;</P>
<P>joinarrays</P>
<P>tostatement</P>
<P>decodehtmlcodes</P>
<P>&nbsp;</P>
<P>exodusassertobject</P>
<P>exodusassertfunctionname</P>
<P>exodusassertstring</P>
<P>exodusassertnumeric</P>
