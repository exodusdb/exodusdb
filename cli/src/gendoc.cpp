#include <exodus/program.h>
programinit()

// Note: man pages are generated with a Unicode FOUR-PER-EM SPACE for fixed layout.
// man pages comments.replacer("\u22c5", "\u2005"); // "⋅" Unicode operator point operator -> " " FOUR-PER-EM SPACE
// comments.replacer("␣", "\u2005");
// Source code comments contain "\u22c5+"; "⋅" Unicode operator point operator and "␣" space indicater
// man_page_white_space_code_point = "\u2005"; // " " FOUR-PER-EM SPACE

let syntax =

R"__(gendoc osfilename ... [codefile_dir] [{OPTIONS}]

osfilename: e.g. ~/exodus/exodus/libexodus/exodus/{var.h,dim.h}

codefile_dir: Optional output of testing_var_h.cpp

Options:
	w = wiki source    ext .wiki
	m = man page       ext .1
	h = html (default) ext .htm
	o - Output to original dir
	V - Verbose
)__";

bool wiki = OPTIONS.contains("w");
bool man = OPTIONS.contains("m");
bool html = not (wiki or man);
let doc_ext = man ? "1" : (wiki ? "wiki" : "htm");

bool output_to_orig_dir = OPTIONS.contains("o");

let verbose = OPTIONS.count("V");

var tableno = 0;

// Default to current dir for example code output dir
var codefile_dir = "";

var all_code_matches = "";
var all_code_matches_ptr = 1;
let code_match_delim1 = "\n//``````\n";
let code_match_delim2 = "``````";
// For style switcher
let style_switcher_class = "light";

func main() {

	if (not COMMAND.count(FM)) {
		abort(syntax);
	}

	if (html) {

		// Pass 1 to collect and syntax highlight c++ code examples
		main2(true);

		// pygmentize cpp syntax highlighting
		{

			// Lambda converter will be used twice
			auto converter = [this](in cpp_in, out html_out) -> bool {

				// TODO enforce stdin stdout and stderr to be independent vars.
				var errors, exit_status;

				// Requires cd ~/exodus/pygment && ./install.sh
				let lexer = "exoduscpp";
				// pygmentize -l exoduscpp -f html -O full,style=colorful -o test.html test.cpp -v"

				// osprocess
				if (not var::osprocess(
					"pygmentize -l " ^ lexer ^ " -f html",
					/*in*/ cpp_in,
					/*out*/ html_out, errors, exit_status)
				)
					abort(lasterror() ^ " " ^ errors);

				// Remove the first two tags
				// <div class="highlight"><pre>
				html_out.cutter(html_out.indexn(">", 2));

				// Also this
				if (html_out.starts("<span></span>"))
					html_out.cutter(13);

				// Remove the last two tags
				// </pre></div>
				html_out.fieldstorer("<", -2, -2, "");
				html_out.popper();

				return true;
			};

			// 1. Convert all the code matches to html
			var converted_code_matches;
			converter(all_code_matches, converted_code_matches);

			// 2. Work out how it converted the code match separator so we can undo it
			var converted_code_match_delim1;
			converter(code_match_delim1, converted_code_match_delim1);

			// All code matches becomes the html converted version
			all_code_matches = converted_code_matches.replace(converted_code_match_delim1, code_match_delim2);

		}

		{
			// Optionally get pygmentize css
			// We have out own style embedded.
			if (false) {
				var errors, exit_status;
				if (not var::osprocess("pygmentize -S default -f html", "", css_cpp_style, errors, exit_status))
					abort(lasterror());
				css_cpp_style.prefixer("<style>\n");
				css_cpp_style.appender("</style>\n");
			}

		}

	}

	// Pass 2
	main2(false);

	stop();
}

func main2(in pass1) {

	var docfilename = ostempfile();

	// Start a temporary file for the example code
	//////////////////////////////////////////////

	var all_code_cleanups = "";
	var first_osfilenameonly = "";

	let codefile = ostempfile();
//	std::ofstream codefile(codefile.toString());

	codefile << "/" "/ Generated by " << COMMAND.f(1) << "\n";
	codefile << "\n";
	codefile <<

R"__(#include <cassert>

#include <exodus/program.h>
#ifndef EXO_FORMAT
#	define println printl
#endif
programinit()

func main() {

	// Options to skip testing
	{
		let msg = "Test passed. Without commencing because ";

		if (osgetenv("EXO_NODATA")) stop(msg ^ "EXO_NODATA was set.");

		if (not connect())          stop(msg ^ "No default db connection.");

		if (not open("xo_clients") or not reccount("xo_clients"))
		                            stop(msg ^ "xo_clients file is missing or empty.");
	}

	// Clean up before starting
	gosub cleanup();
)__";

	var all_contents = "";

///////////
// nextfile
///////////

	let nfiles = COMMAND.fcount(FM) - 1;
	dim file_texts(nfiles);
	file_texts = "";
	var filen = 0;

	for (let osfilename : COMMAND.remove(1)) {

		filen++;

		// Skip and capture output dir for examples .cpp
		if (osdir(osfilename)) {
			codefile_dir = osfilename;
			continue;
		}

		dim src;
		if (not src.osread(osfilename)) {
			errputl(lasterror());
			continue;
		}
//		src.converter("\n\r", _FM);
		let osfilenameonly = osfilename.field(OSSLASH, -1);

		// code is output using the name of the first file
		if (not first_osfilenameonly)
			first_osfilenameonly = osfilenameonly;

		// Start the code examples for this osfile
//		var file_header = osfilenameonly;
		////////////////
		// Code examples - from var.h
		////////////////
		codefile << "\n////////////////";
		codefile << "\n/" "/ Code examples " << osfilenameonly;
		codefile << "\n////////////////";
		codefile << "\n";

		var file_contents = "";

		var new_objs = "";
		var defined_objs = "";
		var all_func_sigs = "";
		tableno = 0;

		var class_name = osfilenameonly.field(".", 1);

		// Start a file for the documentation
		/////////////////////////////////////

		std::ofstream docfile(docfilename.toString());

		// Lines like "///... some text:"
		rex doc_rex(R"__(^(/{3,})\s+(.*):$)__");

		auto skipping = true;
		auto in_table = false;

		var comments = "";

		var default_objname = "var";

///////////
// nextline
///////////

		// Indexing instead of fieldwise so we can look back from any line
		for (let lineno : range(1, src.rows())) {

			// Alias srcline into the src dim array
			var& srcline = src[lineno];

			// tabs become spaces
//			srcline.replacer("\t", " ");
			srcline.replacer("\t", "    ");
//			srcline.trimmer();
			srcline.trimmerboth();

			if (srcline.starts("[[noreturn") and srcline.ends("]]"))
				continue; // nextline

			// class definitions
			if (srcline.starts("class ")) {
				srcline.replacer("PUBLIC ", "");
				// Find class xxx : or { or final
				let class_match = srcline.match(R"__(class\s+([a-zA-Z0-9_]+)\s*[:{f])__");
				if (class_match) {
					class_name = class_match.f(1, 2);
					default_objname = class_name;
					if (class_name == "ExoProgram")
						default_objname = "";
				}
				continue; // nextline
			}

			////////////////////////////
			// Start a section and table
			////////////////////////////

			// Match lines starting // and ending ":"
			var table_title = srcline.match(doc_rex);
			if (table_title) {


				skipping = false;

				// Close any prior table
				if (in_table) {
					if (man) {}
					else if (wiki) {
						docfile << "|}" << std::endl;
					} else {
						docfile << "</table>" << std::endl;
					}
					in_table = false;
				}

				// Empty table title results in closing table and skipping following functions
				// until another table title is found.
				if (not trim(table_title.f(1, 3)))
					continue; // nextline

				in_table = true;

				let short_title = table_title.f(1, 3).tcase().replace("Mv", "MV").replace("Os", "OS").replace("Db", "DB");

				let level = table_title.f(1, 2).len();
				if (man) {

					// Section header
					docfile << ".SH " << ++tableno << ". " << short_title.ucase() << std::endl;
					docfile << ".SH" << std::endl;
					docfile << std::endl;
				}
				else if (wiki) {

					let wiki_title = str("=", level);
					docfile << wiki_title << " " << short_title << " " << wiki_title << std::endl;
					docfile << "" << std::endl;
					docfile << "{|class=\"wikitable\"" << std::endl;
					docfile << "!Use!!Function!!Description" << std::endl;

				} else {

					var table_id = short_title.convert(" ", "_");

					let table_entry = "<li><a href=#" ^ table_id ^ ">" ^ short_title ^ "</a></li>\n";
					file_contents ^= table_entry;

					docfile << "<h" << level << " id=" << table_id << ">" << short_title << "</h" << level << ">" << std::endl;
					docfile << "" << std::endl;
					docfile << "<table class=wikitable>" << std::endl;
					docfile << "<tr> <th>Use</th> <th>Function</th> <th>Description</th> </tr>" << std::endl;
				}
				continue; // nextline
			}

			// private declaration turns off documentation
			if (srcline == "private:")
				skipping = true;
			else if(srcline == "public:")
				skipping = false;
			if (skipping or not in_table)
				continue; // nextline

			///////////////////////////////////////
			// Find a function declaration (tricky)
			///////////////////////////////////////

			//	static int getprecision() const;
			let origsrcline = srcline;
			// TODO replacer to return a bool that it did something?
			// but a returned bool could easily be accidentally used as a var.
			// Use a thread_local global variable flag?
			srcline.replacer(R"__(\bstatic\s+)__"_rex, "");
			bool is_static = srcline ne origsrcline;

			// Not documenting ND or not since mostly ND
			auto no_discard = srcline.starts("ND ");
			if (no_discard)
				srcline.cutter(3);
//
//			// Only interested in certain function declarations and comments starting exactly //
//			var prefix = srcline.field(" ", 1);
//
//			if (prefix == "friend" || prefix.starts("CONST")) {
////				TRACE(prefix)
//				srcline = srcline.field(" ", 2, 999999).trimfirst();
//				prefix = srcline.field(" ", 1);
//			}

            srcline.replacer(R"__(^((friend)|(CONST[^\s]*))\s)__"_rex, "");
			srcline.trimmerfirst();
            var prefix = srcline.field(" ", 1);

			// Suppress lines that are not comments or function declarations
			if (not prefix.starts("/") and not srcline.match(R"__(^[\sa-zA-Z0-9_:&]+\()__")) {
				var remainder = srcline.field(" ", 2, 99999).trimfirst();
				if (not remainder.starts("operator"))
					prefix = "";
			}

			bool is_constructor = false;

			// Include lines starting var
			// Warning: lines like "var xxx = 123;" are NOT function declarations
			if (prefix == "var" or prefix == "int")
				prefix ^= "=";

			else if (prefix.starts("dim(") or prefix.starts("var(")) {
				is_constructor = true;
			}

			else if (prefix == "std::string") prefix = "var="; // i/oconv private

			else if (prefix == "RETVAR") prefix = "="; // from var_base

			// const var&
			else if (prefix == "CVR")  prefix = "expr";// only for output/logput/errput etc.
			else if (prefix == "CBR") prefix = "expr"; // from var_base

			// var& (various types)
			else if (prefix == "io")   prefix = "expr";// none should return this
			else if (prefix == "IO")   prefix = "cmd"; // ditto. (now IO=void for mutator -er)
			else if (prefix == "VARREF") prefix = "VARREF"; // exo::var& from var_base
			else if (prefix == "out")  prefix = "expr";// only input and getlocale

			// bool
			else if (prefix == "bool") prefix = "if";  // many return true/false

			// void
			else if (prefix == "void") prefix = "cmd"; // many return nothing

			// dim
			else if (prefix == "dim") prefix = "dim=";

			// int (rare)
			else if (prefix == "int") {prefix = "int";} // setprecision/getprecision

			else {

				if (prefix == "/" "/") {

					// Collect possible function preamble comments
					// Exactly // (two slashes, not more)
					comments ^= srcline.substr(4) ^ FM_;

				} else {

					if (verbose == 2)
						TRACE(srcline)

					// Throw away non-function preamble comments
					////////////////////////////////////////////

					// From thrown away comments, get the default obj name for all following functions
					// except where overridden in specific function comments.
					// Only match "obj is xxx|yyy|zzz()" at the start of the first line of comment.
					let new_default_objname = comments.match(R"__(^\s*obj is ([a-zA-Z_][a-zA-Z0-9_()|]+))__").f(1, 2);

					if (new_default_objname) {
						new_objs ^= new_default_objname ^ FM;
						default_objname = new_default_objname;
					}

					// Throw away collected comments if not contiguous
					comments = "";
				}
				continue; // nextline
			}

			// Skip [[deprecated]] and [[undocumented]] functions
			static rex undocumented(R"__(\[\[(deprecated|undocumented))__");
			if (comments.match(undocumented))
				continue; // nextline

			///////////////////////////////
			// Found a function declaration
			///////////////////////////////

			if (not is_constructor)
				srcline = srcline.field(" ", 2, 9999).trimfirst();

//			var comments = srcline.field("{", 1).field(";", 2, 9999).trimmerfirst("/ ");
//			var comments = srcline.field("/" "/", 2, 99999).trimfirst();
			let trailing_comment = srcline.field("/" "/", 2, 99999);
			srcline = srcline.field("/" "/", 1).field("{", 1).trimlast();
			let funcname = srcline.field("(", 1);

			// Use trailing comment overerides leading comments
			if (trailing_comment)
				comments = trailing_comment;
			else
				comments.popper();

			// Extract and remove any "obj is xxx|yyy|zzz()" lines in comments for specific functions
			// comments is FM separated at this point (dont forget that \s matches FM chars)
			let objmatch = comments.match(R"__([ \t]*obj is ([a-zA-Z_][a-zA-Z0-9_()|]+)[^\n)__" _FM "]*");
			if (objmatch) {
				comments.replacer(FM ^ objmatch.f(1, 1), "");
				new_objs ^= objmatch.f(1, 2).convert("|()", FM) ^ FM_;
			}
			let objname = objmatch.f(1,2);

			/////////////////////
			// Handle code blocks
			/////////////////////

			// Format backticked source code fragments
			if (comments.contains("`")) {
				// FMs inside backticks (c++ code) become simple "\n"
				bool backtick = false;
				for (int charn : range(1, comments.len())) {
					char charx = comments.substr(charn, 1).toChar();
					if (charx == '`') {
						backtick = not backtick;
						continue;
					}
					if (backtick && charx == FM_) {
						comments.paster(charn, 1, "\n");
					}
				}

				// Prevent extra </p> before or after `
				static rex rex1 {R"__(`\s*)__" _FM};
				static rex rex2 {_FM R"__(\s*`)__"};
				comments.replacer(rex1, "`\n");
				comments.replacer(rex2, "\n`");

				// Add a backtick if an odd numbers is present indicating forgot to close c++ code
				if (comments.count("`") % 2) {
					if (comments.count("`") > 1 ) {
						abort("Error: Odd number of backticks in " ^ funcname.quote());
					}
					logputl("Warning: Missing closing backtick in " ^ funcname.quote());
					comments ^= "`";
				}

				// regex between pairs of backticks
				static rex backquoted_rex {R"__(`([^`]*)`)__"};

				var codematches = comments.match(backquoted_rex);

				// Replace space formatting with single space
				codematches.replacer("\u22c5+"_rex, " "); // "⋅" Unicode operator point operator -> space

////////////////
// nextcodematch
////////////////
				for (var codematch : codematches) {
					codematch = codematch.f(1, 2);

					// Just accumulate code matches in pass1
					if (pass1) {
						// First line indented 1 char by the the back tick
						if (not codematch.starts(" "))
							codematch.replacer("\n ", "\n");
						all_code_matches ^= codematch ^ code_match_delim1;
						continue;
					}

					// ... becomes proper code
					let aborting = " abort(\"" ^ funcname ^ ": \" ^ lasterror());";
					codematch.replacer(") ... ok", ") {/" "*ok*" "/} else " ^ aborting);
					codematch.replacer(") ... true", ") {/" "*true*" "/} else " ^ aborting);
					codematch.replacer(" ...", aborting);
					codematch.replacer("\n", "\n\t\t");
					codematch.replacer("\n\t\t\n", "\n");

					codematch.replacer("\t ", "\t");

					// Remove "// Cleanup" lines to be put in heading of
					static rex cleanup_pattern {R"__(^[^\n]*// Cleanup[^\n]*)__"};
					var cleanups = codematch.match(cleanup_pattern);
					if (cleanups) {
						for (let cleanup : cleanups) {
							all_code_cleanups ^= cleanup ^ "\n";
						}
						codematch.replacer(cleanup_pattern, "");
					}

					// Convert some comments to assertions
					// USE ␣ to indicate spaces. They will be converted to spaces in any assert.
					// Warning: Doesnt handle double quotes inside double quote)?

					// IMPLICT ASSERTS
					// e.g. '   let|var v1 = xxxxxxx ; // "X" // zzzz' where zzzz can be a literal number 9999, "xxx", true or false
					//      '1112222222 3344444444444     55556666666'
//					static rex rex3 = rex(R"__(^(\s*)(let|var)?\s+([a-z0-9A-Z_]+) = ([^\n]*?);[ \t]*//\s+(true|false|["0-9.-][^\n]*?)([ \t]//[^\n]*?)?$)__", "m");
					static rex rex3 = rex(R"__(^(\s*)(let|var)\s+([a-z0-9A-Z_]+) = ([^\n]*?);[ \t]*//\s+(true|false|["0-9.-][^\n]*?)([ \t]//[^\n]*?)?$)__", "m");

//					codematch.replacer(rex3, "\t$1$2 $3$4; assert($3 == $5);$6");
					codematch.replacer(rex3, "\t\t$2 $3 = $4; assert($3 == $5);$6");

					// e.g. '           v1 = xxxxxxx ; // "X" // zzzz' where zzzz can be a literal number 9999, "xxx", true or false
					//      '1112222222 3344444444444     55556666666'
					static rex rex3b = rex(R"__(^(\s*)()([a-z0-9A-Z_]+) = ([^\n]*?);[ \t]*//\s+(true|false|["0-9.-][^\n]*?)([ \t]//[^\n]*?)?$)__", "m");
					codematch.replacer(rex3b, "\t\t$2$3 = $4; assert($3 == $5);$6");

					// ARROW ASSERTS
					//        if (not field.readf(file, key, fieldno)) abort("readf" ": " ^ lasterror()); // field -> "G"
					// e.g. '  // v1 -> "f1^X^f3"_var // v2 -> "a b c"'
					//        1   22    33333333333333
					static rex rex5 = rex(R"__(([^/])//\s*([a-zA-Z0-9_.()]+)\s*->\s*([^/\n]*))__");
					codematch.replacer(rex5, "$1 assert($2 == $3);");
					// Why does it need multiple replaces? (possibly because group 3 overlaps with group 1)
					codematch.replacer(rex5, "$1 assert($2 == $3); ");
					codematch.replacer(rex5, "$1 assert($2 == $3); ");
					codematch.replacer(rex5, "$1 assert($2 == $3); ");
					codematch.replacer(rex5, "$1 assert($2 == $3); ");

//					// MUTATOR ASSERTS
//					// e.g. 'v1.xxx xxx xxx // zzzz // xxxxxx'
//					// e.g. 'v1.ucaser(); // "ABC"'
					static rex rex4 = rex(R"__(^(\s*)([a-z0-9A-Z_]+)\.([^/\n]*)//\s+([^/\n]*)([^\n]*))__");
					codematch.replacer(rex4, "$1$2.$3;assert($2 == $4);$5");

					// Replace hacked spaces ␣ with real spaces " "
					codematch.textconverter("␣", " ");

					// Wrap in {}
					codematch.prefixer("\n\t{\n\t\t");
					codematch ^= "\n\t}\n";

					// Exclude format from tests in old version of Ubuntu
					bool uses_format = codematch.match(R"__((print|println|format)\()__");
					if (uses_format) {
						codefile << "#ifdef EXO_FORMAT\n";
					}

					// Lead with function name
					codematch.prefixer("\n\tprintl(" ^ srcline.quote() ^ ");");

					// Global definitions;
					for (var objname : new_objs) {
						objname.converter("()", "");
						if (not objname or objname == "var")
							continue; // nextcodematch

						if (not locate(objname, defined_objs)) {
							defined_objs ^= objname ^ VM;
							// Declare a var if "obj is"
							//codematch.prefixer("\n\tvar " ^ objname ^ ";\n");
						}
					}
					new_objs = "";

					// Move rhs asserts onto separate lines
//					codematch.replacer(rex(R"__(;\s*assert([^\n;]*))__"), ";\n\t\tassert\$1\n\t");

					// Tidy up
					codematch.replacer(rex(R"__(\n;)__"), ";\n");
					codematch.replacer(rex(R"__(\n(\n[\t ]*assert))__"), "$1");
					codematch.replacer(rex(R"__([\t ]*\n)__"), "\n");

					codefile << codematch;
//					var codematch2, errors, exit_status;
//TRACE("PYGMENTIZE")
//TIMESTAMP=ostimestamp();
//					if (not var::osprocess("pygmentize -f html", codematch, codematch2, errors, exit_status)) {
//						loglasterror();
//						codematch2 = codematch;
//					}
//TRACE(elapsedtimetext())
//TRACE(codematch2)
//static var codematches = "xyz";
//codematches << codematch;
//					codefile << codematch2;

					if (uses_format) {
						codefile << "#endif\n";
					}
				} // next codematch

				// We only need to collect code matches in pass1
				if (pass1)
					continue; // nextline

				// Remove one leading space (should only be from code)
				comments.replacer("\n ", "\n");
				//oswrite(comments on "x");

				// tag backticked code as c++
				if (man) {

					// Man page codes
					// .RS Right shift
					// .nf No format
					// .RE REturn (left shift)
					// .fi formatting
					// Prefix by a section title "Example:"
					comments.replacer(backquoted_rex, "\nExample:\n.RS\n.nf\n$1\n.fi\n.RE\n");
				}
				else if (wiki)
					comments.replacer(backquoted_rex, "<syntaxhighlight lang=\"c++\">\n$1</syntaxhighlight>");
				else {

//					// Javascript instead of cpp because it gives better highlighting for exodus c++. See above too.
//					// (All function calls are highlighted)
//					comments.replacer(backquoted_rex, "\n<pre><code class='hljs-ncdecl language-javascript'>$1</code></pre>\n");
//					comments.replacer(backquoted_rex, "\n<pre><code class='language-cpp'>$1</code></pre>\n");
//					comments.replacer(backquoted_rex, "\n<textarea class=code-block>$1</textarea>\n");

					// Use a lambda that consumes all_code_matches sequentially using a pointer into all_code_matches
					comments.replacer(
						backquoted_rex,
						[this](in /*codeblock*/) {
//TRACE(all_code_matches_ptr)
							let end_charn = all_code_matches.index(code_match_delim2, all_code_matches_ptr);
							let code_match_len = end_charn ? end_charn - all_code_matches_ptr : all_code_matches.len();
							let code_match = all_code_matches.substr(all_code_matches_ptr, code_match_len);
							all_code_matches_ptr += code_match_len + code_match_delim2.len();
//TRACE(codeblock)
//TRACE(all_code_matches_ptr)
//TRACE(end_charn)
//TRACE(code_match_len)
//TRACE(code_match)
//input();
							return "<div class=\"highlight " ^ style_switcher_class ^ "\"><pre>" ^ code_match ^ "</pre></div>";
						}
					);

				}
				// Ordinary spaces for aligning code in html and wiki
				if (not man)
					comments.replacer("\u22c5", " "); // "⋅" Unicode operator point operator -> " "
			}

/////////////////////////
// probably function line
/////////////////////////

			// Can still bail out anywhere down to lineinit below

			// After using backticks to delimit c++ code.
			comments.replacer("{backtick}", "`");

			if (man) {

				// man page formatting function by function

				// hide dot/space formatting
				comments.replacer("\u22c5", "\u2005"); // "⋅" Unicode operator point operator -> " " FOUR-PER-EM SPACE
				comments.replacer("␣", "\u2005");

				// DOUBLE SPACE paragraphs to avoid man joining them up?
				comments.replacer(_FM, "\n\n");

				// Bullet points for lines starting * + space
    			comments.replacer("\n\n* "_var, "\n.br\n<REAL_BS>(bu "_var);

				// Auto numbered points
				// # xxx
				// # yyy
				comments.replacer(R"__((^# .*?\n\n){2,999})__"_rex, [](in lines) {
					dim response = lines.f(1, 1).trim(NL).split(NL);
					let fmt = "R#" ^ response.rows().len(); // 1. R#1, 10. R#2
					for (let ln : range(1, response.rows()))
						response[ln] = ".br\n" ^ ln.oconv(fmt) ^ ". " ^ response[ln].cut(2);
					return response.join(NL) ^ NL;
				});

			} else if (wiki) {
				comments.replacer(_FM, "\n\n");
			} else {
				// html
				thread_local rex field_rex {R"__([^\x1e]+\x1e)__"};
//oswrite(comments on "x");
//stop();
				comments.replacer(R"__((^|\x1e)([a-zA-Z0-9_.]+):(\s*))__"_rex, "\x1e<em>$2:</em>$3");
				// Replace all xxxxxxxx^ with <p>xxxxxxx</p>\n
				comments.replacer(field_rex, "<p>$&</p>\n");
				comments.converter(_FM, _NL);
			}

			// Clean up function args
			var line2 = srcline.field(";", 1);
			{

				if (verbose == 1) {
					TRACE(line2)
				}

				// "ARGS&... appendable" -> "appendable, ..."
				line2.replacer(R"__(\b[a-zA-Z][a-zA-Z0-9]*\s*&{1,2}\s*\.\.\.\s*\b([a-zA-Z][a-zA-Z0-9]*))__"_rex, "$1, ...");

				line2.replacer("\\bstd::size_t\\b", "");
				line2.replacer("\\bconst&&\\b", "");
				line2.replacer("\\bconst&\\b", "");
				line2.replacer("\\bconst\\b"_rex, "");
				line2.replacer("\\bin\\b"_rex, "");
				line2.replacer("\\bSV\\b"_rex, "");
				line2.replacer("(int)", "(INT)"); // preserve operator++(int) for later analysis
				line2.replacer("\\bint\\b"_rex, "");
				line2.replacer("\\bint\\b"_rex, "");
				line2.replacer("\\bchar\\*"_rex, "");
				line2.replacer("\\bbool "_rex, "");
				line2.replacer("\\bbool "_rex, "");
				line2.replacer("\\bstd::size_t "_rex, "");
				line2.replacer("\\brex& "_rex, "");
	//			line2.replacer("\\bdim& "_rex, ""); // needed to create this text below "dim d1 = d2; // Copy"
				line2.replacer("\\bCVR "_rex, "");
				line2.replacer("\\bCBR "_rex, "");
				line2.replacer("\\bVARREF "_rex, "io");
				line2.replacer("\\bCONSTEXPR "_rex, "");
				line2.replacer("= _", "= ");
				line2.trimmer();
				line2.replacer("( ", "(");
				line2.replacer(" )", ")");

	//			line2.replacer("dim& ", "dim ");
	//			line2.replacer("dim& ", "");
				line2.replacer("noexcept", "");

				// SKIP temporaries and deleted functions
				if (line2.ends("&&") || line2.ends("= delete"))
					continue; // nextline

				// Skip copy and move assignment
				// void operator=(const dim& rhs) &;
				// void operator=(dim&& rhs) & noexcept {
	//			if (line2.starts("operator=(const " ^ class_name ^ "&"))
	//				continue;
	//			if (line2.starts("operator=(" ^ class_name ^ "&&"))
	//				continue;
				if (line2.match(R"__(\boperator\s*=\s*\(\s*(const)?\s*[a-zA-Z0-9_]+\s*&)__"))
					continue; // nextline

	//			// operator=(v1)
	//			// dim d1 = v1;
	//			if (line2.match(R"__(\boperator\s*=)__")) {
	//				line2.replacer(R"__(\boperator=\(([a-zA-Z0-9_]+)\))__"_rex, class_name ^ " " ^ class_name.first() ^ "1 = $1;");
	//			}

				if (line2.ends("&")) {
					line2.popper();
					line2.trimmerlast();
				}

				if (line2.ends("REF")) {
					line2.cutter(-3);
					line2.trimmerlast();
				}

			} // end of clean up function arguments

			// SKIP if no comments and already output
			if (not comments and locate(line2, all_func_sigs))
				continue; // nextline

			all_func_sigs ^= line2 ^ VM;

			if (verbose == 1) {
				TRACE(line2)
			}

			// i/oconv_MD(const char* conversion) -> i/oconv("MD")
			var func_decl0 = line2.replace(R"__(([io])conv_([A-Z]+)\([a-zA-Z0-0_*]*\))__"_rex, "$1conv(\"$2\")");

			//    var  exoprog_date(in type, in input0, in ndecs0, out output);
			func_decl0 = func_decl0.replace(R"__(exoprog_date\(.*)__"_rex, "iconv|oconv(var, \"[DATE]\")");

			//    var  exoprog_number(in type, in input0, in ndecs0, out output);
			func_decl0 = func_decl0.replace(R"__(exoprog_number\(.*)__"_rex, "iconv|oconv(var, \"[NUMBER]\")");

			// Prefix the object name
			var func_decl;
			if (not is_constructor) {

				func_decl0.replacer("dim& ", "");

				if (line2.match(R"__(\boperator\s*=)__")) {

					// "operator=(v1)" -> "dim d1 = v1;"
					func_decl = func_decl0.replace(R"__(\boperator\s*=\s*\(\s*([a-zA-Z0-9_]+)\s*\))__"_rex, class_name ^ " " ^ class_name.first() ^ "1 = $1;");
				}

				else if (line2.match(R"__(\boperator\s*<<\s*\()__")) {

					// operator<<(auto& value)
					// operator<<(std::ostream& (*manip)(std::ostream&))
					if (line2.contains("manip"))
//						func_decl = "osfile << std::setw(n) << std::endl; etc.";
						continue; // nextline
					else
						func_decl = "osfile << anything << std::endl;";
					prefix = "";
				}
				else if (line2.match(R"__(\boperator\s*\[\]\s*\()__")) {

					// "operator[](rowno)"
					// "operator[](rowno, colno)"
					// -> "var v1 = d1[rown];   d1[rown] = v1;"
					// -> "var v1 = d1[rown, coln];   d1[rown, coln] = v1;"
					func_decl = func_decl0.replace(
						R"__(\boperator\s*\[\]\s*\(\s*([^\)]+)\))__"_rex,
						 "var v1 = " ^ class_name.first() ^ "1[$1];       " ^ class_name.first() ^ "1[$1] = v1;"
					);
					if (html or wiki)
						func_decl.replacer("       ", "</br>");
					// Use on left and right hand side
					prefix = "";
					}

				else if (line2.contains("operator\"\"_")) {
					// operator""_var(cstr, std::size_t size);
					// ->
					// var v1 = ""_var
					func_decl = func_decl0.replace(
						R"__(\boperator""_([a-zA-Z0-9_])([a-zA-Z0-9_]+).*)__"_rex,
//						"$1$2 ${1}1 = \"\"_$1$2"
						"\"\"_$1$2"
					);

				}
				else if (line2.match(R"__(\boperator\s*\(\)\s*\()__")) {
					//operator()(fieldno, valueno = 0, subvalueno = 0);
					func_decl = func_decl0.replace(" = 0", "").replace(
						R"__(\boperator\s*\(\)\s*\(\s*([^\)]+)\))__"_rex,
						class_name.first() ^ "2($1);       " ^ class_name.first() ^ "1($1) = v2"
					);
				}

				else if (line2.match(R"__(\boperator\s*[\+\-\*\/\%\^]\s*\(.*)__")) {
					//operator+(var)
					// v2 + v3
					func_decl = func_decl0.replace(
						R"__(\boperator\s*([\+\-\*\/\%\^])\s*\(.*)__"_rex,
						class_name.first() ^ "2 $1 " ^ class_name.first() ^ "3"
					);
				}

				else if (line2.match(R"__(\boperator\s*[\+\-\*\/\%\^]=\s*\(.*)__")) {
					//operator+=(var)
					// v1 += v2
					func_decl = func_decl0.replace(
						R"__(\boperator\s*([\+\-\*\/\%\^]=)\s*\(.*)__"_rex,
						class_name.first() ^ "1 $1 " ^ class_name.first() ^ "2"
					);

					// Prevent prefixing with "var v1 = "
					prefix = "";
				}

				else if (line2.match(R"__(\boperator\s*[\+\-]{2,2}\s*\(INT\))__")) {
					//operator++(int);
					// v1 ++
					func_decl = func_decl0.replace(
						R"__(\boperator\s*([\+\-]{2,2})\s*\(.*)__"_rex,
						class_name.first() ^ "1 $1"
					);

					// Prevent prefixing with "var v1 = "
					prefix = "";
				}

				else if (line2.match(R"__(\boperator\s*[\+\-]{2,2}\s*\(\))__")) {
					//operator++();
					// ++ v1
					func_decl = func_decl0.replace(
						R"__(\boperator\s*([\+\-]{2,2})\s*\(.*)__"_rex,
						"$1 " ^ class_name.first() ^ "1"
					);

					// Prevent prefixing with "var v1 = "
					prefix = "";
				}

//				else if (prefix == "int=") {
//					func_decl = func_decl0;
//				}

				else {
					// xxxxxxxxx -> var.xxxxxxxxx
					if (default_objname) {
						func_decl = (objname ?: default_objname) ^ "." ^ func_decl0;
					} else
						func_decl = func_decl0;

					if (is_static)
						// var(). -> var::
						func_decl.replacer("().", "::");
				}

			} else {
//TRACE(func_decl0)
//TRACE: func_decl0 = "dim() = default"
//TRACE: func_decl0 = "dim(dim& sourcedim)"
//TRACE: func_decl0 = "dim(dim&& sourcedim)"
//TRACE: func_decl0 = "dim(nrows, ncols = 1)"
//TRACE: func_decl0 = "dim(std::initializer_list<T> list)"
				// dim(xxx) -> dim d(xxx);
				// dim() -> dim d;
				var args = func_decl0.field("(", 2, 999999).field(")", 1);
				var arg1 = args.field(" ", 1);
				let class_letter = func_decl0.first(1);

				// Default constructor
				if (arg1 == "") {
					// dim() -> dim d1;
					func_decl = class_name ^ " " ^ func_decl0.first(1) ^ "1;";
					prefix = "";
				}
				// Copy constructor
				else if (arg1 == (class_name ^ "&")) {
					// dim(dim&) -> dim d1 = d2;
					prefix = "";
					func_decl = class_name ^ " " ^ class_letter ^ "1 = " ^ class_letter ^ "2; /" "/ Copy";
				}
				// Move constructor
				else if (arg1 == (class_name ^ "&&")) {
					// dim(dim&&) -> dim d1 = dim();
					prefix = "";
					func_decl = class_name ^ " " ^ class_letter ^ "1 = " ^ class_name ^ "(); /" "/ Move";
				}
				else if (arg1.starts("std::initializer_list")) {
					// -> dim d1 = {"a", "b", "c", "d" ...};
					prefix = "";
					func_decl = class_name ^ " " ^ class_letter ^ R"__(1 = {"a", "b", "c" ...};)__" " /" "/ Initializer list";
				}
				// Other constructors
				else {
					// dim(nrows, ncols = 1) -> "dim d1(nrows, ncols = 1);
					func_decl = class_name ^ " " ^ class_letter ^ "1(" ^ args ^ ");";
					prefix = "";
				}

			}

//			// bold the function name
//			if (man) {}
//			else if (wiki) {
//				line2.prefixer("<em>");
//				line2.paster(line2.index("("), "</em>");
//			} else {
//				line2.prefixer("<span class='gendoc_function'>");
//				line2.paster(line2.index("("), "</span>");
//			}

			if (prefix == "cmd" or prefix == "cmd2")
				prefix = "";

///////////
// lineinit
///////////

			// No going back from here because we start outputting to docfile

			if (man) {

				var func_decl2 = func_decl;

				let match1 = prefix.match("([a-zA-Z_0-9]+)=").f(1, 2);

				if (prefix == "if")
					func_decl2 = "if (" ^ func_decl ^ ") ...";

				else if (match1) {
					//var= int=
//					func_decl2 = "var v1 = " ^ func_decl ^ ";";
//					func_decl2 = "int i1 = " ^ func_decl ^ ";";
					func_decl2 = match1 ^ " " ^ match1.first() ^ "1 = " ^ func_decl ^ ";";
				}
//				else if (prefix == "var=")
//					func_decl2 = "var v1 = " ^ func_decl ^ ";";

				// Subsection header
				docfile << ".SS" << std::endl;
				// Put on a separate line to avoid suppression of double quote chars
				docfile << func_decl2 << std::endl;

//				docfile << ".sp" << std::endl; // ignored
				// Hack to defeat man's stubborn insistence on suppressing blank lines between section title and section text
				docfile << ".nf" << std::endl;
//				docfile << " " << std::endl; // ignored
//				docfile << ".sp" << std::endl; // ignored
//				docfile << "\u000A" << std::endl; // ignored
//				docfile << "\u2003" << std::endl; //U+2003 EM SPACE
				docfile << "\u2005" << std::endl; //U+2005 Four-Per-Em Space
				docfile << ".fi" << std::endl;

				docfile << comments << std::endl;
				docfile << "" << std::endl;
			}
			else if (wiki) {
				docfile << "|-" << std::endl;
				docfile << "|" << prefix << "||" << func_decl << "||" << comments << std::endl;
			} else {
				// Using javascript see below too
				docfile << "<tr><td>" << prefix << "</td><td>" << func_decl <<  "</td><td>" << comments << "</td></tr>" << std::endl;
			}

// format() slows compilation a lot for one off compilations (2.8/0.73 secs i.e x4)
// so maybe wait for a modules version of fmt library
//			println("|" "{}" "||" "<em>" "{}" "</em>" "." "{}" "||" "{}", prefix, objname, line2, comments);

		} // srcline

/////////////
// osfileexit
/////////////

		//////
		// doc
		//////
		{
			var doc_body;
			if (not osread(doc_body from docfilename))
				abort(lasterror());

			if (not osremove(docfilename))
				loglasterror();

			if (man) {

				// man page formatting at the end

				// Escape back slashes for man pages comments
				doc_body.replacer("&bsol;", _BS);
				doc_body.replacer(_BS, _BS _BS);

				// but man pages require some real BS in macros
				doc_body.replacer("<REAL_BS>", _BS);

				// Emphasise/highlight leading words xxxxxxx:
				doc_body.replacer(R"__(^([a-zA-Z0-9_."]+):(\s+))__"_rex, R"__(\fB$1:\fR$2)__");

				// Man page codes
				// .RS Right shift
				// .nf No format
				// .RE REturn (left shift)
				// .fi formatting
				doc_body.replacer(R"__(^<pre>)__"_rex, ".nf");
				doc_body.replacer(R"__(^</pre>)__"_rex, ".fi");

			} else {
				// Done above. Too late here since <p> added already
//				doc_body.replacer(R"__(^([a-zA-Z0-9_.]+):(\s*))__"_rex, "<em>$1:</em>$2");
			}

			// Close prior table
			if (in_table) {
				if (man) {}
				else if (wiki)
					doc_body ^= "|}:" "\n";
				else
					doc_body ^= "</table>" "\n";
			}

			// Create the final doc text

			var doc_text = "";

			// 1. css and contents

			if (man) {}

			else if (wiki) {}

			else if (html) {

				let osfile_id = osfilenameonly.field(".");
				let osfile_title = osfilenameonly.field(".");
				all_contents ^= "<li><a href=#" ^ osfile_id ^ ">" ^ osfile_title ^ "</a></li>\n";

				// Contents
				doc_text ^= "<div class=toc>\n";

				doc_text ^= "<h4 id=" ^ osfile_id ^ ">Contents:</h4>\n";

				doc_text ^= "<ol>\n";
				doc_text ^= file_contents;
				doc_text ^= "\n";
				doc_text ^= "</ol>\n";

				doc_text ^= "</div>\n";

			}

			// 2. header

			if (man) {
				doc_text ^= ".TH " ^ osfilenameonly;
//				doc_text ^= "\n";
//				doc_text ^= file_header;
				doc_text ^= "\n\n";
			}
			else {
//				doc_text ^= file_header;
				doc_text ^= "\n\n";
			}

			// 3. body

			doc_text ^= doc_body;
			doc_text ^= "\n";

			if (not output_to_orig_dir) {

				if (man)
					outputl(doc_text);
				else
					// Save it for output after all_contents in this program's exit
					file_texts[filen] = doc_text.move();
			}
			else {
				// Change .h to .1, .wiki. .htm etc.
				var doc_osfilename = osfilename.fieldstore(".", -1, 1, doc_ext);

				// Update doc if needed
				var old_doc_text;
				if (not osread(old_doc_text from doc_osfilename))
					old_doc_text = "";
				if (doc_text ne old_doc_text) {
					if (not oswrite(doc_text on doc_osfilename))
						abort(lasterror());
					outputl("gendoc: Installing: ", doc_osfilename);
				} else
					outputl("gendoc: Up-to-date: ", doc_osfilename);
			}

		} // doc

	} // osfilename

///////
// exit
///////

	if (pass1)
		return 0;

	// Prefix multifile contents
	if (html) {

		var doc_text = "";
		let page_title = "";
		doc_text ^=
			"<!DOCTYPE html>\n"
			"<html>\n"
			"<head>\n";
	//					"  <title>" ^ page_title ^ "</title>"

		// css and script
		doc_text ^= css;
		doc_text ^= "\n";

		// css for cpp syntax
		doc_text ^= css_cpp_style;

//		doc_text ^= style_switcher_head;

		doc_text ^=
			"</head>\n"
			"<body class=\"" ^ style_switcher_class ^ "\">\n";

//		doc_text ^= style_switcher_dropdown;

		if (all_contents) {

			doc_text ^= "<div class=toc>\n";

			doc_text ^= "<h3>Sections:</h3>\n";

			doc_text ^= "<ol>\n";
			doc_text ^= all_contents;
			doc_text ^= "\n";
			doc_text ^= "</ol>\n";

			doc_text ^= "</div>\n";
		}

		// Output the html header
		printl(doc_text);

		// Output each file's html
//		for (let filen : rang(1, nfiles)) {
		for (in file_text : file_texts) {
			printl(file_text);
		}

		// Insert the latest version of exodus keywords
		var exodus_keywords = osread(osgetenv("HOME") ^ "/exodus/exodus/libexodus/exodus/keywords.txt").field("\n",2,999999);
		// Make unique FM array
		exodus_keywords = exodus_keywords.convert(",'\n", "   ").trim().convert(" ", FM).sort().unique();
		// Text fold at 80 and insert an escaped NL
		exodus_keywords = exodus_keywords.convert(FM, " ").oconv("T#80").trimlast().replace(rex("\\s*" _TM), " \\\n");
		syntax_hljs_bottom.replacer("EXODUS_KEYWORDS", exodus_keywords);

		printx(syntax_hljs_bottom);

//		printx(style_switcher_foot);

		// Finalise the html
		printl(
			"</body>\n"
			"</html>"
		);

	}

	/////////////////////
	// handle code output
	/////////////////////
	{

		// Finalise the code output
		codefile << "\n////////";
		codefile << "\n// exit:";
		codefile << "\n////////";
		codefile << "\n";
		codefile << "\n\tgosub cleanup();" << std::endl;
		codefile << "\n\tprintl(\"Test passed.\");\n";
		codefile << "\n\treturn 0;\n}";
		codefile << "\nsubroutine cleanup() {" << std::endl;
		codefile << "\n\t" "/" "/Note that all '// Cleanup' lines in the original source code must use literals and not variables" << std::endl;
		codefile << "\t" "/" "/otherwise the generated code will VNA on cleanup" << std::endl;
		codefile << all_code_cleanups;
		codefile << "};";
		codefile << "\n\nprogramexit()" << std::endl;

		// Move the temp code examples cpp file into destination
		////////////////////////////////////////////////////////

		codefile.close();

		if (codefile_dir) {

			var newcode = "";
			if (not osread(newcode from codefile))
				abort(lasterror());

			let code_filename = codefile_dir ^ "/" ^ "testing_'orig'.cpp"_var.replace("'orig'", first_osfilenameonly);
			var oldcode = "";
			if (not osread(oldcode from code_filename)) {
				oldcode = "";
			}

			// Only update if the text has changed
			logput("gendoc: ");
			if (newcode != oldcode) {
				if (not oscopy(codefile to code_filename))
					abort(lasterror());
				logput("Installing:");
			} else
				logput("Up-to-date:");
			logputl(" ", code_filename);
		}

	} // code

	return 0;

} // main2

////////////
// syntax_js
////////////

	let syntax_hljs_top =

R"__(
)__";

	var syntax_hljs_bottom =

R"__(
)__";

//////
// css
//////

var css =
R"__(
	<!-- bootstrap css. Is this necessary? -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

<style>

body {
	margin: 10px;
}

pre {
	margin: 0px;
	white-space: pre-wrap;
	word-wrap: break-word;
	white-space: -moz-pre-wrap;
	white-space: -pre-wrap;
	white-space: -o-pre-wrap;
	overflow-wrap: break-word;
	overflow-x: auto;
}

table, th, td {
	border: 1px solid #a2a9b1;
}

th {
	background-color: #eaecf0;
	font-weight: bold;
	text-align: left;
	padding: 8px;
}

td {
	padding: 0.2em 0.4em;
	vertical-align: top;
}

p {
  margin: 0.4em 0 0.5em 0;
}

.toc, .toccolours {
	border: 1px solid #a2a9b1;
	background-color: #f8f9fa;
	padding: 5px;
	font-size: 95%;
}
.toc {
	display: table;
	padding: 7px;
}

.wikitable {
	background-color: #f8f9fa;
	color: #202122;
	margin: 1em 0;
	border: 1px solid #a2a9b1;
	border-collapse: collapse;
}
	img {
		border: 0;
		vertical-align: middle
	}

	hr {
		height: 1px;
		background-color: #a2a9b1;
		border: 0;
		margin: 0.2em 0
	}

	h1,h2,h3,h4,h5,h6 {
		color: #000;
		margin: 0;
		padding-top: 0.5em;
		padding-bottom: 0.17em;
		overflow: hidden
	}

	h1,h2 {
		margin-bottom: 0.6em;
		border-bottom: 1px solid #a2a9b1
	}

	h3,h4,h5 {
		margin-bottom: 0.3em
	}

	h1 {
		font-size: 188%;
		font-weight: normal
	}

	h2 {
		font-size: 150%;
		font-weight: normal
	}

	h3 {
		font-size: 128%
	}

	h4 {
		font-size: 116%
	}

	h5 {
		font-size: 108%
	}

	h6 {
		font-size: 100%
	}

	p {
		margin: 0.4em 0 0.5em 0
	}

	p img {
		margin: 0
	}

	ul {
		margin: 0.3em 0 0 1.6em;
		padding: 0
	}

	ol {
		margin: 0.3em 0 0 3.2em;
		padding: 0;
		list-style-image: none
	}

	li {
		margin-bottom: 0.1em
	}

	dt {
		font-weight: bold;
		margin-bottom: 0.1em
	}

	dl {
		margin-top: 0.2em;
		margin-bottom: 0.5em
	}

	dd {
		margin-left: 1.6em;
		margin-bottom: 0.1em
	}

.gendoc_function {
	color: #800;
	font-weight: 700;
}

</style>
)__";

var css_cpp_style =

R"__(<style>
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }






/* Highlight and Error */
:root {
  --highlight-bg-color: #ffffcc;
  --error-border-color: #FF0000;
  --highlight-font-weight: normal;
  --highlight-font-style: normal;
  --master-bold: bold; /*var(--master-bold)*/
  --master-italic: normal; /*var(--master-italic)*/
}
.hll { background-color: var(--highlight-bg-color); font-weight: var(--highlight-font-weight); font-style: var(--highlight-font-style); }
.err { border: 1px solid var(--error-border-color); font-weight: var(--highlight-font-weight); font-style: var(--highlight-font-style); } /* Error */

/* Comments */
:root {
  --comment-main-color: #3D7B7B;
  --comment-preproc-color: #9C6500;
  --comment-font-weight: var(--master-bold);
  --comment-font-style: var(--master-italic);
}
.c   { color: var(--comment-main-color); font-weight: var(--comment-font-weight); font-style: var(--comment-font-style); } /* Comment */
.ch  { color: var(--comment-main-color); font-weight: var(--comment-font-weight); font-style: var(--comment-font-style); } /* Comment.Hashbang */
.cm  { color: var(--comment-main-color); font-weight: var(--comment-font-weight); font-style: var(--comment-font-style); } /* Comment.Multiline */
.cp  { color: var(--comment-preproc-color); font-weight: var(--comment-font-weight); font-style: var(--comment-font-style); } /* Comment.Preproc */
.cpf { color: var(--comment-main-color); font-weight: var(--comment-font-weight); font-style: var(--comment-font-style); } /* Comment.PreprocFile */
.c1  { color: var(--comment-main-color); font-weight: var(--comment-font-weight); font-style: var(--comment-font-style); } /* Comment.Single */
.cs  { color: var(--comment-main-color); font-weight: var(--comment-font-weight); font-style: var(--comment-font-style); } /* Comment.Special */

/* Keywords */
:root {
  --keyword-main-color: #008000; /*green*/
  --keyword-type-color: #B00040; /*reddish*/
  --keyword-flow-color: #FF5722; /*orange*/
  --keyword-cnst-color: #FF0000; /*red*/
  --keyword-font-weight: var(--master-bold);
  --keyword-font-style: normal;
}
.k   { color: var(--keyword-main-color); font-weight: var(--keyword-font-weight); font-style: var(--keyword-font-style); } /* Keyword */
.kc  { color: var(--keyword-cnst-color); font-weight: var(--keyword-font-weight); font-style: var(--keyword-font-style); } /* Keyword.Constant */

/* used in exodus_cpp.py EXTRA_DECLARATIONS 'func', 'subr', 'function', 'subroutine' */
.kd  { color: var(--keyword-main-color); font-weight: var(--keyword-font-weight); font-style: var(--keyword-font-style); } /*Keyword.Declaration*/

.kn  { color: var(--keyword-main-color); font-weight: var(--keyword-font-weight); font-style: var(--keyword-font-style); } /* Keyword.Namespace */
.kp  { color: var(--keyword-main-color); font-weight: var(--keyword-font-weight); font-style: var(--keyword-font-style); } /* Keyword.Pseudo */

/* used in exodus_cpp.py EXTRA_FLOW_CONTROL 'stop', 'abort', 'abortall', 'call', 'gosub' */
.kr  { color: var(--keyword-flow-color); font-weight: var(--keyword-font-weight); font-style: var(--keyword-font-style); } /* Keyword.Reserved */

/* used in exodus_cpp.py EXTRA_TYPES 'dim', 'var', '_var', 'rex', '_rex', 'let', 'in', 'out', 'io', 'qqqqqqq'
								        'programexit', 'programinit',
								        'libraryinit', 'libraryexit',
								         'commoninit', 'commonexit',
								        'dictinit', 'dictexit'*/
.kt  { color: var(--keyword-type-color); font-weight: var(--keyword-font-weight); font-style: var(--keyword-font-style); } /* Keyword.Type */

/* Operators */
:root {
  --operator-main-color: #666666;
  --operator-word-color: #AA22FF;
  --operator-font-weight: var(--master-bold);
  --operator-font-style: normal;
}
.o   { color: var(--operator-main-color); font-weight: var(--operator-font-weight); font-style: var(--operator-font-style); } /* Operator */
.ow  { color: var(--operator-word-color); font-weight: var(--operator-font-weight); font-style: var(--operator-font-style); } /* Operator.Word */

/* Literals */
:root {
  --literal-color: #0000FF;                     /* Unified color (using original string main color as default) */
  --literal-font-weight: var(--master-bold);    /* Unified weight (defaulting to normal) */
  --literal-font-style: var(--master-italic);   /* Unified style (defaulting to normal) */
}
.m   { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.Number */
.mb  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.Number.Bin */
.mf  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.Number.Float */
.mh  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.Number.Hex */
.mi  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.Number.Integer */
.mo  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.Number.Oct */
.il  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.Number.Integer.Long */
.nb  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Name.Builtin (Really Literal.Number.Boolean?) */
.s   { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.String */
.sa  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.String.Affix */
.sb  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.String.Backtick */
.sc  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.String.Char */
.dl  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.String.Delimiter */
.sd  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.String.Doc */
.s2  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.String.Double */
.se  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.String.Escape */
.sh  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.String.Heredoc */
.si  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.String.Interpol */
.sx  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.String.Other */
.sr  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.String.Regex */
.s1  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.String.Single */
.ss  { color: var(--literal-color); font-weight: var(--literal-font-weight); font-style: var(--literal-font-style); } /* Literal.String.Symbol */

/* Unidentified Names - Perhaps the most important part of a program strangely unhighlighted by pygmentize default style.*/
:root {
  --unidentified-color: #000000;
  --unidentified-font-weight: var(--master-bold);
  --unidentified-font-style: normal;
}
.n   { color: var(--unidentified-color); font-weight: var(--unidentified-font-weight); font-style: var(--unidentified-font-style); } /* Unidentified */

/* Names */
:root {
  --name-attribute-color: #687822;
  --name-builtin-color: #008000;
  --name-class-color: #B00040; /* same as .kt keyword type color to be like types*/
  --name-constant-color: #880000;
  --name-decorator-color: #AA22FF;
  --name-entity-color: #717171;
  --name-exception-color: #CB3F38;
  --name-label-color: #767600;
  --name-tag-color: #008000;
  --name-variable-color: #19177C;
  --name-font-weight: var(--master-bold);
  --name-font-style: normal;
}
.na  { color: var(--name-attribute-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Attribute */
.nc  { color: var(--name-class-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Class */
.no  { color: var(--name-constant-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Constant */
.nd  { color: var(--name-decorator-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Decorator */
.ni  { color: var(--name-entity-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Entity */
.ne  { color: var(--name-exception-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Exception */

/* used in exodus_cpp.py EXTRAC_FUNCTIONS massive list*/
.nf  { color: var(--name-class-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Function */

.nl  { color: var(--name-label-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Label */
.nn  { color: var(--name-class-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Namespace */
.nt  { color: var(--name-tag-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Tag */
.nv  { color: var(--name-variable-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Variable */
.bp  { color: var(--name-builtin-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Builtin.Pseudo */
.fm  { color: var(--name-class-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Function.Magic */
.vc  { color: var(--name-variable-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Variable.Class */
.vg  { color: var(--name-variable-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Variable.Global */
.vi  { color: var(--name-variable-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Variable.Instance */
.vm  { color: var(--name-variable-color); font-weight: var(--name-font-weight); font-style: var(--name-font-style); } /* Name.Variable.Magic */

/* Generic */
:root {
  --generic-deleted-color: #A00000;
  --generic-error-color: #E40000;
  --generic-heading-color: #000080;
  --generic-inserted-color: #008400;
  --generic-output-color: #717171;
  --generic-subheading-color: #800080;
  --generic-traceback-color: #0044DD;
  --generic-font-weight: var(--master-bold);
  --generic-font-style: italic;
}
.gd  { color: var(--generic-deleted-color); font-weight: var(--generic-font-weight); font-style: var(--generic-font-style); } /* Generic.Deleted */
.ge  { font-weight: var(--generic-font-weight); font-style: var(--generic-font-style); } /* Generic.Emph */
.ges { font-weight: var(--generic-font-weight); font-style: var(--generic-font-style); } /* Generic.EmphStrong */
.gr  { color: var(--generic-error-color); font-weight: var(--generic-font-weight); font-style: var(--generic-font-style); } /* Generic.Error */
.gh  { color: var(--generic-heading-color); font-weight: var(--generic-font-weight); font-style: var(--generic-font-style); } /* Generic.Heading */
.gi  { color: var(--generic-inserted-color); font-weight: var(--generic-font-weight); font-style: var(--generic-font-style); } /* Generic.Inserted */
.go  { color: var(--generic-output-color); font-weight: var(--generic-font-weight); font-style: var(--generic-font-style); } /* Generic.Output */
.gp  { color: var(--generic-heading-color); font-weight: var(--generic-font-weight); font-style: var(--generic-font-style); } /* Generic.Prompt */
.gs  { font-weight: var(--generic-font-weight); font-style: var(--generic-font-style); } /* Generic.Strong */
.gu  { color: var(--generic-subheading-color); font-weight: var(--generic-font-weight); font-style: var(--generic-font-style); } /* Generic.Subheading */
.gt  { color: var(--generic-traceback-color); font-weight: var(--generic-font-weight); font-style: var(--generic-font-style); } /* Generic.Traceback */

/* Whitespace */
:root {
  --whitespace-color: #bbbbbb;
  --text-font-weight: normal;
  --text-font-style: normal;
}
.w   { color: var(--whitespace-color); font-weight: var(--text-font-weight); font-style: var(--text-font-style); } /* Text.Whitespace */










</style>
)__";

let style_switcher_head = R"__(
    <style>
		#style-select {
            position: fixed; /* Keeps it in place while scrolling */
            top: 10px;      /* Distance from the top */
            right: 10px;    /* Distance from the right */
            z-index: 1000;  /* Ensures it stays on top of other content */
		}

        .highlight { 
            padding: 15px; 
            border: 1px solid #ddd; 
            border-radius: 4px; 
        }
        .highlight pre {
            margin: 0;
        }
        body.light {
            background: #f8f8f8;
            color: #333;
        }
        body.dark {
            background: #1e1e1e;
            color: #ddd;
        }
        /* Default light and dark fallbacks */
        .highlight.light {
            background: #ffffff;
            border-color: #ccc;
        }
        .highlight.dark {
            background: #2d2d2d;
            border-color: #555;
        }
    </style>
    <link id="pygments-style" rel="stylesheet" href="">
)__";

let style_switcher_dropdown = R"__(
	<select id="style-select">
        <option value="default" data-theme="light">default</option>
        <option value="autumn" data-theme="light">autumn</option>
        <option value="borland" data-theme="light">borland</option>
        <option value="bw" data-theme="light">bw</option>
        <option value="colorful" data-theme="light">colorful</option>
        <option value="emacs" data-theme="light">emacs</option>
        <option value="friendly" data-theme="light">friendly</option>
        <option value="manni" data-theme="light">manni</option>
        <option value="murphy" data-theme="light">murphy</option>
        <option value="pastie" data-theme="light">pastie</option>
        <option value="perldoc" data-theme="light">perldoc</option>
        <option value="solarized-light" data-theme="light">solarized-light</option>
        <option value="tango" data-theme="light">tango</option>
        <option value="vs" data-theme="light">vs</option>

        <option value="fruity" data-theme="dark">fruity</option>
        <option value="monokai" data-theme="dark">monokai</option>
        <option value="native" data-theme="dark">native</option>
        <option value="solarized-dark" data-theme="dark">solarized-dark</option>
        <option value="vim" data-theme="dark">vim</option>
    </select>
)__";

let style_switcher_foot = R"__(
	<script>
        function setCookie(name, value, days) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            const expires = "expires=" + date.toUTCString();
            document.cookie = name + "=" + value + ";" + expires + ";path=/";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for(let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) == ' ') c = c.substring(1);
                if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length);
            }
            return null;
        }

        function loadStyle(styleName, theme) {
            const styleLink = document.getElementById('pygments-style');
            styleLink.href = `https://cdn.jsdelivr.net/gh/richleland/pygments-css@master/${styleName}.css`;
            document.body.className = theme;
            document.querySelector('.highlight').className = `highlight ${theme} ${styleName}`;
            setCookie('selectedStyle', styleName, 365);
            setCookie('selectedTheme', theme, 365);
        }

        const select = document.getElementById('style-select');
        const savedStyle = getCookie('selectedStyle');
        const savedTheme = getCookie('selectedTheme');

        if (savedStyle && savedTheme) {
            select.value = savedStyle;
            loadStyle(savedStyle, savedTheme);
        } else {
            loadStyle('default', 'light');
        }

        select.addEventListener('change', function(e) {
            const selectedOption = e.target.selectedOptions[0];
            const theme = selectedOption.getAttribute('data-theme');
            loadStyle(e.target.value, theme);
        });
    </script>
)__";


programexit()
