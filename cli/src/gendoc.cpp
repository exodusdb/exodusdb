#include <exodus/program.h>
programinit()

// Note: man pages are generated with a Unicode FOUR-PER-EM SPACE for fixed layout.
// man pages comments.replacer("\u22c5", "\u2005"); // "⋅" Unicode operator point operator -> " " FOUR-PER-EM SPACE
// comments.replacer("␣", "\u2005");
// Source code comments contain "\u22c5+"; "⋅" Unicode operator point operator and "␣" space indicater
// man_page_white_space_code_point = "\u2005"; // " " FOUR-PER-EM SPACE

let syntax =
R"__(gendoc osfilename ... [{OPTIONS}]
Option: w = wiki source format
Option: m = man page
otherwise html
)__";

bool wiki = OPTIONS.contains("w");
bool man = OPTIONS.contains("m");
bool html = not (wiki or man);

var tableno = 0;

// Default to current dir for example code output dir
var codefile_dir = "";

function main() {

	if (not COMMAND.count(FM)) {
		abort(syntax);
	}

	var docfilename = ostempfilename();

	for (let osfilename : COMMAND.remove(1)) {

		// Skip and capture output dir for examples .cpp
		if (osdir(osfilename)) {
			codefile_dir = osfilename;
			continue;
		}

		var src;
		if (not src.osread(osfilename)) {
			errputl(lasterror());
			continue;
		}
		src.converter("\n\r", _FM);

		let osfilename0 = osfilename.field2(OSSLASH, -1);
		var fileheader = "Generated by cli/gendoc from " ^ osfilename0;


		// Start a temporary file for the example code
		//////////////////////////////////////////////

		let temp_code_filename = ostempfilename();
		std::ofstream codefile(temp_code_filename.toString());

		// Start the code examples file
		codefile << "/" "/" << fileheader << "\n" << std::endl;

		let progheader =
R"__(#include <cassert>
#include <exodus/program.h>
programinit()

function main() {

	// Clean up before starting
	gosub cleanup();
)__";
		codefile << progheader;

		//

		var contents = "";

		var new_objs = "";
		var defined_objs = "";
		var all_cleanups = "";

		// Start a file for the documentation
		/////////////////////////////////////

		std::ofstream docfile(docfilename.toString());

		// Lines like "///... some text:"
		rex doc_rex(R"__(^(/{3,})\s+(.*):$)__");

		//rex func_rex(R"__(^(var|io|bool|void))__");

		auto skipping = true;
		auto in_table = false;
		auto deprecated = false;

		var lastcomment = "";

		var default_objname = "var";

		for (var srcline : src) {

			// tabs become spaces
//			srcline.replacer("\t", " ");
			srcline.replacer("\t", "    ");
//			srcline.trimmer();
			srcline.trimmerboth();

			// "[[Deprecated" flags that the following function line should not be documented
			if (srcline.starts("[[deprecated")) {
				deprecated = true;
				continue;
			}

			////////////////////////////
			// Start a section and table
			////////////////////////////

			// Match lines starting // and ending ":"
			var table_title = srcline.match(doc_rex);
			if (table_title) {


				skipping = false;

				// Close any prior table
				if (in_table) {
					if (man) {}
					else if (wiki) {
						docfile << "|}" << std::endl;
					} else {
						docfile << "</table>" << std::endl;
					}
					in_table = false;
				}

				// Empty table title results in closing table and skipping following functions
				// until another table title is found.
				if (not trim(table_title.f(1, 3)))
					continue;

				in_table = true;

				let short_title = table_title.f(1, 3).tcase().replace("Mv", "MV").replace("Os", "OS");

				let level = table_title.f(1, 2).len();
				if (man) {

					// Section header
					docfile << ".SH " << ++tableno << ". " << short_title.ucase() << std::endl;
					docfile << ".SH" << std::endl;
					docfile << std::endl;
				}
				else if (wiki) {

					let wiki_title = str("=", level);
					docfile << wiki_title << " " << short_title << " " << wiki_title << std::endl;
					docfile << "" << std::endl;
					docfile << "{|class=\"wikitable\"" << std::endl;
					docfile << "!Usage!!Function!!Description" << std::endl;

				} else {

					var table_id = short_title.convert(" ", "_");

					contents ^= "<li><a href=#" ^ table_id ^ ">" ^ short_title ^ "</a></li>\n";

					docfile << "<h" << level << " id=" << table_id << ">" << short_title << "</h" << level << ">" << std::endl;
					docfile << "" << std::endl;
					docfile << "<table class=wikitable>" << std::endl;
					docfile << "<tr> <th>Usage</th> <th>Function</th> <th>Description</th> </tr>" << std::endl;
				}
				continue;
			}

			// private declaration turns off documentation
			if (srcline == "private:")
				skipping = true;
			else if(srcline == "public:")
				skipping = false;
			if (skipping or not in_table)
				continue;

			// Not documenting ND or not since mostly ND
			auto no_discard = srcline.starts("ND ");
			if (no_discard)
				srcline.cutter(3);

			///////////////////////////////////////
			// Find a function declaration (tricky)
			///////////////////////////////////////

			// Only interested in certain function declarations and comments starting exactly //
			var prefix = srcline.field(" ", 1);

			// Suppress lines that are not comments or function declarations
			if (not prefix.starts("/") and not srcline.match(R"__(^[\sa-zA-Z0-9_:]+\()__"))
				prefix = "";

			// Include lines starting var
			// Warning: lines like "var xxx = 123;" are NOT function declarations
			if (prefix == "var")
				prefix ^= "=";

			else if (prefix == "std::string") prefix = "var="; // i/oconv private

			else if (prefix == "RETVAR") prefix = "="; // from var_base

			// const var&
			else if (prefix == "CVR")  prefix = "expr";// only for output/logput/errput etc.
			else if (prefix == "CBR") prefix = "expr"; // from var_base

			// var& (various types)
			else if (prefix == "io")   prefix = "expr";// none should return this
			else if (prefix == "IO")   prefix = "cmd"; // ditto. (now IO=void for mutator -er)
			else if (prefix == "VARREF") prefix = "VARREF"; // exo::var& from var_base
			else if (prefix == "out")  prefix = "expr";// only input and getlocale

			// bool
			else if (prefix == "bool") prefix = "if";  // many return true/false

			// void
			else if (prefix == "void") prefix = "cmd"; // many return nothing

			else {

				if (prefix == "/" "/") {

					// Collect possible function preamble comments
					// Exactly // (two slashes, not more)
					lastcomment ^= srcline.substr(4) ^ FM_;

				} else {

					// Throw away non-function preamble comments
					////////////////////////////////////////////

					// From thrown away comments, get the default obj name for all following functions
					// except where overridden in specific function comments.
					// Only match "obj is xxx|yyy|zzz()" at the start of the first line of comment.
					let new_default_objname = lastcomment.match(R"__(^obj is ([a-zA-Z_][a-zA-Z0-9_()|]+))__").f(1, 2);
					if (new_default_objname) {
						new_objs ^= new_default_objname ^ FM;
						default_objname = new_default_objname;
					}

					// Throw away collected comments if not contiguous
					lastcomment = "";
				}
				continue;
			}

			// Skip deprecated functions
			if (deprecated) {
				deprecated = false;
				continue;
			}

			///////////////////////////////
			// Found a function declaration
			///////////////////////////////

			srcline = srcline.field(" ", 2, 9999);
//			var comments = srcline.field("{", 1).field(";", 2, 9999).trimmerfirst("/ ");
//			var comments = srcline.field("/" "/", 2, 99999).trimfirst();
			var comments = srcline.field("/" "/", 2, 99999);
			srcline = srcline.field("/" "/", 1).field("{", 1).trimlast();
			let funcname = srcline.field("(", 1);

			// If no end of line comment use the lead in comments before the function declaration
			if (not comments and lastcomment) {
				lastcomment.popper();
				comments = std::move(lastcomment);
			}

			// Extract and remove any "obj is xxx|yyy|zzz()" lines in comments for specific functions
			// comments is FM separated at this point (dont forget that \s matches FM chars)
			let objmatch = comments.match(R"__([ \t]*obj is ([a-zA-Z_][a-zA-Z0-9_()|]+)[^\n)__" _FM "]*");
			if (objmatch) {
				comments.replacer(FM ^ objmatch.f(1, 1), "");
				new_objs ^= objmatch.f(1, 2).convert("|()", FM) ^ FM_;
			}
			let objname = objmatch.f(1,2);

			/////////////////////
			// Handle code blocks
			/////////////////////

			// Format backticked source code fragments
			if (comments.contains("`")) {
				// FMs inside backticks (c++ code) become simple "\n"
				bool backtick = false;
				for (int charn : range(1, comments.len())) {
					char charx = comments.substr(charn, 1).toChar();
					if (charx == '`') {
						backtick = not backtick;
						continue;
					}
					if (backtick && charx == FM_) {
						comments.paster(charn, 1, "\n");
					}
				}

				// Prevent extra </p> before or after `
				static rex rex1 {R"__(`\s*)__" _FM};
				static rex rex2 {_FM R"__(\s*`)__"};
				comments.replacer(rex1, "`\n");
				comments.replacer(rex2, "\n`");

				// Add a backtick if an odd numbers is present indicating forgot to close c++ code
				if (comments.count("`") % 2) {
					if (comments.count("`") > 1 ) {
						abort("Error: Odd number of backticks in " ^ funcname.quote());
					}
					logputl("Warning: Missing closing backtick in " ^ funcname.quote());
					comments ^= "`";
				}

				// regex between pairs of backticks
				static rex backquoted {R"__(`([^`]*)`)__"};

				var codematches = comments.match(backquoted);

				// Replace space formatting with single space
				codematches.replacer("\u22c5+"_rex, " "); // "⋅" Unicode operator point operator -> space

				for (var codematch : codematches) {
					codematch = codematch.f(1, 2);
					// ... becomes proper code
					let aborting = " abort(\"" ^ funcname ^ ": \" ^ lasterror());";
					codematch.replacer(") ... ok", ") {/" "*ok*" "/} else " ^ aborting);
					codematch.replacer(") ... true", ") {/" "*true*" "/} else " ^ aborting);
					codematch.replacer(" ...", aborting);
					codematch.replacer("\n", "\n\t\t");
					codematch.replacer("\n\t\t\n", "\n");

					// Remove "// Cleanup" lines to be put in heading of
					static rex cleanup_pattern {R"__(^[^\n]*// Cleanup[^\n]*)__"};
					var cleanups = codematch.match(cleanup_pattern);
					if (cleanups) {
						for (let cleanup : cleanups) {
							all_cleanups ^= cleanup ^ "\n";
						}
						codematch.replacer(cleanup_pattern, "");
					}

					// Convert some comments to assertions
					// USE ␣ to indicate spaces. They will be converted to spaces in any assert.
					// Warning: Doesnt handle double quotes inside double quote)?

					// IMPLICT ASSERTS
					// e.g. '   let|var v1 = xxxxxxx ; // "X" // zzzz' where zzzz can be a literal number 9999, "xxx", true or false
					//      '1112222222 3344444444444     55556666666'
					static rex rex3 = rex(R"__(^(\s*)(let|var)\s+([a-z0-9A-Z_]+)([^\n]*?);[ \t]*//\s+(true|false|["0-9.-][^\n]*?)([ \t]//[^\n]*?)?$)__", "m");
					codematch.replacer(rex3, "$1$2 $3$4; assert\\($3 == $5\\);$6");

					// ARROW ASSERTS
					//        if (not field.readf(file, key, fieldno)) abort("readf" ": " ^ lasterror()); // field -> "G"
					// e.g. '  // v1 -> "f1^X^f3"_var // v2 -> "a b c"'
					//        1   22    33333333333333
					static rex rex5 = rex(R"__(([^/])//\s*([a-zA-Z0-9_.()]+)\s*->\s*([^/\n]*))__");
					codematch.replacer(rex5, "$1 assert\\($2 == $3\\);");
					// Why does it need multiple replaces? (possibly because group 3 overlaps with group 1)
					codematch.replacer(rex5, "$1 assert\\($2 == $3\\); ");
					codematch.replacer(rex5, "$1 assert\\($2 == $3\\); ");
					codematch.replacer(rex5, "$1 assert\\($2 == $3\\); ");
					codematch.replacer(rex5, "$1 assert\\($2 == $3\\); ");

//					// MUTATOR ASSERTS
//					// e.g. 'v1.xxx xxx xxx // zzzz // xxxxxx'
//					// e.g. 'v1.ucaser(); // "ABC"'
					static rex rex4 = rex(R"__(^(\s*)([a-z0-9A-Z_]+)\.([^/\n]*)//\s+([^/\n]*)([^\n]*))__");
					codematch.replacer(rex4, "$1$2.$3;assert\\($2 == $4\\);$5");

					// Replace hacked spaces ␣ with real spaces " "
					codematch.textconverter("␣", " ");

					// Wrap in {}
					codematch.prefixer("\n\t{\n\t\t");
					codematch ^= "\n\t}\n";

					// Lead with function name
					codematch.prefixer("\n\tprintl(" ^ srcline.quote() ^ ");");

					// Global definitions;
					for (var objname : new_objs) {
						objname.converter("()", "");
						if (not objname or objname == "var")
							continue;
						if (not locate(objname, defined_objs)) {
							codematch.prefixer("\n\tvar " ^ objname ^ ";\n");
							defined_objs ^= objname ^ VM;
						}
					}
					new_objs = "";

					// Move rhs asserts onto separate lines
					codematch.replacer(rex(R"__(;\s*assert([^\n;]*))__"), ";\n\t\tassert\\1\n");

					// Tidy up
					codematch.replacer(rex(R"__(\n;)__"), ";\n");
					codematch.replacer(rex(R"__(\n(\n[\t ]*assert))__"), "\\1");
					codematch.replacer(rex(R"__([\t ]*\n)__"), "\n");

					codefile << codematch;
				}

				// tag backticked code as c++
				if (man) {

					// Man page codes
					// .RS Right shift
					// .nf No format
					// .RE REturn (left shift)
					// .fi formatting
					// Prefix by a section title "Example:"
					comments.replacer(backquoted, "\nExample:\n.RS\n.nf\n $1\n.fi\n.RE\n");
				}
				else if (wiki)
					comments.replacer(backquoted, "<syntaxhighlight lang=\"c++\">\n $1</syntaxhighlight>");
				else
					// Javascript instead of cpp because it gives better highlighting for exodus c++. See above too.
					// (All function calls are highlighted)
					comments.replacer(backquoted, "\n<pre><code class='hljs-ncdecl language-javascript'>$1</code></pre>\n");

				// Ordinary spaces for aligning code in html and wiki
				if (not man)
					comments.replacer("\u22c5", " "); // "⋅" Unicode operator point operator -> " "
			}

			////////////////////////////////
			// Output function documentation
			////////////////////////////////

			if (man) {
				// hide dot/space formatting
				comments.replacer("\u22c5", "\u2005"); // "⋅" Unicode operator point operator -> " " FOUR-PER-EM SPACE
				comments.replacer("␣", "\u2005");

				comments.replacer(_FM, "\n\n");
			} else if (wiki) {
				comments.replacer(_FM, "\n\n");
			} else {
				comments.replacer(_FM, "</p>\n");
			}

			var line2 = srcline.field(";", 1);

			// "ARGS&... appendable" -> "appendable, ..."
			line2.replacer(R"__(\b[a-zA-Z][a-zA-Z0-9]*\s*&{1,2}\s*\.\.\.\s*\b([a-zA-Z][a-zA-Z0-9]*))__"_rex, "$1, ...");

			line2.replacer("\\bstd::size_t\\b", "");
			line2.replacer("\\bconst&&\\b", "");
			line2.replacer("\\bconst&\\b", "");
			line2.replacer("\\bconst\\b"_rex, "");
			line2.replacer("\\bin\\b"_rex, "");
			line2.replacer("\\bSV\\b"_rex, "");
			line2.replacer("\\bint& "_rex, "out ");
			line2.replacer("\\bint\\b"_rex, "");
			line2.replacer("\\bchar\\*"_rex, "");
			line2.replacer("\\bbool "_rex, "");
			line2.replacer("\\brex& "_rex, "");
			line2.replacer("\\bCVR "_rex, "");
			line2.replacer("\\bCBR "_rex, "");
			line2.replacer("\\bVARREF "_rex, "io");
			line2.replacer("= _", "= ");
			line2.trimmer();
			line2.replacer("( ", "(");
			line2.replacer(" )", ")");

			if (line2.ends("&&"))
				continue;

			if (line2.ends("&")) {
				line2.popper();
				line2.trimmerlast();
			}

			if (line2.ends("REF")) {
				line2.cutter(-3);
				line2.trimmerlast();
			}

			// bold the function name
			if (man) {}
			else if (wiki) {
				line2.prefixer("<em>");
				line2.paster(line2.index("("), "</em>");
			} else {
				line2.prefixer("<span class='gendoc_function'>");
				line2.paster(line2.index("("), "</span>");
			}

			// i/oconv_MD(const char* conversion) -> i/oconv("MD")
			let func_decl0 = line2.replace(R"__(([io])conv_([A-Z]+)\([a-zA-Z0-0_*]*\))__"_rex, "$1conv\\(\"$2\"\\)");

			let func_decl = (objname ?: default_objname) ^ "." ^ func_decl0;

			if (man) {

				var func_decl2 = func_decl;
				if (prefix == "if")
					func_decl2 = "if (" ^ func_decl ^ ") ...";
				else if (prefix == "var=")
					func_decl2 = "var v1 = " ^ func_decl ^ ";";

				// Subsection header
				docfile << ".SS" << std::endl;
				// Put on a separate line to avoid suppression of double quote chars
				docfile << func_decl2 << std::endl;

//				docfile << ".sp" << std::endl; // ignored
				// Hack to defeat man's stubborn insistence on suppressing blank lines between section title and section text
				docfile << ".nf" << std::endl;
//				docfile << " " << std::endl; // ignored
//				docfile << ".sp" << std::endl; // ignored
//				docfile << "\u000A" << std::endl; // ignored
//				docfile << "\u2003" << std::endl; //U+2003 EM SPACE
				docfile << "\u2005" << std::endl; //U+2005 Four-Per-Em Space
				docfile << ".fi" << std::endl;

				docfile << comments << std::endl;
				docfile << "" << std::endl;
			}
			else if (wiki) {
				docfile << "|-" << std::endl;
				docfile << "|" << prefix << "||" << func_decl << "||" << comments << std::endl;
			} else {
				// Using javascript see below too
				docfile << "<tr><td>" << prefix << "</td><td>" << func_decl <<  "</td><td>" << comments << "</td></tr>" << std::endl;
			}

// format() slows compilation a lot for one off compilations (2.8/0.73 secs i.e x4)
// so maybe wait for a modules version of fmt library
//			println("|" "{}" "||" "<em>" "{}" "</em>" "." "{}" "||" "{}", prefix, objname, line2, comments);

		} // srcline

		////////////
		// File exit
		////////////

		var doc_text;
		if (not osread(doc_text from docfilename))
			abort(lasterror());

		if (not osremove(docfilename))
			loglasterror();

		// Escape back slashes for man pages
		if (man) {
			doc_text.replacer("&bsol;", "\\");
			doc_text.replacer("\\", "\\" "\\");

//			comments.replacer("Returns: ", "/fbReturns:/fr ");
//			doc_text.replacer("^([a-zA-Z0-9_.]+): "_rex, R"__(\\fI$1:\\fR )__");
			doc_text.replacer(R"__(^([a-zA-Z0-9_.]+):(\s+))__"_rex, R"__(\\fB$1:\\fR$2)__");

			// Man page codes
			// .RS Right shift
			// .nf No format
			// .RE REturn (left shift)
			// .fi formatting
			doc_text.replacer(R"__(^<pre>)__"_rex, R"__(.nf)__");
			doc_text.replacer(R"__(^</pre>)__"_rex, R"__(.fi)__");

		} else {
//			comments.replacer("Returns:", "<em>Returns:</em>");
			doc_text.replacer(R"__(^([a-zA-Z0-9_.]+):(\s+))__"_rex, R"__(<em>$1:</em>$2)__");
		}

		// Close prior table
		if (in_table) {
			if (man) {}
			else if (wiki)
				doc_text ^= "|}:" "\n";
			else
				doc_text ^= "</table>" "\n";
		}

		// Finalise the code output
		codefile << "\n\n\tgosub cleanup();" << std::endl;
		codefile << "\n\tprintl(\"Test passed.\");\n";
		codefile << "\n\treturn 0;\n}";
		codefile << "\nsubroutine cleanup() {" << std::endl;
		codefile << "\n\t" "/" "/Note that all '// Cleanup' lines in the original source code must use literals and not variables" << std::endl;
		codefile << "\t" "/" "/otherwise the generated code will VNA on cleanup" << std::endl;
		codefile << all_cleanups;
		codefile << "};";
		codefile << "\n\nprogramexit()" << std::endl;

		// Finally actually output the doc text
		///////////////////////////////////////

		// After outputing css and contents
		if (man) {}

		else if (wiki) {}

		else if (html) {

			// c++ syntax highlighter - highlight.js
			outputl(highlight_js);

			// css and script
			outputl(css);

			// Contents
			outputl("<div class=toc>");

			outputl("<h4>Contents:</h4>");

			outputl("<ol>");
			outputl(contents);
			outputl("</ol>");

			outputl("</div>");
		}

		// Header
		if (man) {
			outputl(".TH ", "var");
			outputl("");
			outputl(fileheader);
			outputl("");
		}
		else {
			outputl(fileheader);
			outputl("");
		}

		// Text
		outputl(doc_text);

		// Move the temp code examples cpp file into destination
		////////////////////////////////////////////////////////

		codefile.close();
		var newcode = "";
		if (not osread(newcode from temp_code_filename))
			abort(lasterror());

		let code_filename = codefile_dir ^ "/" ^ "testing_'orig'.cpp"_var.replace("'orig'", osfilename0);
		var oldcode = "";
		if (not osread(oldcode from code_filename)) {
			oldcode = "";
		}

		// Only update if the text has changed
		logput("gendoc: ", code_filename, " ");
		if (newcode != oldcode) {
			if (not oscopy(temp_code_filename to code_filename))
				abort(lasterror());
			logputl("Updated.");
		} else
			logputl("Not changed.");

	} // osfilename

	return 0;
}

////////////
// syntax_js
////////////
var highlight_js =R"__(

	<!-- highlight.js for c++ syntax highlighting -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
	<!-- done below <script>hljs.highlightAll();</script> -->

<style>

/* Change highlight.js comments from default grey to green */
.hljs-comment,
.hljs-quote {
	color: #008000; /* This is green, you can adjust the shade as per your preference */
	font-style: italic; /* Optional: You might want to keep comments italicized */
}

</style>

<script>
	//// Extend C++ language definition
	//const cppLanguage = hljs.getLanguage('cpp');
	//if (cppLanguage) {
	//	// Adding custom keywords
	//	cppLanguage.keywords = {
	//		...cppLanguage.keywords,
	//		keyword: cppLanguage.keywords.keyword + ' round chr textchr',
	//		// You can also add to other categories like 'literal', 'built_in', etc.
	//	};
	//	// Register the modified language
	//	hljs.registerLanguage('cpp', cppLanguage);
	//}

	// Initialize highlight.js
	document.addEventListener('DOMContentLoaded', (event) => {
	    hljs.highlightAll();
	});
</script>

)__";

//////
// css
//////

var css =R"__(
	<!-- bootstrap css. Is this necessary? -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

<style>

body {
	margin: 10px;
}

pre {
	margin: 0px;
	white-space: pre-wrap;
	word-wrap: break-word;
	white-space: -moz-pre-wrap;
	white-space: -pre-wrap;
	white-space: -o-pre-wrap;
	overflow-wrap: break-word;
	overflow-x: auto;
}

table, th, td {
	border: 1px solid #a2a9b1;
}

th {
	background-color: #eaecf0;
	font-weight: bold;
	text-align: left;
	padding: 8px;
}

td {
	padding: 0.2em 0.4em;
	vertical-align: top;
}

p {
  margin: 0.4em 0 0.5em 0;
}

.toc, .toccolours {
	border: 1px solid #a2a9b1;
	background-color: #f8f9fa;
	padding: 5px;
	font-size: 95%;
}
.toc {
	display: table;
	padding: 7px;
}

.wikitable {
	background-color: #f8f9fa;
	color: #202122;
	margin: 1em 0;
	border: 1px solid #a2a9b1;
	border-collapse: collapse;
}
    img {
        border: 0;
        vertical-align: middle
    }

    hr {
        height: 1px;
        background-color: #a2a9b1;
        border: 0;
        margin: 0.2em 0
    }

    h1,h2,h3,h4,h5,h6 {
        color: #000;
        margin: 0;
        padding-top: 0.5em;
        padding-bottom: 0.17em;
        overflow: hidden
    }

    h1,h2 {
        margin-bottom: 0.6em;
        border-bottom: 1px solid #a2a9b1
    }

    h3,h4,h5 {
        margin-bottom: 0.3em
    }

    h1 {
        font-size: 188%;
        font-weight: normal
    }

    h2 {
        font-size: 150%;
        font-weight: normal
    }

    h3 {
        font-size: 128%
    }

    h4 {
        font-size: 116%
    }

    h5 {
        font-size: 108%
    }

    h6 {
        font-size: 100%
    }

    p {
        margin: 0.4em 0 0.5em 0
    }

    p img {
        margin: 0
    }

    ul {
        margin: 0.3em 0 0 1.6em;
        padding: 0
    }

    ol {
        margin: 0.3em 0 0 3.2em;
        padding: 0;
        list-style-image: none
    }

    li {
        margin-bottom: 0.1em
    }

    dt {
        font-weight: bold;
        margin-bottom: 0.1em
    }

    dl {
        margin-top: 0.2em;
        margin-bottom: 0.5em
    }

    dd {
        margin-left: 1.6em;
        margin-bottom: 0.1em
    }

.gendoc_function {
    color: #800;
    font-weight: 700;
}

</style>

)__";

programexit()
