#include <exodus/program.h>
programinit()

function main() {
//	printl("gendoc says 'Hello World!'");

	for (let osfilename : COMMAND.remove(1)) {
//		printl(osfilename);
		var src;
		if (not src.osread(osfilename)) {
			errputl(lasterror());
			continue;
		}
		src.converter("\n\r", _FM);

		let osfilename0 = osfilename.field2(OSSLASH, -1);

		let codetxt_filename = replace("gendoc.{orig}.cpp", "{orig}", osfilename0);
		var codetxtfile;
		var codetxtptr = 0;
		var new_objs = "";
		var defined_objs = "";

		// Lines like "///... some text:"
		rex doc_rex(R"__(^(/{3,})\s+(.*):$)__");

		//rex func_rex(R"__(^(var|io|bool|void))__");

		auto skipping = true;
		auto in_table = false;
		auto deprecated = false;

		var lastcomment = "";

		var default_objname = "var";

		var fileheader = "Generated by cli/gendoc from " ^ osfilename0 ^ " " ^ date().oconv("D") ^ " " ^ time().oconv("MTS");

		for (var srcline : src) {

			// tabs become spaces
			srcline.replacer("\t", " ");
			srcline.trimmer();

			// "[[Deprecated" flags that the following function line should not be documented
			if (srcline.starts("[[deprecated")) {
				deprecated = true;
				continue;
			}

			// Match lines starting // and ending ":"
			var table_title = srcline.match(doc_rex);
			if (table_title) {
//TRACE(table_title)
//				printl(osfilename0, srcline);

				// Close prior table
				if (in_table) {
					printl("|}");
					in_table = false;
				}

				// Empty table title results in closing table and skipping following functions
				// until another table title is found.
				if (not trim(table_title.f(1, 3)))
					continue;

				in_table = true;

				let short_title = table_title.f(1, 3).tcase().replace("Mv", "MV").replace("Os", "OS");

				printl(fileheader);
				printl();
				fileheader = "";

				let wiki_title = str("=", table_title.f(1, 2).len());
				printl(wiki_title ^ " " ^ short_title ^ " " ^ wiki_title);
				printl();
				printl("{|class=\"wikitable\"");
				printl("!Usage!!Function!!Description");

				continue;
			}

			// Skip class private sections
			if (srcline == "private:")
				skipping = true;
			else if(srcline == "public:")
				skipping = false;
			if (skipping or not in_table)
				continue;

			// Not documenting ND or not since mostly ND
			auto no_discard = srcline.starts("ND ");
			if (no_discard)
				srcline.cutter(3);

			// Only interested in certain function declarations and comments starting exactly //
			var prefix = srcline.field(" ", 1);
			if (prefix == "var")       prefix ^= "=";
			else if (prefix == "CVR")  prefix = "expr";// only for output/logput/errput etc.
			else if (prefix == "io")   prefix = "expr";// none return this
			else if (prefix == "IO")   prefix = "cmd"; // now void for mutator -er
			else if (prefix == "out")  prefix = "expr";// only input and getlocale
			else if (prefix == "bool") prefix = "if";  // many return true/false
			else if (prefix == "void") prefix = "cmd"; // many return nothing
			else {

				if (prefix == "/" "/") {
					// Collect up comments starting // (two slashes, not more)
					lastcomment ^= srcline.substr(4) ^ FM_;
				} else {

					// From thrown away comments, get the default obj name for all following functions
					// except where overridden in specific function comments.
					// Only match "obj is xxx|yyy|zzz()" at the start of the first line of comment.
					let new_default_objname = lastcomment.match(R"__(^obj is ([a-zA-Z_][a-zA-Z0-9_()|]+))__").f(1, 2);
					if (new_default_objname) {
						new_objs ^= new_default_objname ^ FM;
						default_objname = new_default_objname;
					}

					// Throw away collected comments if not contiguous
					lastcomment = "";
				}
				continue;
			}

			// Skip deprecated functions
			if (deprecated) {
				deprecated = false;
				continue;
			}

			srcline = srcline.field(" ", 2, 9999);
//			var comments = srcline.field("{", 1).field(";", 2, 9999).trimmerfirst("/ ");
			var comments = srcline.field("/" "/", 2, 99999).trimfirst();
			srcline = srcline.field("/" "/", 1).field("{", 1).trimlast();
//			let funcname = srcline.field("(", 1);

			// If no end of line comment use the lead in comments before the function declaration
			if (not comments and lastcomment) {
				lastcomment.popper();
//				lastcomment.move(comments);
				comments = std::move(lastcomment);
//				comments = lastcomment;
//				lastcomment = "";
			}

			// Extract and remove any "obj is xxx|yyy|zzz()" lines in comments for specific functions
			// comments is FM separated at this point (dont forget that \s matches FM chars)
			let objmatch = comments.match(R"__([ \t]*obj is ([a-zA-Z_][a-zA-Z0-9_()|]+)[^\n)__" _FM "]*");
			if (objmatch) {
//				TRACE(objmatch.at(1).oconv("HEX"))
				comments.replacer(FM ^ objmatch.f(1, 1), "");
				new_objs ^= objmatch.f(1, 2).convert("|()", FM) ^ FM_;
			}
			let objname = objmatch.f(1,2);

			// Emphasise "Returns:"
			comments.replacer("Returns:", "<em>Returns:</em>");

			// Format backticked source code fragments
			if (comments.contains("`")) {

				// FMs inside backticks (c++ code) become simple "\n"
				bool backtick = false;
				for (int charn : range(1, comments.len())) {
					char charx = comments.substr(charn, 1).toChar();
					if (charx == '`') {
						backtick = not backtick;
						continue;
					}
					if (backtick && charx == FM_) {
						comments.paster(charn, 1, "\n");
					}
				}

				// Prevent extra <br> before or after `
				static rex rex1 {R"__(`\s*)__" _FM};
				static rex rex2 {_FM R"__(\s*`)__"};
				comments.replacer(rex1, "`\n");
				comments.replacer(rex2, "\n`");

				// Add a backtick if an odd numbers is present indicating forgot to close c++ code
				if (comments.count("`") % 2)
					comments ^= "`";

				// Wrap backticked code in <pre> </pre> tags
				static rex backquoted {R"__(`([^`]*)`)__"};

				var codematches = comments.match(backquoted);
				for (var codematch : codematches) {
					codematch = codematch.f(1, 2);

					codematch.replacer(" ...", " {};");

					codematch.replacer("\n", "\n\t\t");
					codematch.replacer("\n\t\t\n", "\n");

					// Wrap in {}
					codematch.prefixer("\n\t{\n\t\t");
					codematch ^= "\n\t}\n";
					codematch.prefixer("\n\t/" "/" ^ srcline);

					// Global definitions;
					for (var objname : new_objs) {
						objname.converter("()", "");
						if (not objname or objname == "var")
							continue;
						if (not locate(objname, defined_objs)) {
							codematch.prefixer("\n\tvar " ^ objname ^ ";\n");
							defined_objs ^= objname ^ VM;
						}
					}
					new_objs = "";

					// Start the code output file
					if (not codetxtptr) {
						if (not oswrite("" on codetxt_filename))
							abort(lasterror());
						if (not osopen(codetxt_filename to codetxtfile))
							abort(lasterror());

						let progheader = "#include <exodus/program.h>\nprograminit()\n\nfunction main() {\n";
						if (not osbwrite(progheader on codetxtfile, codetxtptr))
							abort(lasterror());
					}

					if (not osbwrite(codematch on codetxtfile, codetxtptr))
						abort(lasterror());
				}

				comments.replacer(backquoted, "<syntaxhighlight lang=\"c++\">\n$1</syntaxhighlight>");
			}

			comments.replacer(_FM, "<br>\n");

			var line2 = srcline.field(";", 1);
			line2.replacer("\\bstd::size_t\\b", "");
			line2.replacer("\\bconst&&\\b", "");
			line2.replacer("\\bconst&\\b", "");
			line2.replacer("\\bconst\\b"_rex, "");
			line2.replacer("\\bin\\b"_rex, "");
			line2.replacer("\\bSV\\b"_rex, "");
			line2.replacer("\\bint& "_rex, "out ");
			line2.replacer("\\bint\\b"_rex, "");
			line2.replacer("\\bchar\\*"_rex, "");
			line2.replacer("\\bbool "_rex, "");
			line2.replacer("\\brex& "_rex, "");
			line2.replacer("= _", "= ");
			line2.trimmer();
			line2.replacer("( ", "(");
			line2.replacer(" )", ")");

			if (line2.ends("&&"))
				continue;

			if (line2.ends("&")) {
				line2.popper();
				line2.trimmerlast();
			}

			if (line2.ends("REF")) {
				line2.cutter(-3);
				line2.trimmerlast();
			}

			line2.replacer("DEFAULT_SPACE", R"__(= "")__");
			line2.replacer("DEFAULT_EMPTY", R"__(= "")__");
			line2.replacer("DEFAULT_CSPACE", R"__(= ' ')__");

			printl("|-");

			// bold the function name
			line2.prefixer("<em>");
			line2.paster(line2.index("("), "</em>");

			line2 = "|" ^ prefix ^ "||" ^ (objname ?: default_objname) ^ "." ^ line2 ^ "||" ^ comments;
			printl(line2);
// format() slows compilation a lot for one off compilations (2.8/0.73 secs i.e x4)
// so maybe wait for a modules version of fmt library
//			println("|" "{}" "||" "<em>" "{}" "</em>" "." "{}" "||" "{}", prefix, objname, line2, comments);

		} // srcline

		// Close prior table
		if (in_table)
			printl("|}:");

		// Close the output source capture program
		if (codetxtptr) {
			let progfooter = "\n\n\treturn 0;\n}\n\nprogramexit()\n";
			if (not osbwrite(progfooter on codetxtfile, codetxtptr))
				abort(lasterror());
			osclose(codetxtfile);
		}

	} // osfilename

	return 0;
}

programexit()
