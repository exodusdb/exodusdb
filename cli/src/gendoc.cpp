#include <exodus/program.h>
programinit()

var code_filename;
var codefile;
var codeptr;

function main() {
//	printl("gendoc says 'Hello World!'");

	for (let osfilename : COMMAND.remove(1)) {
//		printl(osfilename);
		var src;
		if (not src.osread(osfilename)) {
			errputl(lasterror());
			continue;
		}
		src.converter("\n\r", _FM);

		let osfilename0 = osfilename.field2(OSSLASH, -1);

		code_filename = replace("gendoc.{orig}.cpp", "{orig}", osfilename0);
		codeptr = 0;

		var new_objs = "";
		var defined_objs = "";
		var all_cleanups = "";

		// Lines like "///... some text:"
		rex doc_rex(R"__(^(/{3,})\s+(.*):$)__");

		//rex func_rex(R"__(^(var|io|bool|void))__");

		auto skipping = true;
		auto in_table = false;
		auto deprecated = false;

		var lastcomment = "";

		var default_objname = "var";

		var fileheader = "Generated by cli/gendoc from " ^ osfilename0 ^ " " ^ date().oconv("D") ^ " " ^ time().oconv("MTS");

		for (var srcline : src) {

			// tabs become spaces
			srcline.replacer("\t", " ");
			srcline.trimmer();

			// "[[Deprecated" flags that the following function line should not be documented
			if (srcline.starts("[[deprecated")) {
				deprecated = true;
				continue;
			}

			// Match lines starting // and ending ":"
			var table_title = srcline.match(doc_rex);
			if (table_title) {
//TRACE(table_title)
//				printl(osfilename0, srcline);

				// Close prior table
				if (in_table) {
					printl("|}");
					in_table = false;
				}

				// Empty table title results in closing table and skipping following functions
				// until another table title is found.
				if (not trim(table_title.f(1, 3)))
					continue;

				in_table = true;

				let short_title = table_title.f(1, 3).tcase().replace("Mv", "MV").replace("Os", "OS");

				if (not codeptr) {
					printl(fileheader);
					printl();
				}

				let wiki_title = str("=", table_title.f(1, 2).len());
				printl(wiki_title ^ " " ^ short_title ^ " " ^ wiki_title);
				printl();
				printl("{|class=\"wikitable\"");
				printl("!Usage!!Function!!Description");

				continue;
			}

			// Skip class private sections
			if (srcline == "private:")
				skipping = true;
			else if(srcline == "public:")
				skipping = false;
			if (skipping or not in_table)
				continue;

			// Not documenting ND or not since mostly ND
			auto no_discard = srcline.starts("ND ");
			if (no_discard)
				srcline.cutter(3);

			// Only interested in certain function declarations and comments starting exactly //
			var prefix = srcline.field(" ", 1);
			if (prefix == "var")       prefix ^= "=";
			else if (prefix == "CVR")  prefix = "expr";// only for output/logput/errput etc.
			else if (prefix == "io")   prefix = "expr";// none return this
			else if (prefix == "IO")   prefix = "cmd"; // now void for mutator -er
			else if (prefix == "out")  prefix = "expr";// only input and getlocale
			else if (prefix == "bool") prefix = "if";  // many return true/false
			else if (prefix == "void") prefix = "cmd"; // many return nothing
			else {

				if (prefix == "/" "/") {
					// Collect up comments starting // (two slashes, not more)
					lastcomment ^= srcline.substr(4) ^ FM_;
				} else {

					// From thrown away comments, get the default obj name for all following functions
					// except where overridden in specific function comments.
					// Only match "obj is xxx|yyy|zzz()" at the start of the first line of comment.
					let new_default_objname = lastcomment.match(R"__(^obj is ([a-zA-Z_][a-zA-Z0-9_()|]+))__").f(1, 2);
					if (new_default_objname) {
						new_objs ^= new_default_objname ^ FM;
						default_objname = new_default_objname;
					}

					// Throw away collected comments if not contiguous
					lastcomment = "";
				}
				continue;
			}

			// Skip deprecated functions
			if (deprecated) {
				deprecated = false;
				continue;
			}

			srcline = srcline.field(" ", 2, 9999);
//			var comments = srcline.field("{", 1).field(";", 2, 9999).trimmerfirst("/ ");
			var comments = srcline.field("/" "/", 2, 99999).trimfirst();
			srcline = srcline.field("/" "/", 1).field("{", 1).trimlast();
			let funcname = srcline.field("(", 1);

			// If no end of line comment use the lead in comments before the function declaration
			if (not comments and lastcomment) {
				lastcomment.popper();
//				lastcomment.move(comments);
				comments = std::move(lastcomment);
//				comments = lastcomment;
//				lastcomment = "";
			}

			// Extract and remove any "obj is xxx|yyy|zzz()" lines in comments for specific functions
			// comments is FM separated at this point (dont forget that \s matches FM chars)
			let objmatch = comments.match(R"__([ \t]*obj is ([a-zA-Z_][a-zA-Z0-9_()|]+)[^\n)__" _FM "]*");
			if (objmatch) {
//				TRACE(objmatch.at(1).oconv("HEX"))
				comments.replacer(FM ^ objmatch.f(1, 1), "");
				new_objs ^= objmatch.f(1, 2).convert("|()", FM) ^ FM_;
			}
			let objname = objmatch.f(1,2);

			// Emphasise "Returns:"
			comments.replacer("Returns:", "<em>Returns:</em>");

			// Format backticked source code fragments
			if (comments.contains("`")) {

				// FMs inside backticks (c++ code) become simple "\n"
				bool backtick = false;
				for (int charn : range(1, comments.len())) {
					char charx = comments.substr(charn, 1).toChar();
					if (charx == '`') {
						backtick = not backtick;
						continue;
					}
					if (backtick && charx == FM_) {
						comments.paster(charn, 1, "\n");
					}
				}

				// Prevent extra <br> before or after `
				static rex rex1 {R"__(`\s*)__" _FM};
				static rex rex2 {_FM R"__(\s*`)__"};
				comments.replacer(rex1, "`\n");
				comments.replacer(rex2, "\n`");

				// Add a backtick if an odd numbers is present indicating forgot to close c++ code
				if (comments.count("`") % 2) {
					if (comments.count("`") > 1 ) {
						abort("Error: Odd number of backticks in " ^ funcname.quote());
					}
					logputl("Warning: Missing closing backtick in " ^ funcname.quote());
					comments ^= "`";
				}

				// Wrap backticked code in <pre> </pre> tags
				static rex backquoted {R"__(`([^`]*)`)__"};

				var codematches = comments.match(backquoted);
				for (var codematch : codematches) {
					codematch = codematch.f(1, 2);

					// ... becomes proper code
					let aborting = " abort(\"" ^ funcname ^ ": \" ^ lasterror());";
					codematch.replacer(") ... ok", ") {/" "*ok*" "/} else " ^ aborting);
					codematch.replacer(") ... true", ") {/" "*true*" "/} else " ^ aborting);
//					codematch.replacer(") ...", ") {abort();}");
					codematch.replacer(" ...", aborting);

					codematch.replacer("\n", "\n\t\t");
					codematch.replacer("\n\t\t\n", "\n");

					// Remove cleanup lines to be put in heading of
					static rex cleanup_pattern {R"__(^[^\n]*// Cleanup[^\n]*)__"};
					var cleanups = codematch.match(cleanup_pattern);
					if (cleanups) {
						for (let cleanup : cleanups) {
							all_cleanups ^= cleanup ^ "\n";
						}
						codematch.replacer(cleanup_pattern, "");
					}

					// Convert some comments to assertions
					// USE ␣ to indicate spaces. They will be converted to spaces in any assert.
					// Warning: Doesnt handle double quotes inside double quote)?

//					// IMPLICT ASSERTS
//					// e.g. 'let|var v1 = xxxxxxx ... // yyyy // zzzz'
////					static rex rex3 = rex(R"__((let|var)\s+([a-z0-9A-Z_]+)([^/\n]*)//\s+([^/\n]*)([^\n]*))__");
////					codematch.replacer(rex3, "$1 $2$3;assert\\($2 == $4\\);$5");
//					// e.g. '   let|var v1 = xxxxxxx ; // yyyy // zzzz'
//					//      '1112222222 3344444444444     555556666666'
					static rex rex3 = rex(R"__(^(\s*)(let|var)\s+([a-z0-9A-Z_]+)([^\n]*?);[ \t]*//\s+(["0-9.-][^\n]*?)([ \t]//[^\n]*?)?$)__", "m");
					codematch.replacer(rex3, "$1$2 $3$4; assert\\($3 == $5\\);$6");

//					// ARROW ASSERTS
////				// e.g. '  // v1 -> "f1^X^f3"_var // v2 -> "a b c"'
					//        if (not field.readf(file, key, fieldno)) abort("readf" ": " ^ lasterror()); // field -> "G"
					static rex rex5 = rex(R"__(([^/])//\s*([a-zA-Z0-9_.()]+)\s*->\s*([^/\n]*))__");
					codematch.replacer(rex5, "$1 assert\\($2 == $3\\);");
					// Why does it need multiple?
					codematch.replacer(rex5, "$1 assert\\($2 == $3\\); ");
					codematch.replacer(rex5, "$1 assert\\($2 == $3\\); ");
					codematch.replacer(rex5, "$1 assert\\($2 == $3\\); ");
					codematch.replacer(rex5, "$1 assert\\($2 == $3\\); ");


//					// MUTATOR ASSERTS
//					// e.g. 'v1.xxx xxx xxx // zzzz // xxxxxx'
//					// e.g. 'v1.ucaser(); // "ABC"'
					static rex rex4 = rex(R"__(^(\s*)([a-z0-9A-Z_]+)\.([^/\n]*)//\s+([^/\n]*)([^\n]*))__");
					codematch.replacer(rex4, "$1$2.$3;assert\\($2 == $4\\);$5");

					// Replace hacked spaces ␣ with real spaces " "
					codematch.textconverter("␣", " ");

					// Wrap in {}
					codematch.prefixer("\n\t{\n\t\t");
					codematch ^= "\n\t}\n";

					// Lead with function name
//					codematch.prefixer("\n\t/" "/" ^ srcline);
					codematch.prefixer("\n\tprintl(" ^ srcline.quote() ^ ");");

					// Global definitions;
					for (var objname : new_objs) {
						objname.converter("()", "");
						if (not objname or objname == "var")
							continue;
						if (not locate(objname, defined_objs)) {
							codematch.prefixer("\n\tvar " ^ objname ^ ";\n");
							defined_objs ^= objname ^ VM;
						}
					}
					new_objs = "";

					// Start the code output file
					if (not codeptr) {
						if (not oswrite("" on code_filename))
							abort(lasterror());
						if (not osopen(code_filename to codefile))
							abort(lasterror());

						outputcode("//" ^ fileheader ^ "\n\n");

						let progheader =
R"__(#include <cassert>
#include <exodus/program.h>
programinit()

function main() {

	// Clean up before starting
	gosub cleanup();
)__";

						outputcode(progheader);
					}

					outputcode(codematch);
				}

				comments.replacer(backquoted, "<syntaxhighlight lang=\"c++\">\n$1</syntaxhighlight>");
			}

			comments.replacer(_FM, "<br>\n");

			var line2 = srcline.field(";", 1);
			line2.replacer("\\bstd::size_t\\b", "");
			line2.replacer("\\bconst&&\\b", "");
			line2.replacer("\\bconst&\\b", "");
			line2.replacer("\\bconst\\b"_rex, "");
			line2.replacer("\\bin\\b"_rex, "");
			line2.replacer("\\bSV\\b"_rex, "");
			line2.replacer("\\bint& "_rex, "out ");
			line2.replacer("\\bint\\b"_rex, "");
			line2.replacer("\\bchar\\*"_rex, "");
			line2.replacer("\\bbool "_rex, "");
			line2.replacer("\\brex& "_rex, "");
			line2.replacer("= _", "= ");
			line2.trimmer();
			line2.replacer("( ", "(");
			line2.replacer(" )", ")");

			if (line2.ends("&&"))
				continue;

			if (line2.ends("&")) {
				line2.popper();
				line2.trimmerlast();
			}

			if (line2.ends("REF")) {
				line2.cutter(-3);
				line2.trimmerlast();
			}

			line2.replacer("DEFAULT_SPACE", R"__(= "")__");
			line2.replacer("DEFAULT_EMPTY", R"__(= "")__");
			line2.replacer("DEFAULT_CSPACE", R"__(= ' ')__");

			printl("|-");

			// bold the function name
			line2.prefixer("<em>");
			line2.paster(line2.index("("), "</em>");

			line2 = "|" ^ prefix ^ "||" ^ (objname ?: default_objname) ^ "." ^ line2 ^ "||" ^ comments;
			printl(line2);
// format() slows compilation a lot for one off compilations (2.8/0.73 secs i.e x4)
// so maybe wait for a modules version of fmt library
//			println("|" "{}" "||" "<em>" "{}" "</em>" "." "{}" "||" "{}", prefix, objname, line2, comments);

		} // srcline

		// Close prior table
		if (in_table)
			printl("|}:");

		// Finalise the code output
		if (codeptr) {
			outputcode("\n\n\tgosub cleanup();\n");
			outputcode("\n\treturn 0;\n}");
			outputcode("\nsubroutine cleanup() {\n");
			outputcode("\n\t//Note that all '// Cleanup' lines in the original source code must use literals and not variables\n");
			outputcode("\t//otherwise the generated code will VNA on cleanup\n");
			outputcode(all_cleanups);
			outputcode("};");
			outputcode("\n\nprogramexit()\n");
		}

		osclose(codefile);

	} // osfilename

	return 0;
}

subroutine outputcode(in text) {
	if (not osbwrite(text on codefile, codeptr))
		abort(lasterror());
}

programexit()
