.TH var

Generated by cli/gendoc from var.h 10 FEB 2025 18:17:34

.SH 1. STRING CREATION
.SH

.SS
var v1 = num.round(ndecimals = 0);
.nf
‚ÄÉ
.fi
Returns: A string representation of a decimal number rounded to a desired number of decimal places

Returns: A var ASCII string with exact decimal places requested.

.5 always rounds away from zero.
.RS
.nf

let v1 = var(0.295).round(2); // "0.30"
// or
let v2 = round(1.295, 2); // "1.30"

var v3 = var(-0.295).round(2); // "-0.30"
// or
var v4 = round(-1.295, 2); // "-1.30"
.fi
.RE


.SS
var v1 = var().chr(num);
.nf
‚ÄÉ
.fi
Returns: A string containing a single char (byte) given an integer 0-255.

0-127 -> ASCII, 128-255 -> invalid UTF-8 so cannot be written to database or used various exodus string operations
.RS
.nf

let v1 = var().chr(0x61); // "a"
// or
let v2 = chr(0x61);
.fi
.RE


.SS
var v1 = var().textchr(num);
.nf
‚ÄÉ
.fi
Returns: A string of a single unicode code point in utf8 encoding.

To get utf codepoints > 2^63 you must provide negative ints

Not providing implicit constructor from var to unsigned int due to getting ambigious conversions

since int and unsigned int are parallel priority in c++ implicit conversions
.RS
.nf

let v1 = var().textchr(171416); // "©∂ò" // or "\xF0A9B698"
// or
let v2 = textchr(171416);
.fi
.RE


.SS
var v1 = var().str(num);
.nf
‚ÄÉ
.fi
Returns: A string of repeating characters or strings
.RS
.nf

let v1 = "ab"_var.str(3); // "ababab"
// or
let v2 = str("ab", 3);
.fi
.RE


.SS
var v1 = num.space();
.nf
‚ÄÉ
.fi
Returns: A string of space characters.
.RS
.nf

let v1 = var(3).space(); // "‚ê£‚ê£‚ê£"
// or
let v2 = space(3);
.fi
.RE


.SS
var v1 = num.numberinwords(languagename_or_locale_id = "");
.nf
‚ÄÉ
.fi
Returns: A string representing a given number written in words instead of digits.

locale: Something like en_GB, ar_AE, el_CY, es_US, fr_FR etc.
.RS
.nf

let softhyphen = "\xc2\xad";
let v1 = var(123.45).numberinwords("de_DE").replace(softhyphen, " "); // "ein‚ê£hundert‚ê£drei‚ê£und‚ê£zwanzig‚ê£Komma‚ê£vier‚ê£f√ºnf"
.fi
.RE


.SH 2. STRING SCANNING
.SH

.SS
var v1 = strvar.seq();
.nf
‚ÄÉ
.fi
Returns: The character number of the first char.
.RS
.nf

let v1 = "abc"_var.seq(); // 0x61 // decimal 97
// or
let v2 = seq("abc");
.fi
.RE


.SS
var v1 = strvar.textseq();
.nf
‚ÄÉ
.fi
Returns: The Unicode character number of the first unicode code point.
.RS
.nf

let v1 = "Œì"_var.textseq(); // 915 // U+0393: Greek Capital Letter Gamma (Unicode Character)
// or
let v2 = textseq("Œì");
.fi
.RE


.SS
var v1 = strvar.len();
.nf
‚ÄÉ
.fi
Returns: The length of a string in number of chars
.RS
.nf

let v1 = "abc"_var.len(); // 3
// or
let v2 = len("abc");
.fi
.RE


.SS
var v1 = strvar.textwidth();
.nf
‚ÄÉ
.fi
Returns: The number of output columns.

Allows multi column unicode and reduces combining characters etc. like e followed by grave accent

Possibly does not properly calculate combining sequences of graphemes e.g. face followed by colour
.RS
.nf

let v1 = "ü§°xü§°"_var.textwidth(); // 5
// or
let v2 = textwidth("ü§°xü§°");
.fi
.RE


.SS
var v1 = strvar.textlen();
.nf
‚ÄÉ
.fi
Returns: The number of Unicode code points
.RS
.nf

let v1 = "ŒìŒπŒ¨ŒΩŒΩŒ∑œÇ"_var.textlen(); // 7
// or
let v2 = textlen("ŒìŒπŒ¨ŒΩŒΩŒ∑œÇ");
.fi
.RE


.SS
var v1 = strvar.fcount(sepstr);
.nf
‚ÄÉ
.fi
Returns: The count of the number of fields separated by a given sepstr.

It is the same as var.count(sepstr) + 1 except that it returns 0 for an empty string.
.RS
.nf

let v1 = "aa**cc"_var.fcount("*"); // 3
// or
let v2 = fcount("aa**cc", "*");
.fi
.RE


.SS
var v1 = strvar.count(sepstr);
.nf
‚ÄÉ
.fi
Returns: The count of the number of sepstr found.
.RS
.nf

let v1 = "aa**cc"_var.count("*"); // 2
// or
let v2 = count("aa**cc", "*");
.fi
.RE


.SS
if (strvar.starts(prefix)) ...
.nf
‚ÄÉ
.fi
Returns: True if starts with prefix
.RS
.nf

if ("abc"_var.starts("ab")) ... true
// or
if (starts("abc", "ab")) ... true
.fi
.RE


.SS
if (strvar.ends(suffix)) ...
.nf
‚ÄÉ
.fi
Returns: True if ends with suffix
.RS
.nf

if ("abc"_var.ends("bc")) ... true
// or
if (ends("abc", "bc")) ... true
.fi
.RE


.SS
if (strvar.contains(substr)) ...
.nf
‚ÄÉ
.fi
Returns: True if starts, ends or contains substr
.RS
.nf

if ("abcd"_var.contains("bc")) ... true
// or
if (contains("abcd", "bc")) ... true
.fi
.RE


.SS
var v1 = strvar.index(substr, startchar1 = 1);
.nf
‚ÄÉ
.fi
Returns: The index (1 based position) of a given substr on or after a given starting char number if present

Returns: 0 if not present.
.RS
.nf

let v1 = "abcd"_var.index("bc"); // 2
// or
let v2 = index("abcd", "bc");
.fi
.RE


.SS
var v1 = strvar.indexn(substr, occurrence);
.nf
‚ÄÉ
.fi
Returns: The index (1 based position) of the nth occurrence of a given substr if present

Returns: 0 if not present.
.RS
.nf

let v1 = "abcabc"_var.index("bc", 2); // 2
// or
let v2 = index("abcabc", "bc", 2);
.fi
.RE


.SS
var v1 = strvar.indexr(substr, startchar1 = -1);
.nf
‚ÄÉ
.fi
Reverse substr search.

Returns: The index (1 based position) of the substr on or before a given starting char number if present

startchar1 defaults to -1 meaning start searching from the last char (towards the first char).
.RS
.nf

let v1 = "abcabc"_var.indexr("bc"); // 5
// or
let v2 = indexr("abcabc", "bc");
.fi
.RE


.SS
var v1 = strvar.match(regex_str, regex_options = "");
.nf
‚ÄÉ
.fi
Returns: All results of regex matching

Multiple matches are returned separated by FMs. Groups are in VMs.
.RS
.nf

let v1 = "abc1abc2"_var.match("BC(\\d)", "i"); // "bc1]1^bc2]2"_var
// or
let v2 = match("abc1abc2", "BC(\\d)", "i");
.fi
.RE

regex_options:



l - Literal (any regex chars are treated as normal chars)



i - Case insensitive



p - ECMAScript/Perl (the default)

b - Basic POSIX (same as sed)

e - Extended POSIX

a - awk

g - grep

eg - egrep or grep -E



char ranges like a-z are locale sensitive if ECMAScript



m - Multiline. Default in boost (and therefore exodus)

s - Single line. Default in std::regex



f - First only. Only for replace() (not match() or search())



w - Wildcard glob style (e.g. *.cfg) not regex style. Only for match() and search(). Not replace().

.SS
var v1 = strvar.match(regex);
.nf
‚ÄÉ
.fi
Ditto

.SS
var v1 = strvar.search(regex_str, io startchar1, regex_options = "");
.nf
‚ÄÉ
.fi
Search for first match of a regular expression starting at startchar1

Updates startchar1 ready to search for the next match

regex_options as for match()
.RS
.nf

var startchar1 = 1;
let v1 = "abc1abc2"_var.search("BC(\\d)", startchar1, "i"); // "bc1]1"_var // startchar1.outputl() -> 5 /// Ready for the next search
// or
startchar1 = 1;
let v2 = search("abc1abc2", "BC(\\d)", startchar1, "i");
.fi
.RE


.SS
var v1 = strvar.search(regex_str);
.nf
‚ÄÉ
.fi
Ditto starting from first char

.SS
var v1 = strvar.search(regex, io startchar1);
.nf
‚ÄÉ
.fi
Ditto given a rex

.SS
var v1 = strvar.search(regex);
.nf
‚ÄÉ
.fi
Ditto starting from first char.

.SS
var v1 = strvar.hash(std::uint64_t modulus = 0);
.nf
‚ÄÉ
.fi
Hash by default returns a 64 bit signed integer as a var.

If a modulus is provided then the result is limited to [0, modulus)

MurmurHash3 is used.
.RS
.nf

let v1 = "abc"_var.hash(); assert(v1 == var(6'715'211'243'465'481'821));
// or
let v2 = hash("abc");
.fi
.RE


.SH 3. STRING CONVERSION - NON-MUTATING - CHAINABLE
.SH

.SS
var v1 = strvar.ucase();
.nf
‚ÄÉ
.fi
To upper case
.RS
.nf

let v1 = "ŒìŒπŒ¨ŒΩŒΩŒ∑œÇ"_var.ucase(); // "ŒìŒôŒÜŒùŒùŒóŒ£"
// or
let v2 = ucase("ŒìŒπŒ¨ŒΩŒΩŒ∑œÇ");
.fi
.RE


.SS
var v1 = strvar.lcase();
.nf
‚ÄÉ
.fi
To lower case
.RS
.nf

let v1 = "ŒìŒôŒÜŒùŒùŒóŒ£"_var.lcase(); // "Œ≥ŒπŒ¨ŒΩŒΩŒ∑œÇ"
// or
let v2 = lcase("ŒìŒôŒÜŒùŒùŒóŒ£");
.fi
.RE


.SS
var v1 = strvar.tcase();
.nf
‚ÄÉ
.fi
To title case (first letters are capitalised)
.RS
.nf

let v1 = "Œ≥ŒπŒ¨ŒΩŒΩŒ∑œÇ"_var.tcase(); // "ŒìŒπŒ¨ŒΩŒΩŒ∑œÇ"
// or
let v2 = tcase("Œ≥ŒπŒ¨ŒΩŒΩŒ∑œÇ");
.fi
.RE


.SS
var v1 = strvar.fcase();
.nf
‚ÄÉ
.fi
To folded case (lower case and remove accents for indexing)

.SS
var v1 = strvar.normalize();
.nf
‚ÄÉ
.fi
Normalises unicode code points sequences to their standardised NFC form making them binary comparable.

.SS
var v1 = strvar.invert();
.nf
‚ÄÉ
.fi
Simple reversible disguising of text

invert(invert()) returns to original.

Flips bit 8 of unicode code points. Note that ASCII bytes become multibyte UTF-8 so string sizes change.
.RS
.nf

let v1 = "abc"_var.invert(); // "\xC2" "\x9E" "\xC2" "\x9D" "\xC2" "\x9C"
// or
let v2 = invert("abc");
.fi
.RE


.SS
var v1 = strvar.lower();
.nf
‚ÄÉ
.fi
Convert all FM to VM, VM to SM etc.
.RS
.nf

let v1 = "a1^b2^c3"_var.lower(); // "a1]b2]c3"_var
// or
let v2 = lower("a1^b2^c3"_var);
.fi
.RE


.SS
var v1 = strvar.raise();
.nf
‚ÄÉ
.fi
Convert all VM to FM, SM to VM etc.
.RS
.nf

let v1 = "a1]b2]c3"_var.raise(); // "a1^b2^c3"_var
// or
let v2 = "a1]b2]c3"_var;
.fi
.RE


.SS
var v1 = strvar.crop();
.nf
‚ÄÉ
.fi
Remove any redundant FM, VM etc. characters (Trailing FM; VM before FM etc.)
.RS
.nf

let v1 = "a1^b2]]^c3^^"_var.crop(); // "a1^b2^c3"_var
// or
let v2 = crop("a1^b2]]^c3^^"_var);
.fi
.RE


.SS
var v1 = strvar.quote();
.nf
‚ÄÉ
.fi
Wrap in double quotes
.RS
.nf

let v1 = "abc"_var.quote(); // "\"abc\""
// or
let v2 = quote("abc");
.fi
.RE


.SS
var v1 = strvar.squote();
.nf
‚ÄÉ
.fi
Wrap in single quotes
.RS
.nf

let v1 = "abc"_var.squote(); // "'abc'"
// or
let v2 = squote("abc");
.fi
.RE


.SS
var v1 = strvar.unquote();
.nf
‚ÄÉ
.fi
Remove one pair of double or single quotes
.RS
.nf

let v1 = "'abc'"_var.unquote(); // "abc"
// or
let v2 = unquote("'abc'");
.fi
.RE


.SS
var v1 = strvar.trim(trimchars = " ");
.nf
‚ÄÉ
.fi
Remove leading, trailing and excessive inner bytes
.RS
.nf

let v1 = "‚ê£‚ê£a1‚ê£‚ê£b2‚ê£c3‚ê£‚ê£"_var.trim(); // "a1‚ê£b2‚ê£c3"
// or
let v2 = trim("‚ê£‚ê£a1‚ê£‚ê£b2‚ê£c3‚ê£‚ê£");
.fi
.RE


.SS
var v1 = strvar.trimfirst(trimchars = " ");
.nf
‚ÄÉ
.fi
Ditto leading
.RS
.nf

let v1 = "‚ê£‚ê£a1‚ê£‚ê£b2‚ê£c3‚ê£‚ê£"_var.trimfirst(); // "a1‚ê£‚ê£b2‚ê£c3‚ê£‚ê£"
// or
let v2 = trimfirst("‚ê£‚ê£a1‚ê£‚ê£b2‚ê£c3‚ê£‚ê£");
.fi
.RE


.SS
var v1 = strvar.trimlast(trimchars = " ");
.nf
‚ÄÉ
.fi
Ditto trailing
.RS
.nf

let v1 = "‚ê£‚ê£a1‚ê£‚ê£b2‚ê£c3‚ê£‚ê£"_var.trimlast(); // "‚ê£‚ê£a1‚ê£‚ê£b2‚ê£c3"
// or
let v2 = trimlast("‚ê£‚ê£a1‚ê£‚ê£b2‚ê£c3‚ê£‚ê£");
.fi
.RE


.SS
var v1 = strvar.trimboth(trimchars = " ");
.nf
‚ÄÉ
.fi
Ditto leading, trailing but not inner
.RS
.nf

let v1 = "‚ê£‚ê£a1‚ê£‚ê£b2‚ê£c3‚ê£‚ê£"_var.trimboth(); // "a1‚ê£‚ê£b2‚ê£c3"
// or
let v2 = trimboth("‚ê£‚ê£a1‚ê£‚ê£b2‚ê£c3‚ê£‚ê£");
.fi
.RE


.SS
var v1 = strvar.first();
.nf
‚ÄÉ
.fi
Extract first char or "" if empty
.RS
.nf

let v1 = "abc"_var.first(); // "a"
// or
let v2 = first("abc");
.fi
.RE


.SS
var v1 = strvar.last();
.nf
‚ÄÉ
.fi
Extract last char or "" if empty
.RS
.nf

let v1 = "abc"_var.last(); // "c"
// or
let v2 = last("abc");
.fi
.RE


.SS
var v1 = strvar.first(std::size_t length);
.nf
‚ÄÉ
.fi
Extract up to length leading chars
.RS
.nf

let v1 = "abc"_var.first(2); // "ab"
// or
let v2 = first("abc", 2);
.fi
.RE


.SS
var v1 = strvar.last(std::size_t length);
.nf
‚ÄÉ
.fi
Extract up to length trailing chars
.RS
.nf

let v1 = "abc"_var.last(2); // "bc"
// or
let v2 = last("abc", 2);
.fi
.RE


.SS
var v1 = strvar.cut(length);
.nf
‚ÄÉ
.fi
Remove length leading chars
.RS
.nf

let v1 = "abcd"_var.cut(2); // "cd"
// or
let v2 = cut("abcd", 2);
.fi
.RE


.SS
var v1 = strvar.paste(pos1, length, insertstr);
.nf
‚ÄÉ
.fi
Insert text at char position overwriting length chars
.RS
.nf

let v1 = "abcd"_var.paste(2, 2, "XYZ"); // "aXYZd"
// or
let v2 = paste("abcd", 2, 2, "XYZ");
.fi
.RE


.SS
var v1 = strvar.paste(pos1, insertstr);
.nf
‚ÄÉ
.fi
Insert text at char position without overwriting any following characters
.RS
.nf

let v1 = "abcd"_var.paste(2, "XYZ"); // "aXYZbcd"
// or
let v2 = paste("abcd", 2, "XYZ");
.fi
.RE


.SS
var v1 = strvar.prefix(insertstr);
.nf
‚ÄÉ
.fi
Insert text at the beginning
.RS
.nf

let v1 = "abc"_var.prefix("XYZ"); // "XYZabc"
// or
let v2 = prefix("abc", "XYZ");
.fi
.RE


.SS
var v1 = strvar.append(appendable, ...);
.nf
‚ÄÉ
.fi
Append text at the end
.RS
.nf

let v1 = "abc"_var.append(" is ", 10, " ok", '.'); // "abc is 10 ok."
// or
let v2 = append("abc", " is ", 10, " ok", '.');
.fi
.RE


.SS
var v1 = strvar.pop();
.nf
‚ÄÉ
.fi
Remove one trailing char
.RS
.nf

let v1 = "abc"_var.pop(); // "ab"
// or
let v2 = pop("abc");
.fi
.RE


.SS
var v1 = strvar.field(strx, fieldnx = 1, nfieldsx = 1);
.nf
‚ÄÉ
.fi
Extract one or more consecutive fields given a delimiter char or substr.
.RS
.nf

let v1 = "aa*bb*cc"_var.field("*", 2); // "bb"
// or
let v2 = field("aa*bb*cc", "*", 2);
.fi
.RE


.SS
var v1 = strvar.field2(separator, fieldno, nfields = 1);
.nf
‚ÄÉ
.fi
field2 is a version that treats fieldn -1 as the last field, -2 the penultimate field etc. -

TODO Should probably make field() do this (since -1 is basically an erroneous call) and remove field2

Same as var.field() but negative fieldnos work backwards from the last field.
.RS
.nf

let v1 = "aa*bb*cc"_var.field2("*", -1); // "cc"
// or
let v2 = field2("aa*bb*cc", "*", -1);
.fi
.RE


.SS
var v1 = strvar.fieldstore(separator, fieldno, nfields, replacement);
.nf
‚ÄÉ
.fi
fieldstore() replaces n fields of subfield(s) in a string.
.RS
.nf

let v1 = "aa*bb*cc*dd"_var.fieldstore("*", 2, 3, "X*Y"); // "aa*X*Y*"
// or
let v2 = fieldstore("aa*bb*cc*dd", "*", 2, 3, "X*Y");
.fi
.RE

If nfields is 0 then insert fields before fieldno
.RS
.nf

let v1 = "a1*b2*c3*d4"_var.fieldstore("*", 2, 0, "X*Y"); // "a1*X*Y*b2*c3*d4"
// or
let v2 = fieldstore("a1*b2*c3*d4", "*", 2, 0, "X*Y");
.fi
.RE

If nfields is negative then delete abs(n) fields before inserting.
.RS
.nf

let v1 = "a1*b2*c3*d4"_var.fieldstore("*", 2, -3, "X*Y"); // "a1*X*Y"
// or
let v2 = fieldstore("a1*b2*c3*d4", "*", 2, -3, "X*Y");
.fi
.RE


.SS
var v1 = strvar.substr(pos1, length);
.nf
‚ÄÉ
.fi
substr version 1. Extract length chars starting at pos1
.RS
.nf

let v1 = "abcd"_var.substr(2, 2); // "bc"
// or
let v2 = substr("abcd", 2, 2);
.fi
.RE

If length is negative then work backwards and return chars reversed
.RS
.nf

let v1 = "abcd"_var.substr(3, -2); // "cb"
// or
let v2 = substr("abcd", 3, -2);
.fi
.RE


.SS
var v1 = strvar.b(pos1, length);
.nf
‚ÄÉ
.fi
Same as substr version 1.

.SS
var v1 = strvar.substr(pos1);
.nf
‚ÄÉ
.fi
substr version 2. Extract all chars from pos1 up to the end
.RS
.nf

let v1 = "abcd"_var.substr(2); // "bcd"
// or
let v2 = substr("abcd", 2);
.fi
.RE


.SS
var v1 = strvar.b(pos1);
.nf
‚ÄÉ
.fi
Same as substr version 2.

.SS
var v1 = strvar.substr(pos1, delimiterchars, io pos2);
.nf
‚ÄÉ
.fi
substr version 3.

Extract a substr starting from pos1 up to any one of some given delimiter chars

Also returns in pos2 the pos of the following delimiter or one past the end of the string if not found.

Add 1 to pos2 start the next search if continuing.
.RS
.nf

var pos1a = 4, pos2a;
let v1 = "aa,bb,cc"_var.substr(pos1a, ",", pos2a); // "bb" // pos2a -> 6
// or
var pos1b = 4, pos2b;
let v2 = substr("aa,bb,cc", pos1b, ",", pos2b);
.fi
.RE


.SS
var v1 = strvar.b(pos1, delimiterchars, io pos2);
.nf
‚ÄÉ
.fi
Alias of substr version 3.

.SS
var v1 = strvar.substr2(io pos1, out delimiterno);
.nf
‚ÄÉ
.fi
substr version 4.

Returns: A substr from a given pos1 up to the next RM/FM/VM/SM/TM/ST delimiter char.

Also returns the next index/offset and the delimiter no. found (1-6) or 0 if not found.
.RS
.nf

var pos1a = 4, delim1;
let v1 = "aa^bb^cc"_var.substr2(pos1a, delim1); // "bb" // pos1a -> 7 // delim1 -> 2
// or
var pos1b = 4, delim2;
let v2 = substr2("aa^bb^cc"_var, pos1b, delim2);
.fi
.RE


.SS
var v1 = strvar.b2(io pos1, out delimiterno);
.nf
‚ÄÉ
.fi
Alias of substr version 4

.SS
var v1 = strvar.convert(fromchars, tochars);
.nf
‚ÄÉ
.fi
Convert chars to other chars one for one or delete where tochars is shorter.
.RS
.nf

let v1 = "abcde"_var.convert("aZd", "XY"); // "Xbce" // a is replaced and d is removed
// or
let v2 = convert("abcde", "aZd", "XY");
.fi
.RE


.SS
var v1 = strvar.textconvert(fromchars, tochars);
.nf
‚ÄÉ
.fi
Ditto for Unicode code points.
.RS
.nf

let v1 = "aü§°büòÄcüåçd"_var.textconvert("ü§°üòÄ", "üëã"); // "aüëãbcüåçd"
// or
let v2 = textconvert("aü§°büòÄcüåçd", "ü§°üòÄ", "üëã");
.fi
.RE


.SS
var v1 = strvar.replace(fromstr, tostr);
.nf
‚ÄÉ
.fi
Replace all occurrences of a substr with another. Case sensitive
.RS
.nf

let v1 = "Abc.Abc"_var.replace("bc", "X"); // "AX.AX"
// or
let v2 = replace("Abc Abc", "bc", "X");
.fi
.RE


.SS
var v1 = strvar.replace(regex, tostr);
.nf
‚ÄÉ
.fi
Replace substring(s) using a regular expression.

Use $0, $1, $2 in tostr to refer to groups defined in the regex.
.RS
.nf

let v1 = "A a B b"_var.replace("[A-Z]"_rex, "'$0'"); // "'A' a 'B' b"
// or
let v2 = replace("A a B b", "[A-Z]"_rex, "'$0'");
.fi
.RE


.SS
var v1 = strvar.unique();
.nf
‚ÄÉ
.fi
Remove duplicate fields in an FM or VM etc. separated list
.RS
.nf

let v1 = "a1^b2^a1^c2"_var.unique(); // "a1^b2^c2"_var
// or
let v2 = unique("a1^b2^a1^c2"_var);
.fi
.RE


.SS
var v1 = strvar.sort(sepchar = FM);
.nf
‚ÄÉ
.fi
Reorder fields in an FM or VM etc. separated list in ascending order

Numerical:
.RS
.nf

let v1 = "20^10^2^1^1.1"_var.sort(); // "1^1.1^2^10^20"_var
// or
let v2 = sort("20^10^2^1^1.1"_var);
.fi
.RE

Alphabetical:
.RS
.nf

let v1 = "b1^a1^c20^c10^c2^c1^b2"_var.sort(); // "a1^b1^b2^c1^c10^c2^c20"_var
// or
let v2 = sort("b1^a1^c20^c10^c2^c1^b2"_var);
.fi
.RE


.SS
var v1 = strvar.reverse(sepchar = FM);
.nf
‚ÄÉ
.fi
Reorder fields in an FM or VM etc. separated list in descending order
.RS
.nf

let v1 = "20^10^2^1^1.1"_var.reverse(); // "1.1^1^2^10^20"_var
// or
let v2 = reverse("20^10^2^1^1.1"_var);
.fi
.RE


.SS
var v1 = strvar.shuffle(sepchar = FM);
.nf
‚ÄÉ
.fi
Randomise the order of fields in an FM, VM separated list
.RS
.nf

let v1 = "20^10^2^1^1.1"_var.shuffle(); /// e.g. "2^1^20^1.1^10" (random order depending on initrand())
// or
let v2 = shuffle("20^10^2^1^1.1"_var);
.fi
.RE


.SS
var v1 = strvar.parse(char sepchar = ' ');
.nf
‚ÄÉ
.fi
Replace separator characters with FM char except inside double or single quotes ignoring escaped quotes &bsol;" &bsol;'
.RS
.nf

let v1 = "abc,\"def,\"123\" fgh\",12.34"_var.parse(','); // "abc^\"def,\"123\" fgh\"^12.34"_var
// or
let v2 = parse("abc,\"def,\"123\" fgh\",12.34", ',');
.fi
.RE


.SH 4. STRING CONVERSION - MUTATING - STANDALONE COMMANDS
.SH

.SS
strvar.ucaser()
.nf
‚ÄÉ
.fi
Upper case

All string mutators follow the same pattern as ucaser.<br>See the non-mutating functions for details.
.RS
.nf

var v1 = "abc";
v1.ucaser(); // "ABC"
// or
ucaser(v1);
.fi
.RE


.SS
strvar.lcaser()
.nf
‚ÄÉ
.fi


.SS
strvar.tcaser()
.nf
‚ÄÉ
.fi


.SS
strvar.fcaser()
.nf
‚ÄÉ
.fi


.SS
strvar.normalizer()
.nf
‚ÄÉ
.fi


.SS
strvar.inverter()
.nf
‚ÄÉ
.fi


.SS
strvar.quoter()
.nf
‚ÄÉ
.fi


.SS
strvar.squoter()
.nf
‚ÄÉ
.fi


.SS
strvar.unquoter()
.nf
‚ÄÉ
.fi


.SS
strvar.lowerer()
.nf
‚ÄÉ
.fi


.SS
strvar.raiser()
.nf
‚ÄÉ
.fi


.SS
strvar.cropper()
.nf
‚ÄÉ
.fi


.SS
strvar.trimmer(trimchars = " ")
.nf
‚ÄÉ
.fi


.SS
strvar.trimmerfirst(trimchars = " ")
.nf
‚ÄÉ
.fi


.SS
strvar.trimmerlast(trimchars = " ")
.nf
‚ÄÉ
.fi


.SS
strvar.trimmerboth(trimchars = " ")
.nf
‚ÄÉ
.fi


.SS
strvar.firster()
.nf
‚ÄÉ
.fi


.SS
strvar.laster()
.nf
‚ÄÉ
.fi


.SS
strvar.firster(std::size_t length)
.nf
‚ÄÉ
.fi


.SS
strvar.laster(std::size_t length)
.nf
‚ÄÉ
.fi


.SS
strvar.cutter(length)
.nf
‚ÄÉ
.fi


.SS
strvar.paster(pos1, length, insertstr)
.nf
‚ÄÉ
.fi


.SS
strvar.paster(pos1, insertstr)
.nf
‚ÄÉ
.fi


.SS
strvar.prefixer(insertstr)
.nf
‚ÄÉ
.fi


.SS
strvar.appender(appendable, ...)
.nf
‚ÄÉ
.fi


.SS
strvar.popper()
.nf
‚ÄÉ
.fi


.SS
strvar.fieldstorer(sepchar, fieldno, nfields, replacement)
.nf
‚ÄÉ
.fi


.SS
strvar.substrer(pos1, length)
.nf
‚ÄÉ
.fi


.SS
strvar.substrer(pos1)
.nf
‚ÄÉ
.fi


.SS
strvar.converter(fromchars, tochars)
.nf
‚ÄÉ
.fi


.SS
strvar.textconverter(fromchars, tochars)
.nf
‚ÄÉ
.fi


.SS
strvar.replacer(regex, tostr)
.nf
‚ÄÉ
.fi


.SS
strvar.replacer(fromstr, tostr)
.nf
‚ÄÉ
.fi


.SS
strvar.uniquer()
.nf
‚ÄÉ
.fi


.SS
strvar.sorter(sepchar = FM)
.nf
‚ÄÉ
.fi


.SS
strvar.reverser(sepchar = FM)
.nf
‚ÄÉ
.fi


.SS
strvar.shuffler(sepchar = FM)
.nf
‚ÄÉ
.fi


.SS
strvar.parser(char sepchar = ' ')
.nf
‚ÄÉ
.fi


.SH 5. I/O CONVERSION
.SH

.SS
var v1 = var.oconv(convstr);
.nf
‚ÄÉ
.fi
Converts internal data to output external display format according to a given conversion code or pattern

If the internal data is invalid and cannot be converted then most conversions return the ORIGINAL data unconverted

Throws a runtime error VarNotImplemented if convstr is invalid

See [[#ICONV/OCONV PATTERNS]]
.RS
.nf

let v1 = var(30123).oconv("D/E"); // "21/06/2050"
// or
let v2 = oconv(30123, "D/E");
.fi
.RE


.SS
var v1 = var.iconv(convstr);
.nf
‚ÄÉ
.fi
Converts external data to internal format according to a given conversion code or pattern

If the external data is invalid and cannot be converted then most conversions return the EMPTY STRING ""

Throws a runtime error VarNotImplemented if convstr is invalid

See [[#ICONV/OCONV PATTERNS]]
.RS
.nf

let v1 = "21 JUN 2050"_var.iconv("D/E"); // 30123
// or
let v2 = iconv("21 JUN 2050", "D/E");
.fi
.RE


.SS
var v1 = var.format(fmt_str, args, ...);
.nf
‚ÄÉ
.fi
Classic format function in printf style

vars can be formatted either with C++ format codes e.g. {:_>8.2f}

or with exodus oconv codes e.g. {::MD20P|R(_)#8} as in the below example.
.RS
.nf

let v1 = var(12.345).format("'{:_>8.2f}'"); // "'___12.35'"
let v2 = var(12.345).format("'{::MD20P|R(_)#8}'");
// or
var v3 = format("'{:_>8.2f}'", var(12.345)); // "'___12.35'"
var v4 = format("'{::MD20P|R(_)#8}'", var(12.345));
.fi
.RE


.SS
var v1 = strvar.from_codepage(codepage);
.nf
‚ÄÉ
.fi
Converts from codepage encoded text to UTF-8 encoded text

e.g. Codepage "CP1124" (Ukrainian).

Use Linux command "iconv -l" for complete list of code pages and encodings.
.RS
.nf

let v1 = "\xa4"_var.from_codepage("CP1124"); // "–Ñ"
// or
let v2 = from_codepage("\xa4", "CP1124");
// U+0404 Cyrillic Capital Letter Ukrainian Ie Unicode Character
.fi
.RE


.SS
var v1 = strvar.to_codepage(codepage);
.nf
‚ÄÉ
.fi
Converts to codepage encoded text from UTF-8 encoded text
.RS
.nf

let v1 = "–Ñ"_var.to_codepage("CP1124").oconv("HEX"); // "A4"
// or
let v2 = to_codepage("–Ñ", "CP1124").oconv("HEX");
.fi
.RE


.SH 6. DYNAMIC ARRAY FUNCTIONS
.SH

.SS
var v1 = strvar.f(fieldno, valueno = 0, subvalueno = 0);
.nf
‚ÄÉ
.fi
f() is a highly abbreviated alias for the PICK OS field/value/subvalue extract() function.

"f()" can be thought of as "field" although the function can extract values and subvalues as well.

The convenient PICK OS angle bracket syntax for field extraction (e.g. xxx<20>) is not available in C++.

The abbreviated exodus field extraction function (e.g. xxx.f(20)) is provided instead since field access is extremely heavily used in source code.
.RS
.nf

let v1 = "f1^f2v1]f2v2]f2v3^f2"_var;
let v2 = v1.f(2, 2); // "f2v2"
.fi
.RE


.SS
var v1 = strvar.extract(fieldno, valueno = 0, subvalueno = 0);
.nf
‚ÄÉ
.fi
Extract a specific field, value or subvalue from a dynamic array.
.RS
.nf

let v1 = "f1^f2v1]f2v2]f2v3^f2"_var;
let v2 = v1.extract(2, 2); // "f2v2"
//
// For brevity the function alias "f()" (standing for "field") is normally used instead of "extract()" as follows:
var v3 = v1.f(2, 2);
.fi
.RE


.SS
var v1 = strvar.pickreplace(fieldno, valueno, subvalueno, replacement);
.nf
‚ÄÉ
.fi
Same as var.r() function but returns a new string instead of updating a variable in place.<br>Rarely used.

.SS
var v1 = strvar.pickreplace(fieldno, valueno, replacement);
.nf
‚ÄÉ
.fi
Ditto for a specific multivalue

.SS
var v1 = strvar.pickreplace(fieldno, replacement);
.nf
‚ÄÉ
.fi
Ditto for a specific field

.SS
var v1 = strvar.insert(fieldno, valueno, subvalueno, insertion);
.nf
‚ÄÉ
.fi
Same as var.inserter() function but returns a new string instead of updating a variable in place.

.SS
var v1 = strvar.insert(fieldno, valueno, insertion);
.nf
‚ÄÉ
.fi
Ditto for a specific multivalue

.SS
var v1 = strvar.insert(fieldno, insertion);
.nf
‚ÄÉ
.fi
Ditto for a specific field

.SS
var v1 = strvar.remove(fieldno, valueno = 0, subvalueno = 0);
.nf
‚ÄÉ
.fi
Same as var.remover() function but returns a new string instead of updating a variable in place.

"remove" was called "delete" in Pick OS.

.SH 7. DYNAMIC ARRAY FILTERS
.SH

.SS
var v1 = strvar.sum();
.nf
‚ÄÉ
.fi
Sum up multiple values into one higher level
.RS
.nf

let v1 = "1]2]3^4]5]6"_var.sum(); // "6^15"_var
// or
let v2 = sum("1]2]3^4]5]6"_var);
.fi
.RE


.SS
var v1 = strvar.sumall();
.nf
‚ÄÉ
.fi
Sum up all levels into a single figure
.RS
.nf

let v1 = "1]2]3^4]5]6"_var.sumall(); // 21
// or
let v2 = sumall("1]2]3^4]5]6"_var);
.fi
.RE


.SS
var v1 = strvar.sum(sepchar);
.nf
‚ÄÉ
.fi
Ditto allowing commas etc.
.RS
.nf

let v1 = "10,20,30"_var.sum(","); // 60
// or
let v2 = sum("10,20,30", ",");
.fi
.RE


.SS
var v1 = strvar.mv(opcode, var2);
.nf
‚ÄÉ
.fi
Binary ops (+, -, *, /) in parallel on multiple values
.RS
.nf

let v1 = "10]20]30"_var.mv("+","2]3]4"_var); // "12]23]34"_var
.fi
.RE


.SH 8. DYNAMIC ARRAY MUTATORS STANDALONE COMMANDS
.SH

.SS
strvar.r(fieldno, replacement)
.nf
‚ÄÉ
.fi
Replaces a specific field in a dynamic array
.RS
.nf

var v1 = "f1^v1]v2}s2}s3^f3"_var;
v1.r(2, "X"); // "f1^X^f3"_var
.fi
.RE


.SS
strvar.r(fieldno, valueno, replacement)
.nf
‚ÄÉ
.fi
Ditto for specific value in a specific field.
.RS
.nf

var v1 = "f1^v1]v2}s2}s3^f3"_var;
v1.r(2, 2, "X"); // "f1^v1]X^f3"_var
.fi
.RE


.SS
strvar.r(fieldno, valueno, subvalueno, replacement)
.nf
‚ÄÉ
.fi
Ditto for a specific subvalue in a specific value of a specific field
.RS
.nf

var v1 = "f1^v1]v2}s2}s3^f3"_var;
v1.r(2, 2, 2, "X"); // "f1^v1]v2}X}s3^f3"_var
.fi
.RE


.SS
strvar.inserter(fieldno, insertion)
.nf
‚ÄÉ
.fi
Insert a specific field in a dynamic array, moving all other fields up.
.RS
.nf

var v1 = "f1^v1]v2}s2}s3^f3"_var;
v1.inserter(2, "X"); // "f1^X^v1]v2}s2}s3^f3"_var
// or
inserter(v1, 2, "X");
.fi
.RE


.SS
strvar.inserter(fieldno, valueno, insertion)
.nf
‚ÄÉ
.fi
Ditto for a specific value in a specific field, moving all other values up.
.RS
.nf

var v1 = "f1^v1]v2}s2}s3^f3"_var;
v1.inserter(2, 2, "X"); // "f1^v1]X]v2}s2}s3^f3"_var
// or
inserter(v1, 2, 2, "X");
.fi
.RE


.SS
strvar.inserter(fieldno, valueno, subvalueno, insertion)
.nf
‚ÄÉ
.fi
Ditto for a specific subvalue in a dynamic array, moving all other subvalues up.
.RS
.nf

var v1 = "f1^v1]v2}s2}s3^f3"_var;
v1.inserter(2, 2, 2, "X"); // "f1^v1]v2}X}s2}s3^f3"_var
// or
v1.inserter(2, 2, 2, "X");
.fi
.RE


.SS
strvar.remover(fieldno, valueno = 0, subvalueno = 0)
.nf
‚ÄÉ
.fi
Remove a specific field (or value, or subvalue) from a dynamic array, moving all other fields (or values, or subvalues) down.
.RS
.nf

var v1 = "f1^v1]v2}s2}s3^f3"_var;
v1.remover(2, 2); // "f1^v1^f3"_var
// or
remover(v1, 2, 2);
.fi
.RE


.SH 9. DYNAMIC ARRAY SEARCH
.SH

.SS
var v1 = strvar.locate(target);
.nf
‚ÄÉ
.fi
locate() with only the target substr argument provided searches unordered values separated by any of the field mark chars.

Returns: The field, value, subvalue etc. number if found or 0 if not.
.RS
.nf

if ("UK^US^UA"_var.locate("US")) ... ok // 2
// or
if (locate("US", "UK^US^UA"_var)) ... ok
.fi
.RE


.SS
if (strvar.locate(target, out valueno)) ...
.nf
‚ÄÉ
.fi
locate() with only the target substr provided and setting returned searches unordered values separated by any type of field mark chars.

Returns: True if found

Setting: Field, value, subvalue etc. number if found or the max number + 1 if not. Suitable for additiom of new values
.RS
.nf

var setting;
if ("UK]US]UA"_var.locate("US", setting)) ... ok // setting -> 2
// or
if (locate("US", "UK]US]UA"_var, setting)) ... ok
.fi
.RE


.SS
if (strvar.locate(target, out setting, fieldno, valueno = 0)) ...
.nf
‚ÄÉ
.fi
locate() the target in unordered fields if fieldno is 0, or values if a fieldno is specified, or subvalues if the valueno argument is provided.

Returns: True if found and with the field, value or subvalue number in setting.

Returns: False if not found and with the max field, value or subvalue number found + 1 in setting. Suitable for replacement of new fields, values or subvalues.
.RS
.nf

var setting;
if ("f1^f2v1]f2v2]s1}s2}s3}s4^f3^f4"_var.locate("s4", setting, 2, 3)) ... ok // setting -> 4 // returns true
.fi
.RE


.SS
if (strvar.locateby(ordercode, target, out valueno)) ...
.nf
‚ÄÉ
.fi
locateby() without fieldno or valueno arguments searches ordered values separated by VM chars.

The order code can be AL, DL, AR, DR meaning Ascending Left, Descending Right, Ascending Right, Ascending Left.

Left is used to indicate alphabetic order where 10 < 2.

Right is used to indicate numeric order where 10 > 2.

Data must be in the correct order for searching to work properly.

Returns: True if found.

In case the target is not exactly found then the correct value no for inserting the target is returned in setting.
.RS
.nf

var valueno; if ("aaa]bbb]ccc"_var.locateby("AL", "bb", valueno)) ... // valueno -> 2 // returns false and valueno = where it could be correctly inserted.
.fi
.RE


.SS
if (strvar.locateby(ordercode, target, out setting, fieldno, valueno = 0)) ...
.nf
‚ÄÉ
.fi
locateby() ordered as above but in fields if fieldno is 0, or values in a specific fieldno, or subvalues in a specific valueno.
.RS
.nf

var setting;
if ("f1^f2^aaa]bbb]ccc^f4"_var.locateby("AL", "bb", setting, 3)) ... // setting -> 2 // return false and where it could be correctly inserted.
.fi
.RE


.SS
if (strvar.locateusing(usingchar, target)) ...
.nf
‚ÄÉ
.fi
locate() a target substr in the whole unordered string using a given delimiter char returning true if found.
.RS
.nf

if ("AB,EF,CD"_var.locateusing(",", "EF")) ... ok
.fi
.RE


.SS
if (strvar.locateusing(usingchar, target, out setting, fieldno = 0, valueno = 0, subvalueno = 0)) ...
.nf
‚ÄÉ
.fi
locate() the target in a specific field, value or subvalue using a specified delimiter and unordered data

Returns: True If found and returns in setting the number of the delimited field found.

Returns: False if not found and returns in setting the maximum number of delimited fields + 1 if not found.

This is similar to the main locate command but the delimiter char can be specified e.g. a comma or TM etc.
.RS
.nf

var setting;
if ("f1^f2^f3c1,f3c2,f3c3^f4"_var.locateusing(",", "f3c2", setting, 3)) ... ok // setting -> 2 // returns true
.fi
.RE


.SS
if (strvar.locatebyusing(ordercode, usingchar, target, out setting, fieldno = 0, valueno = 0, subvalueno = 0)) ...
.nf
‚ÄÉ
.fi
locatebyusing() supports all the above features in a single function.

Returns: True if found.

.SH 10. DATABASE ACCESS
.SH

.SS
if (conn.connect(conninfo = "")) ...
.nf
‚ÄÉ
.fi
For all db operations, the operative var can either be a db connection created with dbconnect() or be any var and a default connection will be established on the fly.

The db connection string (conninfo) parameters are merged from the following places in descending priority.

1. Provided in connect()'s conninfo argument. See 4. for the complete list of parameters.

2. Any environment variables EXO_HOST EXO_PORT EXO_USER EXO_DATA EXO_PASS EXO_TIME

3. Any parameters found in a configuration file at ~/.config/exodus/exodus.cfg

4. The default conninfo is "host=127.0.0.1 port=5432 dbname=exodus user=exodus password=somesillysecret connect_timeout=10"

Setting environment variable EXO_DBTRACE=1 will cause tracing of db interface including SQL commands.
.RS
.nf

let conninfo = "dbname=exodus user=exodus password=somesillysecret";
if (not conn.connect(conninfo)) ...;
// or
if (not connect()) ...
// or
if (not connect("exodus")) ...
.fi
.RE


.SS
if (conn.attach(filenames)) ...
.nf
‚ÄÉ
.fi
Attach (connect) specific files by name to specific connections.

It is not necessary to attach files before opening them. Attach is meant to control the defaults.

For the remainder of the session, opening the db file by name without specifying a connection will automatically use the specified connection applies during the attach command.

If conn is not specified then filename will be attached to the default connection.

Multiple file names must be separated by FM
.RS
.nf

let filenames = "definitions^dict.definitions"_var, conn = "exodus";
if (conn.attach(filenames)) ... ok
// or
if (attach(filenames)) ... ok
.fi
.RE


.SS
conn.detach(filenames)
.nf
‚ÄÉ
.fi
Detach (disconnect) files that have been attached using attach().

.SS
if (conn.begintrans()) ...
.nf
‚ÄÉ
.fi
Begin a db transaction.
.RS
.nf

if (not conn.begintrans()) ...
// or
if (not begintrans()) ...
.fi
.RE


.SS
if (conn.statustrans()) ...
.nf
‚ÄÉ
.fi
Check if a db transaction is in progress.
.RS
.nf

if (conn.statustrans()) ... ok
// or
if (statustrans()) ... ok
.fi
.RE


.SS
if (conn.rollbacktrans()) ...
.nf
‚ÄÉ
.fi
Rollback a db transaction.
.RS
.nf

if (conn.rollbacktrans()) ... ok
// or
if (rollbacktrans()) ... ok
.fi
.RE


.SS
if (conn.committrans()) ...
.nf
‚ÄÉ
.fi
Commit a db transaction.

Returns: True if successfully committed or if there was no transaction in progress, otherwise false.
.RS
.nf

if (conn.committrans()) ... ok
// or
if (committrans()) ... ok
.fi
.RE


.SS
if (conn.sqlexec(sqlcmd)) ...
.nf
‚ÄÉ
.fi
Execute an sql command.

Returns: True if there was no sql error otherwise lasterror() returns a detailed error message.
.RS
.nf

if (conn.sqlexec("vacuum")) ... ok
// or
if (sqlexec("vacuum")) ... ok
.fi
.RE


.SS
if (conn.sqlexec(sqlcmd, io response)) ...
.nf
‚ÄÉ
.fi
Execute an SQL command and capture the response.

Returns: True if there was no sql error otherwise response contains a detailed error message.

response: Any rows and columns returned are separated by RM and FM respectively. The first row is the column names.

Recommended: Don't use sql directly unless you must to manage or configure a database.
.RS
.nf

let sqlcmd = "select 'xxx' as col1, 'yyy' as col2";
var response;
if (conn.sqlexec(sqlcmd, response)) ... ok // response -> "col1^col2\x1fxxx^yyy"_var /// \x1f is the Record Mark (RM) character. The backtick character is used here by gendoc to deliminate source code.
// or
if (sqlexec(sqlcmd, response)) ... ok
.fi
.RE


.SS
conn.disconnect()
.nf
‚ÄÉ
.fi
Closes db connection and frees process resources both locally and in the database server.
.RS
.nf

conn.disconnect();
// or
disconnect();
.fi
.RE


.SS
conn.disconnectall()
.nf
‚ÄÉ
.fi
Closes all connections and frees process resources both locally and in the database server(s).

All connections are closed automatically when a process terminates.
.RS
.nf

conn.disconnectall();
// or
disconnectall();
.fi
.RE


.SS
var v1 = conn.lasterror();
.nf
‚ÄÉ
.fi
Returns: The last os or db error message.
.RS
.nf

var v1 = var().lasterror();
// or
var v2 = lasterror();
.fi
.RE


.SS
var v1 = conn.loglasterror(source = "");
.nf
‚ÄÉ
.fi
Log the last os or db error message.

Output: to stdlog

Prefixes the output with source if provided.
.RS
.nf

var().loglasterror("main:");
// or
loglasterror("main:");
.fi
.RE


.SH 11. DATABASE MANAGEMENT
.SH

.SS
if (conn.dbcreate(new_dbname, old_dbname = "")) ...
.nf
‚ÄÉ
.fi
Create a named database on a particular connection.

The target database cannot already exist.

Optionally copies an existing database from the same connection and which cannot have any current connections.
.RS
.nf

var conn = "exodus";
if (not dbdelete("xo_gendoc_testdb")) {}; // Cleanup first
if (conn.dbcreate("xo_gendoc_testdb")) ... ok
// or
if (dbcreate("xo_gendoc_testdb")) ...
.fi
.RE


.SS
if (conn.dbcopy(from_dbname, to_dbname)) ...
.nf
‚ÄÉ
.fi
Create a named database as a copy of an existing database.

The target database cannot already exist.

The source database must exist on the same connection and cannot have any current connections.
.RS
.nf

var conn = "exodus";
if (not dbdelete("xo_gendoc_testdb2")) {}; // Cleanup first
if (conn.dbcopy("xo_gendoc_testdb", "xo_gendoc_testdb2")) ... ok
// or
if (dbcopy("xo_gendoc_testdb", "xo_gendoc_testdb2")) ...
.fi
.RE


.SS
var v1 = conn.dblist();
.nf
‚ÄÉ
.fi
Returns: A list of available databases on a particular connection.
.RS
.nf

let v1 = conn.dblist();
// or
let v2 = dblist();
.fi
.RE


.SS
if (conn.dbdelete(dbname)) ...
.nf
‚ÄÉ
.fi
Delete (drop) a named database.

The target database must exist and cannot have any current connections.
.RS
.nf

var conn = "exodus";
if (conn.dbdelete("xo_gendoc_testdb2")) ... ok
// or
if (dbdelete("xo_gendoc_testdb2")) ...
.fi
.RE


.SS
if (conn.createfile(filename)) ...
.nf
‚ÄÉ
.fi
Create a named db file.
.RS
.nf

let filename = "xo_gendoc_temp", conn = "exodus";
if (conn.createfile(filename)) ... ok
// or
if (createfile(filename)) ...
.fi
.RE


.SS
if (conn.renamefile(filename, newfilename)) ...
.nf
‚ÄÉ
.fi
Rename a db file.
.RS
.nf

let conn = "exodus", filename = "xo_gendoc_temp", new_filename = "xo_gendoc_temp2";
if (conn.renamefile(filename, new_filename)) ... ok
// or
if (renamefile(filename, new_filename)) ...
.fi
.RE


.SS
var v1 = conn.listfiles();
.nf
‚ÄÉ
.fi
Returns: A list of all files in a database
.RS
.nf

var conn = "exodus";
if (not conn.listfiles()) ...
// or
if (not listfiles()) ...
.fi
.RE


.SS
if (conn.clearfile(filename)) ...
.nf
‚ÄÉ
.fi
Delete all records in a db file
.RS
.nf

let conn = "exodus", filename = "xo_gendoc_temp2";
if (not conn.clearfile(filename)) ...
// or
if (not clearfile(filename)) ...
.fi
.RE


.SS
if (conn.deletefile(filename)) ...
.nf
‚ÄÉ
.fi
Delete a db file
.RS
.nf

let conn = "exodus", filename = "xo_gendoc_temp2";
if (conn.deletefile(filename)) ... ok
// or
if (deletefile(filename)) ...
.fi
.RE


.SS
var v1 = conn_or_file.reccount(filename = "");
.nf
‚ÄÉ
.fi
Returns: The approx. number of records in a db file
.RS
.nf

let conn = "exodus", filename = "xo_clients";
var nrecs1 = conn.reccount(filename);
// or
var nrecs2 = reccount(filename);
.fi
.RE


.SS
if (conn_or_file.flushindex(filename = "")) ...
.nf
‚ÄÉ
.fi
Calls db maintenance function (vacuum)

This doesnt actually flush any indexes but does make sure that reccount() function is reasonably accurate.

.SH 12. DATABASE FILE I/O
.SH

.SS
if (file.open(dbfilename, connection = "")) ...
.nf
‚ÄÉ
.fi
Opens a db file to a var which can be used in subsequent functions to work on the specified file and database connection.
.RS
.nf

var file, filename = "definitions";
if (not file.open(filename)) ...
// or
if (not open(filename to file)) ...
.fi
.RE


.SS
file.close()
.nf
‚ÄÉ
.fi
Closes db file var

Does nothing currently since database file vars consume no resources
.RS
.nf

var file = "definitions";
file.close();
// or
close(file);
.fi
.RE


.SS
if (file.createindex(fieldname, dictfile = "")) ...
.nf
‚ÄÉ
.fi
Creates a secondary index for a given db file and field name.

The fieldname must exist in a dictionary file. The default dictionary is "dict." ^ filename.

Returns: False if the index cannot be created for any reason.

* Index already exists

* File does not exist

* The dictionary file does not have a record with a key of the given field name.

* The dictionary file does not exist. Default is "dict." ^ filename.

* The dictionary field defines a calculated field that uses an exodus function. Using a psql function is OK.
.RS
.nf

var filename = "definitions", fieldname = "DATE_TIME";
if (not deleteindex("definitions", "DATE_TIME")) {}; // Cleanup first
if (filename.createindex(fieldname)) ... ok
// or
if (createindex(filename, fieldname)) ...
.fi
.RE


.SS
var v1 = file|conn.listindex(file_or_filename = "", fieldname = "");
.nf
‚ÄÉ
.fi
Lists secondary indexes in a database or for a db file

Returns: False if the db file or fieldname are given and do not exist
.RS
.nf

var conn = "exodus";
if (conn.listindex()) ... ok // includes "xo_clients__date_time"
// or
if (listindex()) ... ok
.fi
.RE


.SS
if (file.deleteindex(fieldname)) ...
.nf
‚ÄÉ
.fi
Deletes a secondary index for a db file and field name.

Returns: False if the index cannot be deleted for any reason

* File does not exist

* Index does not already exists
.RS
.nf

var file = "definitions", fieldname = "DATE_TIME";
if (file.deleteindex(fieldname)) ... ok
// or
if (deleteindex(file, fieldname)) ...
.fi
.RE


.SS
var v1 = file.lock(key);
.nf
‚ÄÉ
.fi
Places a metaphorical db lock on a particular record given a db file and key.

This is a advisory lock, not a physical lock, since it makes no restriction on the access or modification of data by other connections.

Neither the db file nor the record key need to actually exist since a lock is just a hash of the db file name and key combined.

If another connection attempts to place an identical lock on the same database it will be denied.

Locks can be removed by unlock() or unlockall() or will be automatically removed at the end of a transaction or when the connection is closed.

If the same process attempts to place an identical lock more than once it may be denied (if not in a transaction) or succeed but be ignored (if in a transaction).

Locks can be used to avoid processing a transaction simultaneously with another connection only to have one of them fail due to mutually updating the same records.

Returns::

* 0: Failure: Another connection has already placed the same lock.

* "" Failure: The lock has already been placed.

* 1: Success: A new lock has been placed.

* 2: Success: The lock has already been placed and the connection is in a transaction.
.RS
.nf

var file = "xo_clients", key = "1000";
if (file.lock(key)) ... ok
// or
if (lock(file, key)) ...
.fi
.RE


.SS
if (file.unlock(key)) ...
.nf
‚ÄÉ
.fi
Removes a db lock placed by the lock function.

Only locks placed on the specified connection can be removed.

Locks cannot be removed while a connection is in a transaction.

Returns: False if the lock is not present in a connection.
.RS
.nf

var file = "xo_clients", key = "1000";
if (file.unlock(key)) ... ok
// or
if (unlock(file, key)) ...
.fi
.RE


.SS
if (file.unlockall()) ...
.nf
‚ÄÉ
.fi
Removes all db locks placed by the lock function in the specified connection.

Locks cannot be removed while in a transaction.
.RS
.nf

var conn = "exodus";
if (not conn.unlockall()) ...
// or
if (not unlockall(conn)) ...
.fi
.RE


.SS
rec.write(file, key)
.nf
‚ÄÉ
.fi
Writes a record into a db file given a unique primary key.

Either inserts a new record or updates an existing record.

It always succeeds so no result code is returned.

Any memory cached record is deleted.
.RS
.nf

let rec = "Client GD^G^20855^30000^1001.00^20855.76539"_var;
let file = "xo_clients", key = "GD001";
if (not deleterecord("xo_clients", "GD001")) {}; // Cleanup first
rec.write(file, key);
// or
write(rec on file, key);
.fi
.RE


.SS
if (rec.read(file, key)) ...
.nf
‚ÄÉ
.fi
Reads a record from a db file for a given key.

Returns: False if the key doesnt exist
.RS
.nf

var rec;
let file = "xo_clients", key = "GD001";
if (not rec.read(file, key)) ... // rec -> "Client GD^G^20855^30000^1001.00^20855.76539"_var
// or
if (not read(rec from file, key)) ...
.fi
.RE


.SS
if (file.deleterecord(key)) ...
.nf
‚ÄÉ
.fi
Deletes a record from a db file given a key.

Returns: False if the key doesnt exist

Any memory cached record is deleted.
.RS
.nf

let file = "xo_clients", key = "GD001";
if (file.deleterecord(key)) ... ok
// or
if (deleterecord(file, key)) ...
.fi
.RE


.SS
if (rec.insertrecord(file, key)) ...
.nf
‚ÄÉ
.fi
Inserts a new record in a db file.

Returns: False if the key already exists

Any memory cached record is deleted.
.RS
.nf

let rec = "Client GD^G^20855^30000^1001.00^20855.76539"_var;
let file = "xo_clients", key = "GD001";
if (rec.insertrecord(file, key)) ... ok
// or
if (insertrecord(rec on file, key)) ...
.fi
.RE


.SS
if (rec.updaterecord(file, key)) ...
.nf
‚ÄÉ
.fi
Updates an existing record in a db file.

Returns: False if the key doesnt already exist

Any memory cached record is deleted.
.RS
.nf

let rec = "Client GD^G^20855^30000^1001.00^20855.76539"_var;
let file = "xo_clients", key = "GD001";
if (not rec.updaterecord(file, key)) ...
// or
if (not updaterecord(rec on file, key)) ...
.fi
.RE


.SS
if (strvar.readf(file, key, fieldno)) ...
.nf
‚ÄÉ
.fi
"Read field" Same as read() but only returns a specific field from the record
.RS
.nf

var field, file = "xo_clients", key = "GD001", fieldno = 2;
if (not field.readf(file, key, fieldno)) ... // field -> "G"
// or
if (not readf(field from file, key, fieldno)) ...
.fi
.RE


.SS
strvar.writef(file, key, fieldno)
.nf
‚ÄÉ
.fi
"write field" Same as write() but only writes to a specific field in the record
.RS
.nf

var field = "f3", file = "definitions", key = "1000", fieldno = 3;
field.writef(file, key, fieldno);
// or
writef(field on file, key, fieldno);
.fi
.RE


.SS
rec.writec(file, key)
.nf
‚ÄÉ
.fi
"Write cache" Writes a record and key into a memory cached "db file".

The actual file is NOT updated.

writec() either updates an existing cache record if the key already exists or otherwise inserts a new record into the cache.

It always succeeds so no result code is returned.

Neither the db file nor the record key need to actually exist in the actual db.
.RS
.nf

let rec = "Client XD^X^20855^30000^1001.00^20855.76539"_var;
let file = "xo_clients", key = "XD001";
rec.writec(file, key);
// or
writec(rec on file, key);
.fi
.RE


.SS
if (rec.readc(file, key)) ...
.nf
‚ÄÉ
.fi
"Read cache" Same as "read() but first reads from a memory cache.

1. Tries to read from a memory cache. Returns true if successful.

2a. Tries to read from the actual db file and returns false if unsuccessful.

2b. Writes the record and key to the memory cache and returns true.

Cached db file data lives in exodus process memory and is lost when the process terminates or cleardbcache() is called.
.RS
.nf

var rec;
let file = "xo_clients", key = "XD001";
if (rec.readc(file, key)) ... ok
// or
if (readc(rec from file, key)) ... ok

// Verify not in actual file by using read() not readc()
if (read(rec from file, key)) abort("Error: " ^ key ^ " should not be in the actual file"); // error
.fi
.RE


.SS
if (dbfile.deletec(key)) ...
.nf
‚ÄÉ
.fi
Deletes a record and key from a memory cached "file".

The actual file is NOT updated.

Returns: False if the key doesnt exist
.RS
.nf

var file = "xo_clients", key = "XD001";
if (file.deletec(key)) ... ok
// or
if (deletec(file, key)) ...
.fi
.RE


.SS
conn.cleardbcache()
.nf
‚ÄÉ
.fi
Clears the memory cache of all records for the given connection

All future cache readc() function calls will be forced to obtain records from the actual database and refresh the cache.
.RS
.nf

conn.cleardbcache();
// or
cleardbcache(conn);
.fi
.RE


.SS
var v1 = strvar.xlate(filename, fieldno, mode);
.nf
‚ÄÉ
.fi
The xlate ("translate") function is similar to readf() but, when called as an exodus program member function, it can be used efficiently with exodus file dictionaries using column names and functions and multivalued data.

Arguments:

str: Used as the primary key to lookup a field in a given file and field no or field name.

filename: The db file in which to look up data.

If var key is multivalued then a multivalued field is returned.

fieldno: Determines which field of the record is returned.

* Integer returns that field number

* 0 means return the key unchanged.

* "" means return the whole record.

mode: Determines what is returned if the record does not exist for the given key and file.

* "X" returns ""

* "C" returns the key unconverted.
.RS
.nf

let key = "SB001";
let client_name = key.xlate("xo_clients", 1, "X"); // "Client AAA"
// or
let name_and_type = xlate("xo_clients", key, "NAME_AND_TYPE", "X"); // "Client AAA (A)"
.fi
.RE


.SH 13. DATABASE SORT/SELECT
.SH

.SS
if (file.select(sortselectclause = "")) ...
.nf
‚ÄÉ
.fi


.SS
file.clearselect()
.nf
‚ÄÉ
.fi


.SS
if (file.hasnext()) ...
.nf
‚ÄÉ
.fi


.SS
if (file.readnext(out key)) ...
.nf
‚ÄÉ
.fi


.SS
if (file.readnext(out key, out valueno)) ...
.nf
‚ÄÉ
.fi


.SS
if (file.readnext(out record, out key, out valueno)) ...
.nf
‚ÄÉ
.fi


.SS
if (file.savelist(listname)) ...
.nf
‚ÄÉ
.fi


.SS
if (file.getlist(listname)) ...
.nf
‚ÄÉ
.fi


.SS
if (file.makelist(listname, keys)) ...
.nf
‚ÄÉ
.fi


.SS
if (file.deletelist(listname)) ...
.nf
‚ÄÉ
.fi


.SS
if (file.formlist(keys, fieldno = 0)) ...
.nf
‚ÄÉ
.fi


.SH 14. OS TIME/DATE
.SH

.SS
var v1 = var().date();
.nf
‚ÄÉ
.fi
Number of whole days since pick epoch 1967-12-31 00:00:00 UTC. Negative for dates before.

e.g. was 20821 from 2025-01-01 00:00:00 UTC for 24 hours
.RS
.nf

let today1 = var().date();
// or
let today2 = date();
.fi
.RE


.SS
var v1 = var().time();
.nf
‚ÄÉ
.fi
Number of whole seconds since last 00:00:00 (UTC).

e.g. 43200 if time is 12:00

Range 0 - 86399 since there are 24*60*60 (86400) seconds in a day.
.RS
.nf

let now1 = var().time();
// or
let now2 = time();
.fi
.RE


.SS
var v1 = var().ostime();
.nf
‚ÄÉ
.fi
Number of fractional seconds since last 00:00:00 (UTC).

A floating point with approx. nanosecond resolution depending on hardware.

e.g. 23343.704387955 approx. 06:29:03 UTC
.RS
.nf

let now1 = var().ostime();
// or
let now2 = ostime();
.fi
.RE


.SS
var v1 = var().timestamp();
.nf
‚ÄÉ
.fi
Number of fractional days since pick epoch 1967-12-31 00:00:00 UTC. Negative for dates before.

A floating point with approx. nanosecond resolution depending on hardware.

e.g. Was 20821.99998842593 around 2025-01-01 23:59:59 UTC
.RS
.nf

let now1 = var().timestamp();
// or
let now2 = timestamp();
.fi
.RE


.SS
var v1 = var().timestamp(ostime);
.nf
‚ÄÉ
.fi
Construct a timestamp from a date and time
.RS
.nf

let idate = iconv("2025-01-01", "D"), itime = iconv("23:59:59", "MT");
let ts1 = idate.timestamp(itime); // 20821.99998842593
// or
let ts2 = timestamp(idate, itime);
.fi
.RE


.SS
var().ossleep(milliseconds)
.nf
‚ÄÉ
.fi
Sleep/pause/wait for a number of milliseconds

Releases the processor if not needed for a period of time or a delay is required.
.RS
.nf

var().ossleep(500); // sleep for 500ms
// or
ossleep(500);
.fi
.RE


.SS
var v1 = file_dir_list.oswait(milliseconds);
.nf
‚ÄÉ
.fi
Sleep/pause/wait up to a given number of milliseconds or until any changes occur in an FM delimited list of directories and/or files.

Any terminal input (e.g. a key press) will also terminate the wait.

An FM array of event information is returned. See below.

Multiple events are returned in multivalues.
.RS
.nf

let v1 = ".^/etc/hosts"_var.oswait(500); /// e.g. "IN_CLOSE_WRITE^/etc^hosts^f"_var
// or
let v2 = oswait(".^/etc/hosts"_var, 500);
.fi
.RE

Returned array fields

1. Event type codes

2. dirpaths

3. filenames

4. d=dir, f=file



Possible event type codes are as follows:

* IN_CLOSE_WRITE - A file opened for writing was closed

* IN_ACCESS - Data was read from file

* IN_MODIFY - Data was written to file

* IN_ATTRIB - File attributes changed

* IN_CLOSE - File was closed (read or write)

* IN_MOVED_FROM - File was moved away from watched directory

* IN_MOVED_TO - File was moved into watched directory

* IN_MOVE - File was moved (in or out of directory)

* IN_CREATE - A file was created in the directory

* IN_DELETE - A file was deleted from the directory

* IN_DELETE_SELF - Directory or file under observation was deleted

* IN_MOVE_SELF - Directory or file under observation was moved

.SH 15. OS FILE I/O
.SH

.SS
if (osfilevar.osopen(osfilename, utf8 = true)) ...
.nf
‚ÄÉ
.fi
Given the name of an existing os file name including path, initialises an os file handle var that can be used in random access osbread and osbwrite functions.

The utf8 option defaults to true which causes trimming of partial utf-8 unicode byte sequences from the end of osbreads. For raw untrimmed osbreads pass utf8 = false;

File will be opened for writing if possible otherwise for reading.

Returns: True if successful or false if not possible for any reason.

e.g. Target doesnt exist, permissions etc.
.RS
.nf

let osfilename = ostempdirpath() ^ "xo_gendoc_test.conf";
if (oswrite("" on osfilename)) ... ok /// Create an empty os file
var ostempfile;
if (ostempfile.osopen(osfilename)) ... ok
// or
if (osopen(osfilename to ostempfile)) ... ok
.fi
.RE


.SS
if (osfilevar.osbwrite(osfilevar, io offset)) ...
.nf
‚ÄÉ
.fi
Writes data to an existing os file starting at a given byte offset (0 based).

See osbread for more info.
.RS
.nf

let osfilename = ostempdirpath() ^ "xo_gendoc_test.conf";
let text = "aaa=123\nbbb=456\n";
var offset = osfile(osfilename).f(1); /// Size of file therefore append
if (text.osbwrite(osfilename, offset)) ... ok // offset -> 16
// or
if (not osbwrite(text on osfilename, offset)) ...
.fi
.RE


.SS
if (osfilevar.osbread(osfilevar, io offset, length)) ...
.nf
‚ÄÉ
.fi
Reads length bytes from an existing os file starting at a given byte offset (0 based).

The osfilevar file handle may either be initialised by osopen or be just be a normal string variable holding the path and name of the os file.

After reading, the offset is updated to point to the correct offset for a subsequent sequential read.

If reading utf8 data (the default) then the length of data actually returned may be a few bytes shorter than requested in order to be a complete number of UTF-8 code points.
.RS
.nf

let osfilename = ostempdirpath() ^ "xo_gendoc_test.conf";
var text, offset = 0;
if (text.osbread(osfilename, offset, 8)) ... ok // text -> "aaa=123\n" // offset -> 8
// or
if (osbread(text from osfilename, offset, 8)) ... ok // text -> "bbb=456\n" // offset -> 16
.fi
.RE


.SS
osfilevar.osclose()
.nf
‚ÄÉ
.fi
Removes an osfilevar handle from the internal memory cache of os file handles. This frees up both exodus process memory and operating system resources.

It is advisable to osclose any file handles after use, regardless of whether they were specifically opened using osopen or not, especially in long running programs. Exodus performs caching of internal os file handles per thread and os file. If not closed, then the operating system will probably not flush deleted files from storage until the process is terminated. This can potentially create an memory issue or file system resource issue especially if osopening/osreading/oswriting many perhaps temporary files in a long running process.
.RS
.nf

osfilevar.osclose();
// or
osclose(osfilevar);
.fi
.RE


.SS
if (strvar.oswrite(osfilename, codepage = "")) ...
.nf
‚ÄÉ
.fi
Create a complete os file from a var.

Any existing os file is removed first.

Returns: True if successful or false if not possible for any reason.

e.g. Path is not writeable, permissions etc.

If codepage is specified then output is converted from utf-8 to that codepage. Otherwise no conversion is done.
.RS
.nf

let text = "aaa = 123\nbbb = 456";
let osfilename = ostempdirpath() ^ "xo_gendoc_test.conf";
if (text.oswrite(osfilename)) ... ok
// or
if (oswrite(text on osfilename)) ... ok
.fi
.RE


.SS
if (strvar.osread(osfilename, codepage = "")) ...
.nf
‚ÄÉ
.fi
Read a complete os file into a var.

If codepage is specified then input is converted from that codepage to utf-8 otherwise no conversion is done.

Returns: True if successful or false if not possible for any reason.

e.g. File doesnt exist, permissions etc.
.RS
.nf

var text;
let osfilename = ostempdirpath() ^ "xo_gendoc_test.conf";
if (text.osread(osfilename)) ... ok // text -> "aaa = 123\nbbb = 456"
// or
if (osread(text from osfilename)) ... ok
.fi
.RE


.SS
if (osfile_or_dirname.osrename(new_dirpath_or_filepath)) ...
.nf
‚ÄÉ
.fi
Renames an os file or dir in the OS file system.

Will not overwrite an existing os file or dir.

Source and target must exist in the same storage device.

Returns: True if successful or false if not possible for any reason.

e.g. Target already exists, path is not writeable, permissions etc.

Uses std::filesystem::rename internally.
.RS
.nf

let from_osfilename = ostempdirpath() ^ "xo_gendoc_test.conf";
let to_osfilename = from_osfilename ^ ".bak";
if (not osremove(ostempdirpath() ^ "xo_gendoc_test.conf.bak")) {}; // Cleanup first

if (from_osfilename.osrename(to_osfilename)) ... ok
// or
if (osrename(from_osfilename, to_osfilename)) ...
.fi
.RE


.SS
if (osfile_or_dirname.osmove(to_osfilename)) ...
.nf
‚ÄÉ
.fi
"Moves" an os file or dir within the os file system.

Will not overwrite an existing os file or dir.

Returns: True if successful or false if not possible for any reason.

e.g. Source doesnt exist or cannot be accessed, target already exists, source or target is not writeable, permissions etc.

Attempts osrename first then oscopy followed by osremove original.
.RS
.nf

let from_osfilename = ostempdirpath() ^ "xo_gendoc_test.conf.bak";
let to_osfilename = from_osfilename.cut(-4);

if (not osremove(ostempdirpath() ^ "xo_gendoc_test.conf")) {}; // Cleanup first
if (from_osfilename.osmove(to_osfilename)) ... ok
// or
if (osmove(from_osfilename, to_osfilename)) ...
.fi
.RE


.SS
if (osfile_or_dirname.oscopy(to_osfilename)) ...
.nf
‚ÄÉ
.fi
Copies an os file or directory recursively within the os file system.

Will overwrite an existing os file or dir.

Uses std::filesystem::copy internally with recursive and overwrite options
.RS
.nf

let from_osfilename = ostempdirpath() ^ "xo_gendoc_test.conf";
let to_osfilename = from_osfilename ^ ".bak";

if (from_osfilename.oscopy(to_osfilename)) ... ok;
// or
if (oscopy(from_osfilename, to_osfilename)) ... ok
.fi
.RE


.SS
if (osfilename.osremove()) ...
.nf
‚ÄÉ
.fi
Removes/deletes an os file from the OS file system given path and name.

Will not remove directories. Use osrmdir() to remove directories

Returns: True if successful or false if not possible for any reason.

e.g. Target doesnt exist, path is not writeable, permissions etc.
.RS
.nf

let osfilename = ostempdirpath() ^ "xo_gendoc_test.conf";
if (osfilename.osremove()) ... ok
// or
if (osremove(osfilename)) ...
.fi
.RE


.SH 16. OS DIRECTORIES
.SH

.SS
var v1 = dirpath.oslist(globpattern = "", mode = 0);
.nf
‚ÄÉ
.fi
Returns: A FM delimited string containing all matching dir entries given a dir path

A glob pattern (e.g. *.conf) can be appended to the path or passed as argument.
.RS
.nf

var entries1 = "/etc/"_var.oslist("*.cfg"); /// e.g. "adduser.conf^ca-certificates.con^... etc."
// or
var entries2 = oslist("/etc/" "*.conf");
.fi
.RE


.SS
var v1 = dirpath.oslistf(globpattern = "");
.nf
‚ÄÉ
.fi
Same as oslist for files only

.SS
var v1 = dirpath.oslistd(globpattern = "");
.nf
‚ÄÉ
.fi
Same as oslist for files only

.SS
var v1 = osfile_or_dirpath.osinfo(mode = 0);
.nf
‚ÄÉ
.fi
Returns: Dir info for any dir entry or "" if it doesnt exist

A short string containing size ^ FM ^ modified_time ^ FM ^ modified_time

mode 0 default

mode 1 returns "" if not an os file

mode 2 returns "" if not an os dir

See also osfile() and osdir()
.RS
.nf

var info1 = "/etc/hosts"_var.osinfo(); /// e.g. "221^20597^78309"_var
// or
var info2 = osinfo("/etc/hosts");
.fi
.RE


.SS
var v1 = osfilename.osfile();
.nf
‚ÄÉ
.fi
Returns: Dir info for a os file

A short string containing size ^ FM ^ modified_time ^ FM ^ modified_time

Alias for osinfo(1)
.RS
.nf

var fileinfo1 = "/etc/hosts"_var.osfile(); /// e.g. "221^20597^78309"_var
// or
var fileinfo2 = osfile("/etc/hosts");
.fi
.RE


.SS
var v1 = dirpath.osdir();
.nf
‚ÄÉ
.fi
Returns: Dir info for a dir.

A short string containing FM ^ modified_time ^ FM ^ modified_time

Alias for osinfo(2)
.RS
.nf

var dirinfo1 = "/etc/"_var.osdir(); /// e.g. "^20848^44464"_var
// or
var dirinfo2 = osfile("/etc/");
.fi
.RE


.SS
if (dirpath.osmkdir()) ...
.nf
‚ÄÉ
.fi
Makes a new directory and returns true if successful.

Including parent dirs if necessary.
.RS
.nf

let osdirname = "xo_test/aaa";
if (osrmdir("xo_test/aaa")) {}; // Cleanup first
if (osdirname.osmkdir()) ... ok
// or
if (osmkdir(osdirname)) ...
.fi
.RE


.SS
if (dirpath.oscwd(newpath)) ...
.nf
‚ÄÉ
.fi
Changes the current working dir and returns true if successful.
.RS
.nf

let osdirname = "xo_test/aaa";
if (osdirname.oscwd()) ... ok
// or
if (oscwd(osdirname)) ... ok
.fi
.RE


.SS
var v1 = dirpath.oscwd();
.nf
‚ÄÉ
.fi
Returns: The current working directory

e.g. "/root/exodus/cli/src/xo_test/aaa"
.RS
.nf

var cwd1 = var().oscwd();
// or
var cwd2 = oscwd();
.fi
.RE


.SS
if (dirpath.osrmdir(evenifnotempty = false)) ...
.nf
‚ÄÉ
.fi
Removes a os dir and returns true if successful.

Optionally even if not empty. Including subdirs.
.RS
.nf

let osdirname = "xo_test/aaa";
if (oscwd("../..")) ... ok /// Change up before removing because cannot remove dir while it is current
if (osdirname.osrmdir()) ... ok
// or
if (osrmdir(osdirname)) ...
.fi
.RE


.SH 17. OS SHELL/ENVIRONMENT
.SH

.SS
if (command.osshell()) ...
.nf
‚ÄÉ
.fi
Execute a shell command.

Returns: True if the process terminates with error status 0 and false otherwise.

Append "&>/dev/null" to the command to suppress terminal output.
.RS
.nf

let cmd = "echo $HOME";
if (cmd.osshell()) ... ok
// or
if (osshell(cmd)) ... ok
.fi
.RE


.SS
if (instr.osshellread(oscmd)) ...
.nf
‚ÄÉ
.fi
Same as osshell but captures and returns stdout

Returns: The stout of the shell command.

Append "2>&1" to the command to capture stderr/stdlog output as well.
.RS
.nf

let cmd = "echo $HOME";
var text;
if (text.osshellread(cmd)) ... ok

// or capturing stdout but ignoring exit status
text = osshellread(cmd);
.fi
.RE


.SS
if (outstr.osshellwrite(oscmd)) ...
.nf
‚ÄÉ
.fi
Same as osshell but provides stdin to the process

Returns: True if the process terminates with error status 0 and false otherwise.

Append "&> somefile" to the command to suppress and/or capture output.
.RS
.nf

let outtext = "abc xyz";
if (outtext.osshellwrite("grep xyz")) ... ok
// or
if (osshellwrite(outtext, "grep xyz")) ... ok
.fi
.RE


.SS
var v1 = var().ostempdirpath();
.nf
‚ÄÉ
.fi
Returns: The path of the tmp dir

e.g. "/tmp/"
.RS
.nf

let v1 = var().ostempdirpath();
// or
let v2 = ostempdirpath();
.fi
.RE


.SS
var v1 = var().ostempfilename();
.nf
‚ÄÉ
.fi
Returns: The name of a new temporary file

e.g. Something like "/tmp/~exoEcLj3C"
.RS
.nf

var temposfilename1 = var().ostempfilename();
// or
var temposfilename2 = ostempfilename();
.fi
.RE


.SS
envvalue.ossetenv(envcode)
.nf
‚ÄÉ
.fi
Set the value of an environment variable code
.RS
.nf

let envcode = "EXO_ABC", envvalue = "XYZ";
envvalue.ossetenv(envcode);
// or
ossetenv(envcode, envvalue);
.fi
.RE


.SS
if (envvalue.osgetenv(envcode)) ...
.nf
‚ÄÉ
.fi
Get the value of an environment variable
.RS
.nf

var envvalue1;
if (envvalue1.osgetenv("HOME")) ... ok // e.g. "/home/exodus"
// or
var envvalue2 = osgetenv("EXO_ABC"); // "XYZ"
.fi
.RE


.SS
var v1 = var().ospid();
.nf
‚ÄÉ
.fi
Get the os process id
.RS
.nf

let pid1 = var().ospid(); /// e.g. 663237
// or
let pid2 = ospid();
.fi
.RE


.SS
var v1 = var().ostid();
.nf
‚ÄÉ
.fi
Get the os thread process id
.RS
.nf

let tid1 = var().ostid(); /// e.g. 663237
// or
let tid2 = ostid();
.fi
.RE


.SS
var v1 = var().version();
.nf
‚ÄÉ
.fi
Get the libexodus build date and time
.RS
.nf

let v1 = var().version(); /// e.g. "29 JAN 2025 14:56:52"
.fi
.RE


.SS
if (strvar.setxlocale()) ...
.nf
‚ÄÉ
.fi
Sets the current thread's default locale codepage code

True if successful
.RS
.nf

if ("en_US.utf8"_var.setxlocale()) ... ok
// or
if (setxlocale("en_US.utf8")) ... ok
.fi
.RE


.SS
var v1 = var.getxlocale();
.nf
‚ÄÉ
.fi
Returns: The current thread's default locale codepage code
.RS
.nf

let v1 = var().getxlocale(); // "en_US.utf8"
// or
let v2 = getxlocale();
.fi
.RE


.SH 18. OUTPUT
.SH

.SS
var.output()
.nf
‚ÄÉ
.fi
To stdout. No new line. Buffered.

.SS
var.outputl()
.nf
‚ÄÉ
.fi
To stdout. Starts a new line. Flushed.

.SS
var.outputt()
.nf
‚ÄÉ
.fi
To stdout. Adds a tab. Buffered.

.SS
var.logput()
.nf
‚ÄÉ
.fi
To stdlog. No new line. Buffered.

.SS
var.logputl()
.nf
‚ÄÉ
.fi
To stdlog. Starts a new line. Flushed.

.SS
var.errput()
.nf
‚ÄÉ
.fi
To stderr. No new line. Flushed.

.SS
var.errputl()
.nf
‚ÄÉ
.fi
To stderr. Starts a new line. Flushed.

.SS
var.output(prefix)
.nf
‚ÄÉ
.fi
To stdout. With a prefix. No new line. Buffered.

.SS
var.outputl(prefix)
.nf
‚ÄÉ
.fi
To stdout. With a prefix. Starts a new line. Flushed.

.SS
var.outputt(prefix)
.nf
‚ÄÉ
.fi
To stdout. With a prefix. Adds a tab. Buffered.

.SS
var.logput(prefix)
.nf
‚ÄÉ
.fi
To stdlog. With a prefix. No new line. Buffered.

.SS
var.logputl(prefix)
.nf
‚ÄÉ
.fi
To stdlog. With a prefix. Starts a new line. Flushed.

.SS
var.errput(prefix)
.nf
‚ÄÉ
.fi
To stderr. With a prefix. No new line. Flushed.

.SS
var.errputl(prefix)
.nf
‚ÄÉ
.fi
To stderr. With a prefix. Starts a new line. Flushed.

.SS
var.put(std::ostream& ostream1)
.nf
‚ÄÉ
.fi
Output to a given stream

.SS
var().osflush()
.nf
‚ÄÉ
.fi
Flushes any buffered output to stdout/cout
.RS
.nf

var().osflush();
// or
osflush();
.fi
.RE


.SH 19. INPUT
.SH

.SS
var.input()
.nf
‚ÄÉ
.fi
Wait for stdin until cr or eof

.SS
var.input(prompt)
.nf
‚ÄÉ
.fi
Ditto after outputting prompt to stdout

.SS
var.inputn(nchars)
.nf
‚ÄÉ
.fi
Wait for nbytes from stdin

.SS
if (var.isterminal()) ...
.nf
‚ÄÉ
.fi
True if terminal is available

.SS
if (var.hasinput(milliseconds = 0)) ...
.nf
‚ÄÉ
.fi
True if stdin bytes available within milliseconds

.SS
if (var.eof()) ...
.nf
‚ÄÉ
.fi
True if stdin is at end of file

.SS
if (var.echo(on_off)) ...
.nf
‚ÄÉ
.fi
Reflect all stdin to stdout if terminal available

.SS
var.breakon()
.nf
‚ÄÉ
.fi
Allow interrupt Ctrl+C

.SS
var.breakoff()
.nf
‚ÄÉ
.fi
Prevent interrupt Ctr+C

.SH 20. MATH/BOOLEAN
.SH

.SS
var v1 = num.abs();
.nf
‚ÄÉ
.fi
Absolute value
.RS
.nf

let v1 = var(-12.34).abs(); // 12.34
// or
let v2 = abs(-12.34);
.fi
.RE


.SS
var v1 = num.pwr(exponent);
.nf
‚ÄÉ
.fi
Power
.RS
.nf

let v1 = var(2).pwr(8); // 256
// or
let v2 = pwr(2, 8);
.fi
.RE


.SS
num.initrnd()
.nf
‚ÄÉ
.fi
Initialise the seed for rnd()

Allows the stream of pseudo random numbers generated by rnd() to be reproduced.

Seeded from std::chrono::high_resolution_clock::now() if the argument is 0;
.RS
.nf

var(123).initrnd(); /// Set seed to 123
// or
initrnd(123);
.fi
.RE


.SS
var v1 = num.rnd();
.nf
‚ÄÉ
.fi
Pseudo random number generator

Returns: a pseudo random integer between 0 and the provided maximum minus 1.

Uses std::mt19937 and std::uniform_int_distribution<int>
.RS
.nf

let v1 = var(100).rnd().outputl();
// or
let v2 = rnd(100);
.fi
.RE


.SS
var v1 = num.exp();
.nf
‚ÄÉ
.fi
Power of e
.RS
.nf

let v1 = var(1).exp(); // 2.718281828459045
// or
let v2 = exp(1);
.fi
.RE


.SS
var v1 = num.sqrt();
.nf
‚ÄÉ
.fi
Square root
.RS
.nf

let v1 = var(100).sqrt(); // 10
// or
let v2 = sqrt(100);
.fi
.RE


.SS
var v1 = num.sin();
.nf
‚ÄÉ
.fi
Sine of degrees
.RS
.nf

let v1 = var(30).sin(); // 0.5
// or
let v2 = sin(30);
.fi
.RE


.SS
var v1 = num.cos();
.nf
‚ÄÉ
.fi
Cosine of degrees
.RS
.nf

let v1 = var(60).cos(); // 0.5
// or
let v2 = cos(60);
.fi
.RE


.SS
var v1 = num.tan();
.nf
‚ÄÉ
.fi
Tangent of degrees
.RS
.nf

let v1 = var(45).tan(); // 1
// or
let v2 = tan(45);
.fi
.RE


.SS
var v1 = num.atan();
.nf
‚ÄÉ
.fi
Arctangent of degrees
.RS
.nf

let v1 = var(1).atan(); // 45
// or
let v2 = atan(1);
.fi
.RE


.SS
var v1 = num.loge();
.nf
‚ÄÉ
.fi
Natural logarithm

Returns: Floating point ver (double)
.RS
.nf

let v1 = var(2.718281828459045).loge(); // 1
// or
let v2 = loge(2.718281828459045);
.fi
.RE


.SS
var v1 = num.integer();
.nf
‚ÄÉ
.fi
Truncate decimal numbers towards zero

Returns: A var integer
.RS
.nf

let v1 = var(2.9).integer(); // 2
// or
let v2 = integer(2.9);

var v3 = var(-2.9).integer(); // -2
// or
var v4 = integer(-2.9);
.fi
.RE


.SS
var v1 = num.floor();
.nf
‚ÄÉ
.fi
Truncate decimal numbers towards negative

Returns: A var integer
.RS
.nf

let v1 = var(2.9).floor(); // 2
// or
let v2 = floor(2.9);

var v3 = var(-2.9).floor(); // -3
// or
var v4 = floor(-2.9);
.fi
.RE


.SS
var v1 = num.mod(modulus);
.nf
‚ÄÉ
.fi
Modulus function

Identical to C++ % operator only for positive numbers and modulus

Negative denominators are considered as periodic with positiive numbers

Result is between [0, modulus) if modulus is positive

Result is between (modulus, 0] if modulus is negative (symmetric)

Throws: VarDivideByZero if modulus is zero.

Floating point works.
.RS
.nf

let v1 = var(11).mod(5); // 1
// or
let v2 = mod(11, 5); // 1
let v3 = mod(-11, 5); // 4
let v4 = mod(11, -5); // -4
let v5 = mod(-11, -5); // -1
.fi
.RE



