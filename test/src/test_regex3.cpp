/* C++ syntax highlighting RDSN/CM/AP excluded from keyword replacing

Patterns used:

R (Raw Strings): (R"([^\(\)\s]{0,16})\(.*?\)\2")     - Supports empty delimiters and quad quotes (e.g., R""(xxx)"", R""""(xxx)""yyyyyyyy)"""").
D (Double-Quoted Strings): ("(?:[^"\\]|\\.)*")       - Matches strings like "hello" and "he\"llo".
S (Single-Quoted Characters): ('(?:[^'\\]|\\.)*')    - Matches character literals like 'a' and '\n'.
N (Numeric Literals): (\b(?:0x[0-9a-fA-F]+|0b[01]+|0[0-7]+|(?:\d*\.\d+|\d+\.)(?:[eE][+-]?\d+)?(?:[fFlL])?|\d+[eE][+-]?\d+(?:[fFlL])?|\d+(?:[uU](?:ll|LL|[lL])?|[lL](?:[lL]|[uU])?|[uU])?)\b)
                                                     - Matches integers, floating-point, and exponential numbers as single units.
C (Single-Line Comments): (//[^\n]*)                 - Matches single-line comments, taking precedence over multiline comments.
M (Multiline Comments): (/\*(?:(?!\*\/).)*(\*\/)?)   - Matches multiline comments, including unclosed ones to the end of input.
A (Attributes): (\[\[[^\]]*?\]\])                    - Matches attributes like [[nodiscard]].
P (Preprocessor Directives): (^\s*#[^\n]*(?=\n|$))   - Matches preprocessor directives at the start of a line.
*/

#include <exodus/program.h>
programinit()

function main() {

	// Self test
	if (not COMMAND.f(2)) {

		if (not oswrite(test_text_inp on "t_regex3_inp.txt")) loglasterror();
		if (not oswrite(test_text_exp on "t_regex3_exp.txt")) loglasterror();

		// Test a few hard letters only
		var allwords_pat = R"__(\be\b|\bR\b|\bhpp\b)__";

		// Convert
		var test_text_act = highlight_cpp_syntax(test_text_inp, allwords_pat);

		if (not oswrite(test_text_act on "t_regex3_act.txt")) loglasterror();
		printl(elapsedtimetext());

		// Verify
		if (test_text_act ne test_text_exp)
			abort("Test failed");

		// Confirm
		stop("Test passed.");

	}

	// Get cpp text
	if (not osread(RECORD from COMMAND.f(2)))
		abort(lasterror());

	// Convert and output
	printx(highlight_cpp_syntax(RECORD));

    return 0;
}

function get_exodus_keywords() {
	return osread(osgetenv("EXO_HOME") ?: osgetenv("HOME") ^ "/exodus/exodus/libexodus/exodus/keywords.txt");
}


function highlight_cpp_syntax(in text) {
	var allwords_pat = "";
	return highlight_cpp_syntax(text, allwords_pat);
}

function highlight_cpp_syntax(in text, io allwords_pat) {

	// Returns text with html spans added.

	allwords_pat.defaulter("");

	// Get latest exodus keywords
	if (not allwords_pat) {

		//	// Wrap keywords lambda
		//	// e.g. "<span class=exo>e</span>"
		//	auto wrapkeywords = [](in code) -> var {
		//		rex allwords_rex(R"__(\be\b|\bR\b|\bhpp\b)__");
		//		return code.replace(allwords_rex, "<span class=exo>$&</span>");
		//	};

		// Get keywords.txt
		// Generated by exodus keywords.sh
		//
		//'var', '_var', 'BASEFMT', 'BS', 'CVR', 'Callable', 'DATEFMT', 'DQ',
		//'DimIndexOutOfBounds', 'DimUndimensioned', 'EOL', 'ExoAbort', 'ExoAbortAll',
		//'ExoCommon', 'ExoEnv', 'ExoStop', 'ExoProgram', 'ExoStop', 'FM', 'NL',
		var allwords = get_exodus_keywords();
		if (not allwords)
			loglasterror();

		// Clean up all words
		allwords.fieldstorer("\n", 1, 1, "");
		allwords.converter("',\n", "   ");
		allwords.trimmer();
		allwords = allwords.convert(" ", _FM).sort().unique().convert(_FM, " ");

		// Make realwords
		var realwords =
			"func function "
			"call gosub "
			"subr subroutine "
			"var _var "
			"rex _rex "
			"dim _dim "
			"let in io out "
			"eq ne lt gt ge le "
			"not and or "
		;
		let realwords_pat = realwords.trim().replace(" ", "\\b|\\b").prefix("\\b").append("\\b");
		rex realwords_rex = rex(realwords_pat);

		// Remove real words from allwords
		allwords.replacer(realwords_rex, "");

		// get capwords
		rex capwords_rex = "\\b[A-Z_][a-zA-Z0-9_]*"_rex;
		var capwords = allwords.match(capwords_rex).convert(_FM, " ");
		var capwords_pat = capwords.replace(" ", "\\b|\\b").prefix("\\b").append("\\b");

		// Remove capwords from allwords
		allwords.replacer(capwords_rex, "");
		allwords.trimmer();

		// force the remaining allwords to be functions like \b(abs|mod|int)(?=\()
		allwords_pat = "\\b(" ^ allwords.replace(" ", "|") ^ ")(?=\\()";
	//	TRACE(allwords)

		// add capwords
		allwords_pat.prefixer(capwords_pat ^ "|");
	//	TRACE(capwords_pat)

		// add realwords
		allwords_pat.prefixer(realwords_pat ^ "|");
	//	TRACE(realwords_pat)

	}

//	rex allwords_rex(R"__(\be\b|\bR\b|\bhpp\b)__");
	rex allwords_rex(allwords_pat);

	return doit(text, allwords_rex);

}

function doit(in text, const rex& allwords_rex) {

	var result = "";

	rex cpp_data_rex = rex(cpp_data_pat);

	// Data matches
	var pos1 = 1;
	var lastpos1 = 1;
	for (;;) {

		// Get the next data match or break
		var smatch = text.search(cpp_data_rex, pos1);
		if (not smatch)
			break;

		var datamatched = smatch.f(1, 1);

		// Replace keywords in unmatched and append.
		// Duplicated after loop.
		{
			var nunmatched = pos1 - lastpos1 - len(datamatched);
			var unmatched = text.substr(lastpos1, nunmatched);
			result ^= unmatched.replace(allwords_rex, "<span class=exo>$&</span>");
		}

		// Add matched unconvertible literals, comments, attributes, declarations
		// Group 1 has two groups
		// All groups have a delimiter group separating them
		// 1. First groups are all literals
		// 2. Two groups are comments
		// 3. Two groups are attributes and preprocessor
		var ngroups = smatch.trimlast(_VM).count(_VM);
		result ^= "<span class=exo" ^ ngroups ^ ">" ^ datamatched ^ "</span>";

		lastpos1 = pos1;
	}

	// Replace keywords in any remaining unmatched tail end.
	// Duplicated in loop.
	result ^= text.substr(lastpos1).replace(allwords_rex, "<span class=exo>$&</span>");

	return result;
}

var cpp_data_pat =

	// 1, 2, 3, 4 are literals
	// 5, 6 are comments
	// 7 and 8 are attributes and preprocessor
	// There are more than one regex groups in some of the logical "groups"

	// Group 1 R"   - CAUTION THERE IS A BACKREFERENCE TO A GROUP IN THIS PATTERN
	R"__((R"([a-zA-Z0-9_+\-*/=<>\!@#$%^&|~:;,.?'\[\]{}]{0,16})\(.*?\)\2"))__"
                                                            // R: Raw strings like R"delim(content)delim"
	R"__(|)__"

	// Group 2 "
	R"__(("(?:[^"\\]|\\.)*"))__"                            // D: Double-quoted strings like "hello" or "he\"llo"
	R"__(|)__"

	// Group 3 '
	R"__(('(?:[^'\\]|\\.)*'))__"                            // S: Single-quoted chars like 'a' or '\n'
	R"__(|)__"

	// Group 4 0
//	R"__((\b(?:(?:0x[0-9a-fA-F]+|0b[01]+|0[0-7]+|[1-9][0-9]*)(?:[uU](?:ll|LL|[lL])?|[lL](?:[lL]|[uU])?|[uU])?|\d*\.\d+(?:[eE][+-]?\d+)?(?:[fFlL])?|\d+[eE][+-]?\d+(?:[fFlL])?)\b))__"                          // N: Numeric literals (complete)
//	R"__((\b(?:0x[0-9a-fA-F]+|0b[01]+|0[0-7]+|(?:\d*\.\d+|\d+\.)(?:[eE][+-]?\d+)?(?:[fFlL])?|\d+[eE][+-]?\d+(?:[fFlL])?|\d+(?:[uU](?:ll|LL|[lL])?|[lL](?:[lL]|[uU])?|[uU])?)\b))__"
	R"__((\b(?:0x[0-9a-fA-F](?:'?[0-9a-fA-F])*|)__" // Hexadecimal literals (e.g., 0xFF'00)

	R"__(0b[01](?:'?[01])*|)__"                     // Binary literals (e.g., 0b101'010)

	R"__(0[0-7](?:'?[0-7])*|)__"                    // Octal literals (e.g., 077'7)

	R"__((?:(?:\d(?:'?\d)*)?\.\d(?:'?\d)*|)__"      // Floating-point literals (e.g., 12.34'56, .5, 1.2e+3'00)
	R"__(\d(?:'?\d)*(?:\.\d(?:'?\d)*)?))__"
	R"__((?:[eE][+-]?\d(?:'?\d)*)?(?:[fFlL])?|)__"

	R"__(\d(?:'?\d)*)__"
	R"__([eE][+-]?\d(?:'?\d)*(?:[fFlL])?|)__"       // Exponential literals without decimal point (e.g., 1'000e+3'00)

	R"__(\d(?:'?\d)*)__"                            // Integer literals with optional suffixes (e.g., 1'000'000u)
	R"__((?:[uU](?:ll|LL|[lL])?|[lL](?:[lL]|[uU])?|[uU])?)\b))__"

	R"__(|)__"

	// Group 5 //
	R"__((//[^\n]*))__"                                     // C: Single-line comments like // comment
	R"__(|)__"

	// Group 6 / *
	R"__((/\*(?:(?!\*/).)*(\*/)?))__"                       // M: Multiline comments like /* comment */
	R"__(|)__"

	// Group 7 [[
	R"__((\[\[[^\]]*?\]\]))__"                              // A: Attributes like [[nodiscard]]
	R"__(|)__"

	// Group 8 #
	R"__(((^|\n)\s*#[^\n]*(?=\n|$)))__"                     // P: Preprocessor like #include, with indentation
;

var css =

R"__(/* custom-theme.css */
.exocpp {
    display: block;
    overflow-x: auto;
    padding: 0.5em;
    background: #ffffff; /* White background */
    color: #000000; /* Black text for non-highlighted code */
}

/* Keywords (both C++ and custom) in bold green */
.exocpp-keyword {
    color: #008000; /* Green */
    font-weight: bold;
}

/* Optional: Style other elements for contrast */
.exocpp-string {
    color: #a31515; /* Red for strings */
}

.exocpp-number {
    color: #0000ff; /* Blue for numbers */
}

.exocpp-comment {
    color: #008080; /* Teal for comments */
})__";

var test_text_inp =

	"auto e = \"e\"; /" "/ e R \n" // sl comment
    "auto R R\"R(R)R\";\n"    // raw string
    "auto e R\"e(e)e\";\n"    // raw string
    "auto e = 123e4;\n"       // numeric literal
    "/" "* e R *" "/\n"       // ml comment
    "char c = 'e';\n"         // char
    "char c = 'R';\n"         // char
    "int x = 0xFF;\n"         // hex
    "int y = 0b101;\n"        // bin
    "int z = 077;\n"          // oct
    "unsigned u = 123u;\n"    // suffix
    "long long ll = 123LL;\n" // 123LL
    "float f = 12.34f;\n"     // 12.34f
    "double d = 1.2e+3;\n"    // 1.2e+3
    "long double ld = .5L;\n" // .5L
    "auto e = \"привет\"; /" "/ Russian hello\n" //utf8
    "e" "R" "\n"
    "bool e = true;\n"                   // true
    "int* R = nullptr;\n"                // nullptr
    "[[nodiscard e R]] int foo(e R);\n"  // [[xxxx]]
    "#include <iostream.hpp>\n"          // #include
    "#define e R var\n"                  // #define
    "\t#include\t<boost/regex.hpp>\n"    // 	 #	include
    "auto s = \"hello\"_s;\n"            // ""_s
    "auto _var = u8\" e R\";\n"          // u8"xxxxxxxxxxx"
    "auto _var = u8'e';\n"               // u8"xxxxxxxxxxxx"
    "auto _var = u8R\"delim(e R )delim\";\n"      //u8R""(xxxxxxx)""
    "123\n"                    // Simple integer
    "1'000'000\n"             // Integer with digit separators
    "12.34\n"                 // Floating-point
    "12.34'56f\n"             // Floating-point with digit separators
    ".5L\n"                   // Floating-point with leading decimal point
    "123.\n"                  // Floating-point with trailing decimal point
    "1'000.2e+3'00\n"         // Floating-point with exponent and digit separators
    "1e+3\n"                  // Exponential without decimal point
    "1'000e+3'00LL\n"         // Exponential with digit separators
    "0xFF\n"                  // Hexadecimal
    "0xFF'00\n"               // Hexadecimal with digit separators
    "0b101\n"                 // Binary
    "0b101'010\n"             // Binary with digit separators
    "077\n"                   // Octal
    "077'7\n"                 // Octal with digit separators
    "123u\n"                  // Integer with unsigned suffix
    "123LL\n"                // Integer with long long suffix
    "/" "/ single line comment trumps /" "*\n"    // commented out / *
    "/" "* unclosed ml comment invalid c++ should not be converted e R\n"   // sole / *
;

var test_text_exp =

R"V0G0N(auto <span class=exo>e</span> = <span class=exo3>"e"</span>; <span class=exo6>// e R </span>
auto <span class=exo>R</span> <span class=exo2>R"R(R)R"</span>;
auto <span class=exo>e</span> <span class=exo2>R"e(e)e"</span>;
auto <span class=exo>e</span> = <span class=exo5>123e4</span>;
<span class=exo8>/* e R */</span>
char c = <span class=exo4>'e'</span>;
char c = <span class=exo4>'R'</span>;
int x = <span class=exo5>0xFF</span>;
int y = <span class=exo5>0b101</span>;
int z = <span class=exo5>077</span>;
unsigned u = <span class=exo5>123u</span>;
long long ll = <span class=exo5>123LL</span>;
float f = <span class=exo5>12.34f</span>;
double d = <span class=exo5>1.2e+3</span>;
long double ld = .<span class=exo5>5L</span>;
auto <span class=exo>e</span> = <span class=exo3>"привет"</span>; <span class=exo6>// Russian hello</span>
eR
bool <span class=exo>e</span> = true;
int* <span class=exo>R</span> = nullptr;
<span class=exo9>[[nodiscard e R]]</span> int foo(<span class=exo>e</span> <span class=exo>R</span>);<span class=exo11>
#include <iostream.hpp></span><span class=exo10>
#define e R var</span><span class=exo10>
	#include	<boost/regex.hpp></span>
auto s = <span class=exo3>"hello"</span>_s;
auto _var = u8<span class=exo3>" e R"</span>;
auto _var = u8<span class=exo4>'e'</span>;
auto _var = u8<span class=exo2>R"delim(e R )delim"</span>;
<span class=exo5>123</span>
<span class=exo5>1'000'000</span>
<span class=exo5>12.34</span>
<span class=exo5>12.34'56f</span>
.<span class=exo5>5L</span>
<span class=exo5>123</span>.
<span class=exo5>1'000.2e+3'00</span>
<span class=exo5>1e+3</span>
<span class=exo5>1'000e+3</span><span class=exo4>'00LL
0xFF
0xFF'</span><span class=exo5>00</span>
<span class=exo5>0b101</span>
<span class=exo5>0b101'010</span>
<span class=exo5>077</span>
<span class=exo5>077'7</span>
<span class=exo5>123u</span>
<span class=exo5>123LL</span>
<span class=exo6>// single line comment trumps /)V0G0N" R"V0G0N(*</span>
<span class=exo7>/)V0G0N" R"V0G0N(* unclosed ml comment invalid c++ should not be converted e R
</span>)V0G0N";

}; // programexit()
