// Generated by gendoc

#include <cassert>

#include <exodus/program.h>
#ifndef EXO_FORMAT
#	define println printl
#endif
programinit()

func main() {

	// Options to skip testing
	{
		let msg = "Test passed. Without commencing because ";

		if (osgetenv("EXO_NODATA")) stop(msg ^ "EXO_NODATA was set.");

		if (not connect())          stop(msg ^ "No default db connection.");

		if (not open("xo_clients") or not reccount("xo_clients"))
		                            stop(msg ^ "xo_clients file is missing or empty.");
	}

	// Clean up before starting
	gosub cleanup();

////////////////
// Code examples var.h
////////////////

	printl("var() = default;");
	{
		var client; // Unassigned var
		if (not read(client from "xo_clients", "SB001")) abort("var: " ^ lasterror());
	}

	printl("var() = default;");
	{
		//             Exodus keywords:     C++ declarations:
		//             Non-Const   Const    Non-Const   Const
		//             -----------------    ----------------------
		// Variable:   var         let      var         const var
		// Reference:  out         in       var&        const var&
	}

	printl("operator=(expression) &;");
	{
		var v1 = 42;                 // Integer
		var v2 = 42.3;               // Double
		var v3 = "abc";              // String
		var v4 = 'x';                // char
		var v5 = true;               // bool
		var v6 = v1 + 100;           // Arithmetic
		var v7 = v3 ^ "xyz";         // Concatenation
		var v8 = oslist(".").sort(); // Built in functions
		let v9 = 12345;              // A const var
		var v10 = 12'345_var;        // A literal var integer
		var v11 = 123.45_var;        // A literal var double
		var v12 = "f1^v1]v2^f3"_var; // A literal var string
		var x = 0.1, y = "0.2", z = x + y;  assert(z == 0.3);
	}

	printl("or_default(in defaultvalue) const;");
	{
		var v1; // Unassigned
		var v2 = v1.or_default("abc");  assert(v2 == "abc");
		// or
		var v3 = or_default(v1, "abc");
	}

	printl("defaulter(CVR defaultvalue);");
	{
		var v1; // Unassigned
		v1.defaulter("abc");  assert(v1 == "abc");
		// or
		defaulter(v1, "abc");
	}

	printl("swap(io v2);");
	{
		var v1 = space(65'536);
		var v2 = "";
		v1.swap(v2);  assert(v1 == "" ); assert(v2.len() == 65'536);
		// or
		swap(v1, v2);
	}

	printl("move();");
	{
		var v1 = space(65'536);
		var v2 = v1.move();  assert(v2.len() == 65'536 ); assert(v1 == "");
		// or
		var v3 = move(v2);
	}

	printl("clone() const;");
	{
		var v1 = "abc";
		var v2 = v1.clone(); assert(v2 == "abc");
		// or
		var v3 = clone(v2);
	}

	printl("dump() const;");
	{
		var v1 = str("x", 32);
		v1.dump().outputl(); /// e.g. var:0x7ffea7462cd0 typ:1 str:0x584d9e9f6e70 "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
		// or
		outputl(dump(v1));
	}

	printl("isnum() const;");
	{
		if ("+123.45"_var.isnum()) {/*ok*/} else  abort("isnum: " ^ lasterror());
		if (       ""_var.isnum()) {/*ok*/} else  abort("isnum: " ^ lasterror());
		if (not   "."_var.isnum()) {/*ok*/} else  abort("isnum: " ^ lasterror());
		// or
		if (isnum("123.")) {/*ok*/} else  abort("isnum: " ^ lasterror());
	}

	printl("num() const;");
	{
				var v1 = "123.45"_var.num(); assert(v1 == 123.45);
		var v2 = "abc"_var.num() + 100; assert(v2 == 100);
	}

	printl("operator+(var);");
	{
		var v1 = 0.1;
		var v2 = v1 + 0.2; assert(v2 == 0.3);
	}

	printl("operator+=(var);");
	{
		var v1 = 0.1;
		v1 += 0.2; // 0.3
	}

	printl("operator++(int) &;");
	{
		var v1 = 3;
		var v2 = v1 ++;  assert(v2 == 3 ); assert(v1 == 4);
	}

	printl("operator--(int) &;");
	{
		var v1 = 3;
		var v2 = v1 --;  assert(v2 == 3 ); assert(v1 == 2);
	}

	printl("operator++() &;");
	{
		var v1 = 3;
		var v2 = ++ v1;  assert(v2 == 4 ); assert(v1 == 4);
	}

	printl("operator--() &;");
	{
		var v1 = 3;
		var v2 = -- v1;  assert(v2 == 2 ); assert(v1 == 2);
	}

	printl("operator""_var(const char* cstr, std::size_t size);");
	{
				var v1 = "f1^f2^v1]v2^f4"_var; assert(v1 == "f1" _FM "f2" _FM "v1" _VM "v2" _FM "f4");
	}

	printl("var(std::initializer_list<T> list)");
	{
				var v1 = {11, 22, 33}; assert(v1 == "11^22^33"_var);
	}

	printl("operator()(int fieldno) const;");
	{
		var v1 = "aa^bb"_var;
		v1(4) = 44;  assert(v1 == "aa^bb^^44"_var);
		// Field number -1 causes appending a field when updating.
		v1(-1) = "55";  assert(v1 == "aa^bb^^44^55"_var);
	}

	printl("operator()(int fieldno) const;");
	{
		var v1 = "aa^bb^cc"_var;
		var v2 = v1.f(2); assert(v2 == "bb"); /// .f() style access. Recommended.
		var v3 =   v1(2); assert(v3 == "bb"); ///   () style access. Not recommended.
	}

	printl("operator()(int fieldno, valueno) const;");
	{
		var v1 = "aa^b1]b2^cc"_var;
		v1(2, 4) = "44";  assert(v1 == "aa^b1]b2]]44^cc"_var);
		// value number -1 causes appending a value when updating.
		v1(2, -1) = 55;  assert(v1 == "aa^b1]b2]]44]55^cc"_var);
	}

	printl("operator()(int fieldno, valueno) const;");
	{
		var v1 = "aa^b1]b2^cc"_var;
		var v2 = v1.f(2,2); assert(v2 == "b2"); /// .f() style access. Recommended.
		var v3 =   v1(2,2); assert(v3 == "b2"); ///   () style access. Not recommended.
	}

	printl("operator^(var);");
	{
		var v2 = "aa";
		var v1 = v2 ^ 22; assert(v1 == "aa22");
	}

	printl("operator^=(var);");
	{
		var v1 = "aa";
		v1 ^= 22;  assert(v1 == "aa22");
	}

	printl("round(const int ndecimals = 0) const;");
	{
				let v1 = var(0.295).round(2); assert(v1 == "0.30");
		// or
		let v2 = round(1.295, 2); assert(v2 == "1.30");
		var v3 = var(-0.295).round(2); assert(v3 == "-0.30");
		// or
		var v4 = round(-1.295, 2); assert(v4 == "-1.30");
		var v5 = round(0, 1); assert(v5 == "0.0");
		var v6 = round(0, 0); assert(v6 == "0");
		var v7 = round(0, -1); assert(v7 == "0");
	}

	printl("round(const int ndecimals = 0) const;");
	{
				let v1 = round(123456.789,  0); assert(v1 == "123457");
		let v2 = round(123456.789, -1); assert(v2 == "123460");
		let v3 = round(123456.789, -2); assert(v3 == "123500");
	}

	printl("chr(const int num);");
	{
				let v1 = var::chr(0x61); assert(v1 == "a");
		// or
		let v2 = chr(0x61);
	}

	printl("textchr(const int num);");
	{
				let v1 = var::textchr(171416); assert(v1 == "ð©¶˜"); // or "\xF0A9B698"
		// or
		let v2 = textchr(171416);
	}

	printl("textchrname(const int unicode_code_point);");
	{
				let v1 = var::textchrname(91); assert(v1 == "LEFT SQUARE BRACKET");
		// or
		let v2 = textchrname(91);
	}

	printl("str(const int num) const;");
	{
				let v1 = "ab"_var.str(3); assert(v1 == "ababab");
		// or
		let v2 = str("ab", 3);
	}

	printl("space(const int nspaces);");
	{
				let v1 = var::space(3); assert(v1 == "   ");
		// or
		let v2 = space(3);
	}

	printl("numberinwords(in locale = "");");
	{
		let softhyphen = "\xc2\xad";
		let v1 = var(123.45).numberinwords("de_DE").replace(softhyphen, " "); assert(v1 == "ein hundert drei und zwanzig Komma vier fÃ¼nf");
	}

	printl("at(const int pos1) const;");
	{
		var v1 = "abc";
		var v2 = v1.at(2); assert(v2 == "b");
		var v3 = v1.at(-3); assert(v3 == "a");
		var v4 = v1.at(4); assert(v4 == "");
	}

	printl("ord() const;");
	{
				let v1 = "abc"_var.ord(); assert(v1 == 0x61); // decimal 97, 'a'
		// or
		let v2 = ord("abc");
	}

	printl("textord() const;");
	{
				let v1 = "Î“"_var.textord(); assert(v1 == 915); // U+0393: Greek Capital Letter Gamma (Unicode character)
		// or
		let v2 = textord("Î“");
	}

	printl("len() const;");
	{
				let v1 = "abc"_var.len(); assert(v1 == 3);
		// or
		let v2 = len("abc");
	}

	printl("empty() const;");
	{
		let v1 = "0";
		if (not v1.empty()) {/*ok*/} else  abort("empty: " ^ lasterror()); // true
		// or
		if (not empty(v1)) {/*ok*/} else  abort("empty: " ^ lasterror()); // true
	}

	printl("textwidth() const;");
	{
				let v1 = "ðŸ¤¡xðŸ¤¡"_var.textwidth(); assert(v1 == 5);
		// or
		let v2 = textwidth("ðŸ¤¡xðŸ¤¡");
	}

	printl("textlen() const;");
	{
				let v1 = "Î“Î¹Î¬Î½Î½Î·Ï‚"_var.textlen(); assert(v1 == 7);
		// or
		let v2 = textlen("Î“Î¹Î¬Î½Î½Î·Ï‚");
	}

	printl("fcount(SV sepstr) const;");
	{
				let v1 = "aa**cc"_var.fcount("*"); assert(v1 == 3);
		// or
		let v2 = fcount("aa**cc", "*");
	}

	printl("count(SV sepstr) const;");
	{
				let v1 = "aa**cc"_var.count("*"); assert(v1 == 2);
		// or
		let v2 = count("aa**cc", "*");
	}

	printl("starts(SV prefix) const;");
	{
		if ("abc"_var.starts("ab")) {/*true*/} else  abort("starts: " ^ lasterror());
		// or
		if (starts("abc", "ab")) {/*true*/} else  abort("starts: " ^ lasterror());
	}

	printl("ends(SV suffix) const;");
	{
		if ("abc"_var.ends("bc")) {/*true*/} else  abort("ends: " ^ lasterror());
		// or
		if (ends("abc", "bc")) {/*true*/} else  abort("ends: " ^ lasterror());
	}

	printl("contains(SV substr) const;");
	{
		if ("abcd"_var.contains("bc")) {/*true*/} else  abort("contains: " ^ lasterror());
		// or
		if (contains("abcd", "bc")) {/*true*/} else  abort("contains: " ^ lasterror());
	}

	printl("index(SV substr, const int startchar1 = 1) const;");
	{
				let v1 = "abcd"_var.index("bc"); assert(v1 == 2);
		// or
		let v2 = index("abcd", "bc");
	}

	printl("indexn(SV substr, const int occurrence) const;");
	{
				let v1 = "abcabc"_var.indexn("bc", 2); assert(v1 == 5);
		// or
		let v2 = indexn("abcabc", "bc", 2);
	}

	printl("indexr(SV substr, const int startchar1 = -1) const;");
	{
				let v1 = "abcabc"_var.indexr("bc"); assert(v1 == 5);
		// or
		let v2 = indexr("abcabc", "bc");
	}

	printl("match(SV regex_str, SV regex_options = "") const;");
	{
				let v1 = "abc1abc2"_var.match("BC(\\d)", "i"); assert(v1 == "bc1]1^bc2]2"_var);
		// or
		let v2 = match("abc1abc2", "BC(\\d)", "i");
	}

	printl("search(SV regex_str, io startchar1, SV regex_options = "") const;");
	{
		var startchar1 = 1;
		let v1 = "abc1abc2"_var.search("BC(\\d)", startchar1, "i"); assert(v1 == "bc1]1"_var);  assert(startchar1 == 5 );/// Ready for the next search
		// or
		startchar1 = 1;
		let v2 = search("abc1abc2", "BC(\\d)", startchar1, "i");
	}

	printl("hash(const std::uint64_t modulus = 0) const;");
	{
		let v1 = "abc"_var.hash(); assert(v1 == var(6'715'211'243'465'481'821));
		// or
		let v2 = hash("abc");
	}

	printl("ucase() const&");
	{
				let v1 = "Î“Î¹Î¬Î½Î½Î·Ï‚"_var.ucase(); assert(v1 == "Î“Î™Î†ÎÎÎ—Î£");
		// or
		let v2 = ucase("Î“Î¹Î¬Î½Î½Î·Ï‚");
	}

	printl("lcase() const&");
	{
				let v1 = "Î“Î™Î†ÎÎÎ—Î£"_var.lcase(); assert(v1 == "Î³Î¹Î¬Î½Î½Î·Ï‚");
		// or
		let v2 = lcase("Î“Î™Î†ÎÎÎ—Î£");
	}

	printl("tcase() const&");
	{
				let v1 = "Î³Î¹Î¬Î½Î½Î·Ï‚ Ï€Î±Ï€Ï€Î¬Ï‚"_var.tcase(); assert(v1 == "Î“Î¹Î¬Î½Î½Î·Ï‚ Î Î±Ï€Ï€Î¬Ï‚");
		// or
		let v2 = tcase("Î³Î¹Î¬Î½Î½Î·Ï‚ Ï€Î±Ï€Ï€Î¬Ï‚");
	}

	printl("fcase() const&");
	{
				let v1 = "GrÃ¼ÃŸen"_var.fcase(); assert(v1 == "grÃ¼ssen");
		// or
		let v2 = tcase("GrÃ¼ÃŸen");
	}

	printl("normalize() const&");
	{
				let v1 = "cafe\u0301"_var.normalize(); assert(v1 == "caf\u00E9"); // "cafÃ©"
		// or
		let v2 = normalize("cafe\u0301");
	}

	printl("invert() const&");
	{
				let v1 = "abc"_var.invert(); assert(v1 == "\xC2" "\x9E" "\xC2" "\x9D" "\xC2" "\x9C");
		// or
		let v2 = invert("abc");
	}

	printl("lower() const&");
	{
				let v1 = "a1^b2^c3"_var.lower(); assert(v1 == "a1]b2]c3"_var);
		// or
		let v2 = lower("a1^b2^c3"_var);
	}

	printl("raise() const&");
	{
				let v1 = "a1]b2]c3"_var.raise(); assert(v1 == "a1^b2^c3"_var);
		// or
		let v2 = "a1]b2]c3"_var;
	}

	printl("crop() const&");
	{
				let v1 = "a1^b2]]^c3^^"_var.crop(); assert(v1 == "a1^b2^c3"_var);
		// or
		let v2 = crop("a1^b2]]^c3^^"_var);
	}

	printl("quote() const&;");
	{
				let v1 = "abc"_var.quote(); assert(v1 == "\"abc\"");
		// or
		let v2 = quote("abc");
	}

	printl("squote() const&;");
	{
				let v1 = "abc"_var.squote(); assert(v1 == "'abc'");
		// or
		let v2 = squote("abc");
	}

	printl("unquote() const&;");
	{
				let v1 = "'abc'"_var.unquote(); assert(v1 == "abc");
		// or
		let v2 = unquote("'abc'");
	}

	printl("trim(SV trimchars = " ") const&;");
	{
				let v1 = "  a1  b2 c3  "_var.trim(); assert(v1 == "a1 b2 c3");
		// or
		let v2 = trim("  a1  b2 c3  ");
	}

	printl("trimfirst(SV trimchars = " ") const&;");
	{
				let v1 = "  a1  b2 c3  "_var.trimfirst(); assert(v1 == "a1  b2 c3  ");
		// or
		let v2 = trimfirst("  a1  b2 c3  ");
	}

	printl("trimlast(SV trimchars = " ") const&;");
	{
				let v1 = "  a1  b2 c3  "_var.trimlast(); assert(v1 == "  a1  b2 c3");
		// or
		let v2 = trimlast("  a1  b2 c3  ");
	}

	printl("trimboth(SV trimchars = " ") const&;");
	{
				let v1 = "  a1  b2 c3  "_var.trimboth(); assert(v1 == "a1  b2 c3");
		// or
		let v2 = trimboth("  a1  b2 c3  ");
	}

	printl("first() const&;");
	{
				let v1 = "abc"_var.first(); assert(v1 == "a");
		// or
		let v2 = first("abc");
	}

	printl("last() const&;");
	{
				let v1 = "abc"_var.last(); assert(v1 == "c");
		// or
		let v2 = last("abc");
	}

	printl("first(const std::size_t length) const&;");
	{
				let v1 = "abc"_var.first(2); assert(v1 == "ab");
		// or
		let v2 = first("abc", 2);
	}

	printl("last(const std::size_t length) const&;");
	{
				let v1 = "abc"_var.last(2); assert(v1 == "bc");
		// or
		let v2 = last("abc", 2);
	}

	printl("cut(const int length) const&;");
	{
				let v1 = "abcd"_var.cut(2); assert(v1 == "cd");
		// or
		let v2 = cut("abcd", 2);
	}

	printl("paste(const int pos1, const int length, SV replacestr) const&");
	{
				let v1 = "abcd"_var.paste(2, 2, "XYZ"); assert(v1 == "aXYZd");
		// or
		let v2 = paste("abcd", 2, 2, "XYZ");
	}

	printl("paste(const int pos1, SV insertstr) const&");
	{
				let v1 = "abcd"_var.paste(2, "XYZ"); assert(v1 == "aXYZbcd");
		// or
		let v2 = paste("abcd", 2, "XYZ");
	}

	printl("prefix(SV insertstr) const&;");
	{
				let v1 = "abc"_var.prefix("XYZ"); assert(v1 == "XYZabc");
		// or
		let v2 = prefix("abc", "XYZ");
	}

	printl("append(const auto&... appendable) const&");
	{
				let v1 = "abc"_var.append(" is ", 10, " ok", '.'); assert(v1 == "abc is 10 ok.");
		// or
		let v2 = append("abc", " is ", 10, " ok", '.');
	}

	printl("pop() const&");
	{
				let v1 = "abc"_var.pop(); assert(v1 == "ab");
		// or
		let v2 = pop("abc");
	}

	printl("field(SV delimiter, const int fieldnx = 1, const int nfieldsx = 1) const;");
	{
				let v1 = "aa*bb*cc"_var.field("*", 2); assert(v1 == "bb");
		// or
		let v2 = field("aa*bb*cc", "*", 2);
	}

	printl("field(SV delimiter, const int fieldnx = 1, const int nfieldsx = 1) const;");
	{
				let v1 = "aa*bb*cc"_var.field("*", -1); assert(v1 == "cc");
		// or
		let v2 = field("aa*bb*cc", "*", -1);
	}

	printl("fieldstore(SV separator, const int fieldno, const int nfields, in replacement) const&");
	{
				let v1 = "aa,bb,cc,dd,ee"_var.fieldstore(",", 2, 3, "11,22"); assert(v1 == "aa,11,22,,ee");
		// or
		let v2 = fieldstore("aa,bb,cc,dd,ee", ",", 2, 3, "11,22");
	}

	printl("fieldstore(SV separator, const int fieldno, const int nfields, in replacement) const&");
	{
				let v1 = "aa,bb,cc,dd,ee"_var.fieldstore(",", 2, 0, "11,22"); assert(v1 == "aa,11,22,bb,cc,dd,ee");
	}

	printl("fieldstore(SV separator, const int fieldno, const int nfields, in replacement) const&");
	{
				let v1 = "aa,bb,cc,dd,ee"_var.fieldstore(",", 2, -2, "11"); assert(v1 == "aa,11,dd,ee");
	}

	printl("fieldstore(SV separator, const int fieldno, const int nfields, in replacement) const&");
	{
				let v1 = "aa,bb,cc"_var.fieldstore(",", 6, 2, "11"); assert(v1 == "aa,bb,cc,,,11,");
	}

	printl("substr(const int pos1, const int length) const&");
	{
				let v1 = "abcd"_var.substr(2, 2); assert(v1 == "bc");
		// or
		let v2 = substr("abcd", 2, 2);
	}

	printl("substr(const int pos1, const int length) const&");
	{
				let v1 = "abcd"_var.substr(-3, 2); assert(v1 == "bc");
		// or
		let v2 = substr("abcd", -3, 2);
	}

	printl("substr(const int pos1, const int length) const&");
	{
				let v1 = "abcd"_var.substr(3, -2); assert(v1 == "cb");
		// or
		let v2 = substr("abcd", 3, -2); assert(v2 == "cb");
	}

	printl("substr(const int pos1) const&");
	{
				let v1 = "abcd"_var.substr(2); assert(v1 == "bcd");
		// or
		let v2 = substr("abcd", 2);
	}

	printl("substr(const int pos1, SV delimiterchars, out pos2) const;");
	{
		var pos1 = 4;
		let v1 = "12,45 78"_var.substr(pos1, ", ", COL2);   assert(v1 == "45" ); assert(COL2 == 6 ); // 6 is the position of the next delimiter char found.
		// or
		let v2 = substr("12,45 78", COL2 + 1, ", ", COL2);  assert(v2 == "78" ); assert(COL2 == 9 ); // 9 is one after the end of the string meaning that none of the delimiter chars were found.
	}

	printl("substr2(io pos1, out delimiterno) const;");
	{
		var pos1 = 4, field_mark_no;
		let v1 = "12^45^78"_var.substr2(pos1, field_mark_no); assert(v1 == "45");  assert(pos1 == 7 ); assert(field_mark_no == 2 ); // field_mark_no 2 means that a FM was found.
		// or
		let v2 = substr2("12^45^78"_var, pos1, field_mark_no); assert(v2 == "78");  assert(pos1 == 9 ); assert(field_mark_no == 0 ); // field_mark_no 0 means that none of the standard field marks were found.
	}

	printl("convert(SV fromchars, SV tochars) const&");
	{
				let v1 = "abcde"_var.convert("aZd", "XY"); assert(v1 == "Xbce"); // a is replaced and d is removed
		// or
		let v2 = convert("abcde", "aZd", "XY");
	}

	printl("textconvert(SV fromchars, SV tochars) const&");
	{
				let v1 = "aðŸ¤¡bðŸ˜€cðŸŒd"_var.textconvert("ðŸ¤¡ðŸ˜€", "ðŸ‘‹"); assert(v1 == "aðŸ‘‹bcðŸŒd");
		// or
		let v2 = textconvert("aðŸ¤¡bðŸ˜€cðŸŒd", "ðŸ¤¡ðŸ˜€", "ðŸ‘‹");
	}

	printl("replace(SV fromstr, SV tostr) const&;");
	{
				let v1 = "Abc.Abc"_var.replace("bc", "X"); assert(v1 == "AX.AX");
		// or
		let v2 = replace("Abc Abc", "bc", "X");
	}

	printl("replace(const rex& regex, SV replacement_str) const&;");
	{
				let v1 = "A a B b"_var.replace("[A-Z]"_rex, "'$0'"); assert(v1 == "'A' a 'B' b");
		// or
		let v2 = replace("A a B b", "[A-Z]"_rex, "'$0'");
	}

	printl("replace(const rex& regex, ReplacementFunction auto repl_func) const");
	{
		// Decode hex escape codes.
		var v1 = R"(--\0x3B--\0x2F--)";                                 // Hex escape codes.
		v1.replacer(
		    R"(\\0x[0-9a-fA-F]{2,2})"_rex,                              // Finds \0xFF.
		    [](auto match_str) {return match_str.cut(3).iconv("HEX");}  // Decodes to a char.
		);
		assert(v1 == "--;--/--");
	}

	printl("replace(const rex& regex, ReplacementFunction auto repl_func) const");
	{
		// Reformat dates using groups.
		var v2 = "Date: 03-15-2025";
		v2.replacer(
		    R"((\d{2})-(\d{2})-(\d{4}))"_rex,
		    [](auto match_str) {return match_str.f(1, 4) ^ "-" ^ match_str.f(1, 2) ^ "-" ^ match_str.f(1, 3);}
		);
		assert(v2 == "Date: 2025-03-15");
	}

	printl("unique() const&;");
	{
				let v1 = "a1^b2^a1^c2"_var.unique(); assert(v1 == "a1^b2^c2"_var);
		// or
		let v2 = unique("a1^b2^a1^c2"_var);
	}

	printl("sort(SV delimiter = _FM) const&;");
	{
				let v1 = "20^10^2^1^1.1"_var.sort(); assert(v1 == "1^1.1^2^10^20"_var);
		// or
		let v2 = sort("20^10^2^1^1.1"_var);
	}

	printl("sort(SV delimiter = _FM) const&;");
	{
				let v1 = "b1^a1^c20^c10^c2^c1^b2"_var.sort(); assert(v1 == "a1^b1^b2^c1^c10^c2^c20"_var);
		// or
		let v2 = sort("b1^a1^c20^c10^c2^c1^b2"_var);
	}

	printl("reverse(SV delimiter = _FM) const&;");
	{
				let v1 = "20^10^2^1^1.1"_var.reverse(); assert(v1 == "1.1^1^2^10^20"_var);
		// or
		let v2 = reverse("20^10^2^1^1.1"_var);
	}

	printl("shuffle(SV delimiter = _FM) const&;");
	{
		let v1 = "20^10^2^1^1.1"_var.shuffle(); /// e.g. "2^1^20^1.1^10" (random order depending on initrand())
		// or
		let v2 = shuffle("20^10^2^1^1.1"_var);
	}

	printl("parse(char sepchar = ' ') const&");
	{
				let v1 = "abc,\"def,\"123\" fgh\",12.34"_var.parse(','); assert(v1 == "abc^\"def,\"123\" fgh\"^12.34"_var);
		// or
		let v2 = parse("abc,\"def,\"123\" fgh\",12.34", ',');
	}

	printl("split(SV delimiter = _FM) const;");
	{
		dim d1 = "a^b^c"_var.split(); // A dimensioned array with three elements (vars)
		// or
		dim d2 = split("a^b^c"_var);
	}

	printl("ucaser() REF ;");
	{
		var v1 = "abc";
		v1.ucaser(); ;assert(v1 == "ABC");
		// or
		ucaser(v1);
	}

	printl("oconv(const char* convstr) const;");
	{
				let v1 = var(30123).oconv("D/E"); assert(v1 == "21/06/2050");
		// or
		let v2 = oconv(30123, "D/E");
	}

	printl("iconv(const char* convstr) const;");
	{
				let v1 = "21 JUN 2050"_var.iconv("D/E"); assert(v1 == 30123);
		// or
		let v2 = iconv("21 JUN 2050", "D/E");
	}
#ifdef EXO_FORMAT

	printl("format(in fmt_str, Args&&... args) const");
	{
				let v1 = var(12.345).format("'{:_>8.2f}'"); assert(v1 == "'___12.35'");
		let v2 = var(12.345).format("'{::MD20P|R(_)#8}'");
		// or
		var v3 = format("'{:_>8.2f}'", var(12.345)); assert(v3 == "'___12.35'");
		var v4 = format("'{::MD20P|R(_)#8}'", var(12.345));
	}
#endif

	printl("from_codepage(const char* codepage) const;");
	{
				let v1 = "\xa4"_var.from_codepage("CP1124"); assert(v1 == "Ð„");
		// or
		let v2 = from_codepage("\xa4", "CP1124");
		// U+0404 Cyrillic Capital Letter Ukrainian Ie Unicode character
	}

	printl("to_codepage(const char* codepage) const;");
	{
				let v1 = "Ð„"_var.to_codepage("CP1124").oconv("HEX"); assert(v1 == "A4");
		// or
		let v2 = to_codepage("Ð„", "CP1124").oconv("HEX");
	}

	printl("f(const int fieldno, const int valueno = 0, const int subvalueno = 0)            const;");
	{
		let v1 = "f1^f2v1]f2v2]f2v3^f2"_var;
		let v2 = v1.f(2, 2); assert(v2 == "f2v2");
	}

	printl("extract(const int fieldno, const int valueno = 0, const int subvalueno = 0)      const");
	{
		let v1 = "f1^f2v1]f2v2]f2v3^f2"_var;
		let v2 = v1.extract(2, 2); assert(v2 == "f2v2");
		//
		// For brevity the function alias "f()" (standing for "field") is normally used instead of "extract()" as follows:
		var v3 = v1.f(2, 2);
	}

	printl("sum() const;");
	{
				let v1 = "1]2]3^4]5]6"_var.sum(); assert(v1 == "6^15"_var);
		// or
		let v2 = sum("1]2]3^4]5]6"_var);
	}

	printl("sumall() const;");
	{
				let v1 = "1]2]3^4]5]6"_var.sumall(); assert(v1 == 21);
		// or
		let v2 = sumall("1]2]3^4]5]6"_var);
	}

	printl("sum(SV delimiter) const;");
	{
				let v1 = "10,20,30"_var.sum(","); assert(v1 == 60);
		// or
		let v2 = sum("10,20,30", ",");
	}

	printl("mv(const char* opcode, in var2) const;");
	{
				let v1 = "10]20]30"_var.mv("+","2]3]4"_var); assert(v1 == "12]23]34"_var);
	}

	printl("updater(const int fieldno, in replacement) REF");
	{
		var v1 = "f1^v1]v2}s2}s3^f3"_var;
		v1.updater(2, "X"); ;assert(v1 == "f1^X^f3"_var);
		// or
		v1(2) = "X"; /// Easiest.
		// or
		updater(v1, 2, "X");
	}

	printl("updater(const int fieldno, const int valueno, in replacement) REF");
	{
		var v1 = "f1^v1]v2}s2}s3^f3"_var;
		v1.updater(2, 2, "X"); ;assert(v1 == "f1^v1]X^f3"_var);
		// or
		v1(2, 2) = "X"; /// Easiest.
		// or
		updater(v1, 2, 2, "X");
	}

	printl("updater(const int fieldno, const int valueno, const int subvalueno, in replacement) REF;");
	{
		var v1 = "f1^v1]v2}s2}s3^f3"_var;
		v1.updater(2, 2, 2, "X"); ;assert(v1 == "f1^v1]v2}X}s3^f3"_var);
		// or
		v1(2, 2, 2) = "X"; /// Easiest.
		// or
		updater(v1, 2, 2, 2, "X");
	}

	printl("inserter(const int fieldno, in insertion) REF");
	{
		var v1 = "f1^v1]v2}s2}s3^f3"_var;
		v1.inserter(2, "X"); ;assert(v1 == "f1^X^v1]v2}s2}s3^f3"_var);
		// or
		inserter(v1, 2, "X");
	}

	printl("inserter(const int fieldno, const int valueno, in insertion) REF");
	{
		var v1 = "f1^v1]v2}s2}s3^f3"_var;
		v1.inserter(2, 2, "X"); ;assert(v1 == "f1^v1]X]v2}s2}s3^f3"_var);
		// or
		inserter(v1, 2, 2, "X");
	}

	printl("inserter(const int fieldno, const int valueno, const int subvalueno, in insertion) REF;");
	{
		var v1 = "f1^v1]v2}s2}s3^f3"_var;
		v1.inserter(2, 2, 2, "X"); ;assert(v1 == "f1^v1]v2}X}s2}s3^f3"_var);
		// or
		v1.inserter(2, 2, 2, "X");
	}

	printl("remover(const int fieldno, const int valueno = 0, const int subvalueno = 0) REF;");
	{
		var v1 = "f1^v1]v2}s2}s3^f3"_var;
		v1.remover(2, 2); ;assert(v1 == "f1^v1^f3"_var);
		// or
		remover(v1, 2, 2);
	}

	printl("locate(in target) const;");
	{
		if ("UK^US^UA"_var.locate("US")) {/*ok*/} else  abort("locate: " ^ lasterror()); // 2
		// or
		if (locate("US", "UK^US^UA"_var)) {/*ok*/} else  abort("locate: " ^ lasterror());
	}

	printl("locate(in target, out valueno) const;");
	{
		var setting;
		if ("UK]US]UA"_var.locate("US", setting)) {/*ok*/} else  abort("locate: " ^ lasterror());  assert(setting == 2);
		// or
		if (locate("US", "UK]US]UA"_var, setting)) {/*ok*/} else  abort("locate: " ^ lasterror());
	}

	printl("locate(in target, out setting, const int fieldno, const int valueno = 0) const;");
	{
		var setting;
		if ("f1^f2v1]f2v2]s1}s2}s3}s4^f3^f4"_var.locate("s4", setting, 2, 3)) {/*ok*/} else  abort("locate: " ^ lasterror());  assert(setting == 4 );// returns true
	}

	printl("locateby(const char* ordercode, in target, out valueno) const;");
	{
		var valueno; if ("aaa]bbb]ccc"_var.locateby("AL", "bb", valueno)) abort("locateby: " ^ lasterror());  assert(valueno == 2 );// returns false and valueno = where it could be correctly inserted.
	}

	printl("locateby(const char* ordercode, in target, out setting, const int fieldno, const int valueno = 0) const;");
	{
		var setting;
		if ("f1^f2^aaa]bbb]ccc^f4"_var.locateby("AL", "bb", setting, 3)) abort("locateby: " ^ lasterror());  assert(setting == 2 );// return false and where it could be correctly inserted.
	}

	printl("locateusing(const char* usingchar, in target) const;");
	{
		if ("AB,EF,CD"_var.locateusing(",", "EF")) {/*ok*/} else  abort("locateusing: " ^ lasterror());
	}

	printl("locateusing(const char* usingchar, in target, out setting, const int fieldno = 0, const int valueno = 0, const int subvalueno = 0) const;");
	{
		var setting;
		if ("f1^f2^f3c1,f3c2,f3c3^f4"_var.locateusing(",", "f3c2", setting, 3)) {/*ok*/} else  abort("locateusing: " ^ lasterror());  assert(setting == 2 );// returns true
	}

	printl("connect(in conninfo = "");");
	{
		var conn = "exodus";
		if (not conn.connect("dbname=exodus user=exodus password=somesillysecret")) abort("connect: " ^ lasterror());;
		// or
		if (not connect()) abort("connect: " ^ lasterror());
		// or
		if (not connect("exodus")) abort("connect: " ^ lasterror());
	}

	printl("attach(in filenames) const;");
	{
		var conn = "exodus";
		let filenames = "xo_clients^dict.xo_clients"_var;
		if (conn.attach(filenames)) {/*ok*/} else  abort("attach: " ^ lasterror());
		// or
		if (attach(filenames)) {/*ok*/} else  abort("attach: " ^ lasterror());
	}

	printl("begintrans() const;");
	{
		var conn = "exodus";
		if (not conn.begintrans()) abort("begintrans: " ^ lasterror());
		// or
		if (not begintrans()) abort("begintrans: " ^ lasterror());
	}

	printl("statustrans() const;");
	{
		var conn = "exodus";
		if (conn.statustrans()) {/*ok*/} else  abort("statustrans: " ^ lasterror());
		// or
		if (statustrans()) {/*ok*/} else  abort("statustrans: " ^ lasterror());
	}

	printl("rollbacktrans() const;");
	{
		var conn = "exodus";
		if (conn.rollbacktrans()) {/*ok*/} else  abort("rollbacktrans: " ^ lasterror());
		// or
		if (rollbacktrans()) {/*ok*/} else  abort("rollbacktrans: " ^ lasterror());
	}

	printl("committrans() const;");
	{
		var conn = "exodus";
		if (conn.committrans()) {/*ok*/} else  abort("committrans: " ^ lasterror());
		// or
		if (committrans()) {/*ok*/} else  abort("committrans: " ^ lasterror());
	}

	printl("sqlexec(in sqlcmd) const;");
	{
		var conn = "exodus";
		if (conn.sqlexec("select 1")) {/*ok*/} else  abort("sqlexec: " ^ lasterror());
		// or
		if (sqlexec("select 1")) {/*ok*/} else  abort("sqlexec: " ^ lasterror());
	}

	printl("sqlexec(in sqlcmd, io response) const;");
	{
		var conn = "exodus";
		let sqlcmd = "select 'xxx' as col1, 'yyy' as col2";
		var response;
		if (conn.sqlexec(sqlcmd, response)) {/*ok*/} else  abort("sqlexec: " ^ lasterror());  assert(response == "col1^col2\x1fxxx^yyy"_var );/// \x1f is the Record Mark (RM) char. The backtick char is used here by gendoc to deliminate source code.
		// or
		if (sqlexec(sqlcmd, response)) {/*ok*/} else  abort("sqlexec: " ^ lasterror());
	}

	printl("disconnect();");
	{
		var conn = "exodus";
		conn.disconnect();
		// or
		disconnect();
	}

	printl("disconnectall();");
	{
		var conn = "exodus";
		conn.disconnectall();
		// or
		disconnectall();
	}

	printl("lasterror();");
	{
		var v1 = var::lasterror();
		// or
		var v2 = lasterror();
	}

	printl("loglasterror(in source = "");");
	{
		var::loglasterror("main:");
		// or
		loglasterror("main:");
	}

	printl("dbcreate(in new_dbname, in old_dbname = "") const;");
	{
		var conn = "exodus";

		if (conn.dbcreate("xo_gendoc_testdb")) {/*ok*/} else  abort("dbcreate: " ^ lasterror());
		// or
		if (dbcreate("xo_gendoc_testdb")) abort("dbcreate: " ^ lasterror());
	}

	printl("dbcopy(in from_dbname, in to_dbname) const;");
	{
		var conn = "exodus";

		if (conn.dbcopy("xo_gendoc_testdb", "xo_gendoc_testdb2")) {/*ok*/} else  abort("dbcopy: " ^ lasterror());
		// or
		if (dbcopy("xo_gendoc_testdb", "xo_gendoc_testdb2")) abort("dbcopy: " ^ lasterror());
	}

	printl("dblist() const;");
	{
		var conn = "exodus";
		let v1 = conn.dblist();
		// or
		let v2 = dblist();
	}

	printl("dbdelete(in dbname) const;");
	{
		var conn = "exodus";
		if (conn.dbdelete("xo_gendoc_testdb2")) {/*ok*/} else  abort("dbdelete: " ^ lasterror());
		// or
		if (dbdelete("xo_gendoc_testdb2")) abort("dbdelete: " ^ lasterror());
	}

	printl("createfile(in filename) const;");
	{
		let filename = "xo_gendoc_temp", conn = "exodus";
		if (conn.createfile(filename)) {/*ok*/} else  abort("createfile: " ^ lasterror());
		// or
		if (createfile(filename)) abort("createfile: " ^ lasterror());
	}

	printl("renamefile(in filename, in newfilename) const;");
	{
		let conn = "exodus", filename = "xo_gendoc_temp", new_filename = "xo_gendoc_temp2";
		if (conn.renamefile(filename, new_filename)) {/*ok*/} else  abort("renamefile: " ^ lasterror());
		// or
		if (renamefile(filename, new_filename)) abort("renamefile: " ^ lasterror());
	}

	printl("listfiles() const;");
	{
		var conn = "exodus";
		if (not conn.listfiles()) abort("listfiles: " ^ lasterror());
		// or
		if (not listfiles()) abort("listfiles: " ^ lasterror());
	}

	printl("clearfile(in filename) const;");
	{
		let conn = "exodus", filename = "xo_gendoc_temp2";
		if (not conn.clearfile(filename)) abort("clearfile: " ^ lasterror());
		// or
		if (not clearfile(filename)) abort("clearfile: " ^ lasterror());
	}

	printl("deletefile(in filename) const;");
	{
		let conn = "exodus", filename = "xo_gendoc_temp2";
		if (conn.deletefile(filename)) {/*ok*/} else  abort("deletefile: " ^ lasterror());
		// or
		if (deletefile(filename)) abort("deletefile: " ^ lasterror());
	}

	printl("reccount(in filename = "") const;");
	{
		let conn = "exodus", filename = "xo_clients";
		var nrecs1 = conn.reccount(filename);
		// or
		var nrecs2 = reccount(filename);
	}

	printl("open(in dbfilename, in connection = "");");
	{
		var file, filename = "xo_clients";
		if (not file.open(filename)) abort("open: " ^ lasterror());
		// or
		if (not open(filename to file)) abort("open: " ^ lasterror());
	}

	printl("close() const;");
	{
		var file = "xo_clients";
		file.close();
		// or
		close(file);
	}

	printl("createindex(in fieldname, in dictfile = "") const;");
	{
		var filename = "xo_clients", fieldname = "DATE_CREATED";

		if (filename.createindex(fieldname)) {/*ok*/} else  abort("createindex: " ^ lasterror());
		// or
		if (createindex(filename, fieldname)) abort("createindex: " ^ lasterror());
	}

	printl("listindex(in file_or_filename = "", in fieldname = "") const;");
	{
		var conn = "exodus";
		if (conn.listindex()) {/*ok*/} else  abort("listindex: " ^ lasterror()); // includes "xo_clients__date_created"
		// or
		if (listindex()) {/*ok*/} else  abort("listindex: " ^ lasterror());
	}

	printl("deleteindex(in fieldname) const;");
	{
		var file = "xo_clients", fieldname = "DATE_CREATED";
		if (file.deleteindex(fieldname)) {/*ok*/} else  abort("deleteindex: " ^ lasterror());
		// or
		if (deleteindex(file, fieldname)) abort("deleteindex: " ^ lasterror());
	}

	printl("lock(in key) const;");
	{
		var file = "xo_clients", key = "1000";
		if (file.lock(key)) {/*ok*/} else  abort("lock: " ^ lasterror());
		// or
		if (lock(file, key)) abort("lock: " ^ lasterror());
	}

	printl("unlock(in key) const;");
	{
		var file = "xo_clients", key = "1000";
		if (file.unlock(key)) {/*ok*/} else  abort("unlock: " ^ lasterror());
		// or
		if (unlock(file, key)) abort("unlock: " ^ lasterror());
	}

	printl("unlockall() const;");
	{
		var conn = "exodus";
		if (not conn.unlockall()) abort("unlockall: " ^ lasterror());
		// or
		if (not unlockall(conn)) abort("unlockall: " ^ lasterror());
	}

	printl("write(in file, in key) const;");
	{
		let record = "Client GD^G^20855^30000^1001.00^20855.76539"_var;
		let file = "xo_clients", key = "GD001";

		record.write(file, key);
		// or
		write(record on file, key);
	}

	printl("read(in file, in key);");
	{
		var record;
		let file = "xo_clients", key = "GD001";
		if (not record.read(file, key)) abort("read: " ^ lasterror());  assert(record == "Client GD^G^20855^30000^1001.00^20855.76539"_var);
		// or
		if (not read(record from file, key)) abort("read: " ^ lasterror());
	}

	printl("deleterecord(in key) const;");
	{
		let file = "xo_clients", key = "GD001";
		if (file.deleterecord(key)) {/*ok*/} else  abort("deleterecord: " ^ lasterror());
		// or
		//if (deleterecord(file, key)) abort("deleterecord: " ^ lasterror());
	}

	printl("insertrecord(in file, in key) const;");
	{
		let record = "Client GD^G^20855^30000^1001.00^20855.76539"_var;
		let file = "xo_clients", key = "GD001";
		if (record.insertrecord(file, key)) {/*ok*/} else  abort("insertrecord: " ^ lasterror());
		// or
		if (insertrecord(record on file, key)) abort("insertrecord: " ^ lasterror());
	}

	printl("updaterecord(in file, in key) const;");
	{
		let record = "Client GD^G^20855^30000^1001.00^20855.76539"_var;
		let file = "xo_clients", key = "GD001";
		if (not record.updaterecord(file, key)) abort("updaterecord: " ^ lasterror());
		// or
		if (not updaterecord(record on file, key)) abort("updaterecord: " ^ lasterror());
	}

	printl("updatekey(in key, in newkey) const;");
	{
		let file = "xo_clients", key = "GD001", newkey = "GD002";
		if (not file.updatekey(key, newkey)) abort("updatekey: " ^ lasterror());
		// or
		if (not updatekey(file, newkey, key)) abort("updatekey: " ^ lasterror()); // Reverse the above change.
	}

	printl("readf(in file, in key, const int fieldno);");
	{
		var field, file = "xo_clients", key = "GD001", fieldno = 2;
		if (not field.readf(file, key, fieldno)) abort("readf: " ^ lasterror());  assert(field == "G");
		// or
		if (not readf(field from file, key, fieldno)) abort("readf: " ^ lasterror());
	}

	printl("writef(in file, in key, const int fieldno) const;");
	{
		var field = "f3", file = "xo_clients", key = "1000", fieldno = 3;
		field.writef(file, key, fieldno);
		// or
		writef(field on file, key, fieldno);
	}

	printl("writec(in file, in key) const;");
	{
		let record = "Client XD^X^20855^30000^1001.00^20855.76539"_var;
		let file = "xo_clients", key = "XD001";
		record.writec(file, key);
		// or
		writec(record on file, key);
	}

	printl("readc(in file, in key);");
	{
		var record;
		let file = "xo_clients", key = "XD001";
		if (record.readc(file, key)) {/*ok*/} else  abort("readc: " ^ lasterror());
		// or
		if (readc(record from file, key)) {/*ok*/} else  abort("readc: " ^ lasterror());
		// Verify not in actual database file by using read() not readc()
		if (read(record from file, key)) abort("Error: " ^ key ^ " should not be in the actual database file"); // error
	}

	printl("deletec(in key) const;");
	{
		var file = "xo_clients", key = "XD001";
		if (file.deletec(key)) {/*ok*/} else  abort("deletec: " ^ lasterror());
		// or
		if (deletec(file, key)) abort("deletec: " ^ lasterror());
	}

	printl("clearcache() const;");
	{
		let conn = "exodus";
		conn.clearcache();
		// or
		clearcache(conn);
	}

	printl("xlate(in filename, in fieldno, const char* mode) const;");
	{
		let key = "SB001";
		let client_name = key.xlate("xo_clients", 1, "X"); assert(client_name == "Client AAA");
		// or
		let name_and_type = xlate("xo_clients", key, "NAME_AND_TYPE", "X"); assert(name_and_type == "Client AAA (A)");
	}
#ifdef EXO_FORMAT

	printl("select(in sort_select_command = "");");
	{
		var clients = "xo_clients";
		if (clients.select("with type 'B' and with balance ge 100 by type by name"))
		    while (clients.readnext(ID))
		        println("Client code is {}", ID);
		// or
		if (select("xo_clients with type 'B' and with balance ge 100 by type by name"))
		    while (readnext(ID))
		        println("Client code is {}", ID);
	}
#endif

	printl("selectkeys(in keys);");
	{
		var dbfile = "";
		let keys = "A01^B02^C03"_var;
		if (dbfile.selectkeys(keys)) {/*ok*/} else  abort("selectkeys: " ^ lasterror());
		assert(dbfile.readnext(ID) and ID == "A01");
		// or
		if (selectkeys(keys)) {/*ok*/} else  abort("selectkeys: " ^ lasterror());
		assert(readnext(ID) and ID == "A01");
	}

	printl("hasnext();");
	{
		var clients = "xo_clients", key;
		if (clients.select()) {
		    assert(clients.hasnext());
		}
		// or
		if (select("xo_clients")) {
		    assert(hasnext());
		}
	}
#ifdef EXO_FORMAT

	printl("readnext(out record, out key, out valueno);");
	{
		var clients = "xo_clients";
		if (clients.select("with type 'B' and with balance ge 100 by type by name (R)"))
		    while (clients.readnext(RECORD, ID, MV))
		        println("Code is {}, Name is {}", ID, RECORD.f(1));
		// or
		DICT = "dict.xo_clients";
		if (select("xo_clients with type 'B' and with balance ge 100 by type by name (R)"))
		    while (readnext(RECORD, ID, MV))
		        println("Code is {}, Name is {}", calculate("CODE"), calculate("NAME"));
	}
#endif

	printl("clearselect();");
	{
		var clients = "xo_clients";
		clients.clearselect();
		if (not clients.hasnext()) {/*ok*/} else  abort("clearselect: " ^ lasterror());
		// or
		clearselect();
		if (not hasnext()) {/*ok*/} else  abort("clearselect: " ^ lasterror());
	}

	printl("savelist(SV listname);");
	{
		var clients = "xo_clients";
		if (clients.select("with type 'B' by name")) {
		}
		// or
		if (select("xo_clients with type 'B' by name")) {
		    if (savelist("mylist")) {/*ok*/} else  abort("savelist: " ^ lasterror());
		}
	}
#ifdef EXO_FORMAT

	printl("getlist(SV listname);");
	{
		var file = "";
		if (file.getlist("mylist")) {
		    while (file.readnext(ID))
		        println("Key is {}", ID);
		}
		// or
		if (getlist("mylist")) {
		    while (readnext(ID))
		        println("Key is {}", ID);
		}
	}
#endif

	printl("deletelist(SV listname) const;");
	{
		var conn = "";
		if (conn.deletelist("mylist")) {/*ok*/} else  abort("deletelist: " ^ lasterror());
		// or
		if (deletelist("mylist")) abort("deletelist: " ^ lasterror());
	}

	printl("date();");
	{
		let today1 = var::date();
		// or
		let today2 = date();
	}

	printl("time();");
	{
		let now1 = var::time();
		// or
		let now2 = time();
	}

	printl("ostime();");
	{
		let now1 = var::ostime();
		// or
		let now2 = ostime();
	}

	printl("ostimestamp();");
	{
		let now1 = var::ostimestamp();
		// or
		let now2 = ostimestamp();
	}

	printl("ostimestamp(in ostime) const;");
	{
		let idate = iconv("2025-01-01", "D"), itime = iconv("23:59:59", "MT");
		let ts1 = idate.ostimestamp(itime); assert(ts1 == 20821.99998842593);
		// or
		let ts2 = ostimestamp(idate, itime);
	}

	printl("ossleep(const int milliseconds);");
	{
		var::ossleep(100); // sleep for 100ms
		// or
		ossleep(100);
	}

	printl("oswait(const int milliseconds) const;");
	{
		let v1 = ".^/etc/hosts"_var.oswait(100); /// e.g. "IN_CLOSE_WRITE^/etc^hosts^f"_var
		// or
		let v2 = oswait(".^/etc/hosts"_var, 100);
	}

	printl("osopen(in osfilename, const bool utf8 = true) const;");
	{
		let osfilename = ostempdir() ^ "xo_gendoc_test.conf";
		if (oswrite("" on osfilename)) {/*ok*/} else  abort("osopen: " ^ lasterror()); /// Create an empty OS file
		var ostempfile;
		if (ostempfile.osopen(osfilename)) {/*ok*/} else  abort("osopen: " ^ lasterror());
		// or
		if (osopen(osfilename to ostempfile)) {/*ok*/} else  abort("osopen: " ^ lasterror());
	}

	printl("osbwrite(in osfilevar, io offset) const;");
	{
		let osfilename = ostempdir() ^ "xo_gendoc_test.conf";
		let text = "aaa=123\nbbb=456\n";
		var offset = -1; /// -1 means append.
		if (text.osbwrite(osfilename, offset)) {/*ok*/} else  abort("osbwrite: " ^ lasterror());  assert(offset == 16);
		// or
		if (not osbwrite(text on osfilename, offset)) abort("osbwrite: " ^ lasterror());
	}

	printl("osbread(in osfilevar, io offset, const int length);");
	{
		let osfilename = ostempdir() ^ "xo_gendoc_test.conf";
		var text, offset = 0;
		if (text.osbread(osfilename, offset, 8)) {/*ok*/} else  abort("osbread: " ^ lasterror());  assert(text == "aaa=123\n" ); assert(offset == 8);
		// or
		if (osbread(text from osfilename, offset, 8)) {/*ok*/} else  abort("osbread: " ^ lasterror());  assert(text == "bbb=456\n" ); assert(offset == 16);
	}

	printl("operator<<(const auto& value) const");
	{
		let txtfile = "t_temp.txt";
		if (not osremove(txtfile)) {} // Remove any existing file.
		txtfile << txtfile << " " << 123.456789 << " " << 123 << std::endl;
		let v1 = osread(txtfile); assert(v1 == "t_temp.txt 123.457 123\n");
	}

	printl("operator<<(const auto& value) const");
	{
		let vout = "t_std_iomanip_overview.txt";
		if (not osremove(vout)) {}
		using namespace std;
		vout << boolalpha    << true          << "\ttrue"    << endl;
		vout << noboolalpha  << true          << "\t1"       << endl;
		vout << showpoint    << 42.0          << "\t42.0000" << endl;
		vout << noshowpoint  << 42.0          << "\t42"      << endl;
		vout << showpos      << 42            << "\t+42"     << endl;
		vout << noshowpos    << 42            << "\t42"      << endl;
		vout << skipws       << " " << 42     << "\t 42"     << endl;
		vout << noskipws     << " " << 42     << "\t 42"     << endl;
		vout << unitbuf      << "a"           << "\ta"       << endl;
		vout << nounitbuf    << "b"           << "\tb"       << endl;
		vout << setw(6)      << 42            << "\t    42"  << endl;
		vout << left         << setw(6) << 42 << "\t42    "  << endl;
		vout << right        << setw(6) << 42 << "\t    42"  << endl;
		vout << internal     << setw(6) << 42 << "\t    42"  << endl;
		vout << setfill('*') << setw(6) << 42 << "\t****42"  << endl;
		vout << showbase     << hex << 255    << "\t0xff"    << endl;
		vout << noshowbase   << 255           << "\tff"      << endl;
		vout << uppercase    << 255           << "\tFF"      << endl;
		vout << nouppercase  << 255           << "\tff"      << endl;
		vout << oct          << 255           << "\t377"     << endl;
		vout << hex          << 255           << "\tff"      << endl;
		vout << dec          << 255           << "\t255"     << endl;
		vout << fixed        << 42.1          << "\t42.100000"            << endl;
		vout << scientific   << 42.1          << "\t4.210000e+01"         << endl;
		vout << hexfloat     << 42.1          << "\t0x1.50ccccccccccdp+5" << endl;
		vout << defaultfloat << 42.1          << "\t42.1"                 << endl;
		vout << std::setprecision(3)      << 42.1567  << "\t42.2"  << endl;
		vout << resetiosflags(ios::fixed) << 42.1567  << "\t42.2"  << endl;
		vout << setiosflags(ios::showpos) << 42       << "\t+42"   << endl;
		// Verify actual v. expected.
		var act_v_exp = osread(vout);
		act_v_exp.converter("\n\t", FM ^ VM); ;assert(act_v_exp == Text to dynamic array);
		act_v_exp = invertarray(act_v_exp);   // Columns <-> Rows
		assert(act_v_exp.f(1) eq act_v_exp.f(2));
	}

	printl("osclose() const;");
	{
		var osfilevar; if (osfilevar.osopen(ostempfile())) {/*ok*/} else  abort("osclose: " ^ lasterror());
		osfilevar.osclose();
		// or
		osclose(osfilevar);
	}

	printl("oswrite(in osfilename, const char* codepage = "") const;");
	{
		let text = "aaa = 123\nbbb = 456";
		let osfilename = ostempdir() ^ "xo_gendoc_test.conf";
		if (text.oswrite(osfilename)) {/*ok*/} else  abort("oswrite: " ^ lasterror());
		// or
		if (oswrite(text on osfilename)) {/*ok*/} else  abort("oswrite: " ^ lasterror());
	}

	printl("osread(const char* osfilename, const char* codepage = "");");
	{
		var text;
		let osfilename = ostempdir() ^ "xo_gendoc_test.conf";
		if (text.osread(osfilename)) {/*ok*/} else  abort("osread: " ^ lasterror());  assert(text == "aaa = 123\nbbb = 456");
		// or
		if (osread(text from osfilename)) {/*ok*/} else  abort("osread: " ^ lasterror());
		let text2 = osread(osfilename);
	}

	printl("osrename(in new_dirpath_or_filepath) const;");
	{
		let from_osfilename = ostempdir() ^ "xo_gendoc_test.conf";
		let to_osfilename = from_osfilename ^ ".bak";

		if (from_osfilename.osrename(to_osfilename)) {/*ok*/} else  abort("osrename: " ^ lasterror());
		// or
		if (osrename(from_osfilename, to_osfilename)) abort("osrename: " ^ lasterror());
	}

	printl("osmove(in to_osfilename) const;");
	{
		let from_osfilename = ostempdir() ^ "xo_gendoc_test.conf.bak";
		let to_osfilename = from_osfilename.cut(-4);

		if (from_osfilename.osmove(to_osfilename)) {/*ok*/} else  abort("osmove: " ^ lasterror());
		// or
		if (osmove(from_osfilename, to_osfilename)) abort("osmove: " ^ lasterror());
	}

	printl("oscopy(in to_osfilename) const;");
	{
		let from_osfilename = ostempdir() ^ "xo_gendoc_test.conf";
		let to_osfilename = from_osfilename ^ ".bak";
		if (from_osfilename.oscopy(to_osfilename)) {/*ok*/} else  abort("oscopy: " ^ lasterror());;
		// or
		if (oscopy(from_osfilename, to_osfilename)) {/*ok*/} else  abort("oscopy: " ^ lasterror());
	}

	printl("osremove() const;");
	{
		let osfilename = ostempdir() ^ "xo_gendoc_test.conf";
		if (osfilename.osremove()) {/*ok*/} else  abort("osremove: " ^ lasterror());
		// or
		if (osremove(osfilename)) abort("osremove: " ^ lasterror());
	}

	printl("oslist(SV globpattern = "", const int mode = 0) const;");
	{
		var entries1 = "/etc/"_var.oslist("*.cfg"); /// e.g. "adduser.conf^ca-certificates.con^... etc."
		// or
		var entries2 = oslist("/etc/" "*.conf");
	}

	printl("osinfo(const int mode = 0) const;");
	{
		var info1 = "/etc/hosts"_var.osinfo(); /// e.g. "221^20597^78309"_var
		// or
		var info2 = osinfo("/etc/hosts");
	}

	printl("osfile() const;");
	{
		var fileinfo1 = "/etc/hosts"_var.osfile(); /// e.g. "221^20597^78309"_var
		// or
		var fileinfo2 = osfile("/etc/hosts");
	}

	printl("osdir() const;");
	{
		var dirinfo1 = "/etc/"_var.osdir(); /// e.g. "^20848^44464"_var
		// or
		var dirinfo2 = osfile("/etc/");
	}

	printl("osmkdir() const;");
	{
		let osdirname = "xo_test/aaa";

		if (osdirname.osmkdir()) {/*ok*/} else  abort("osmkdir: " ^ lasterror());
		// or
		if (osmkdir(osdirname)) abort("osmkdir: " ^ lasterror());
	}

	printl("oscwd(SV newpath);");
	{
		let osdirname = "xo_test/aaa";
		if (osdirname.oscwd()) {/*ok*/} else  abort("oscwd: " ^ lasterror());
		// or
		if (oscwd(osdirname)) {/*ok*/} else  abort("oscwd: " ^ lasterror());
		if (oscwd("../..")) {/*ok*/} else  abort("oscwd: " ^ lasterror()); /// Change back to avoid errors in following code.
	}

	printl("oscwd();");
	{
		var cwd1 = var().oscwd();
		// or
		var cwd2 = oscwd();
	}

	printl("osrmdir(bool evenifnotempty = false) const;");
	{
		let osdirname = "xo_test/aaa";
		if (osdirname.osrmdir()) {/*ok*/} else  abort("osrmdir: " ^ lasterror());
		// or
		if (osrmdir(osdirname)) abort("osrmdir: " ^ lasterror());
	}

	printl("osshell() const;");
	{
		let cmd = "echo $HOME";
		if (cmd.osshell()) {/*ok*/} else  abort("osshell: " ^ lasterror());
		// or
		if (osshell(cmd)) {/*ok*/} else  abort("osshell: " ^ lasterror());
	}

	printl("osshellread(in oscmd);");
	{
		let cmd = "echo $HOME";
		var text;
		if (text.osshellread(cmd)) {/*ok*/} else  abort("osshellread: " ^ lasterror());
		// or capturing stdout but ignoring exit status
		text = osshellread(cmd);
	}

	printl("osshellwrite(in oscmd) const;");
	{
		let outtext = "abc xyz";
		if (outtext.osshellwrite("grep xyz")) {/*ok*/} else  abort("osshellwrite: " ^ lasterror());
		// or
		if (osshellwrite(outtext, "grep xyz")) {/*ok*/} else  abort("osshellwrite: " ^ lasterror());
	}

	printl("osprocess(in oscmd, in stdin_for_process, out stdout_from_process, out stderr_from_process, out exit_status, in timeout_secs = 0);");
	{
		var v_stdout, v_stderr, v_exit_status;
		if (var::osprocess("grep xyz", "abc\nxyz 123\ndef", v_stdout, v_stderr, v_exit_status)) {/*ok*/} else  abort("osprocess: " ^ lasterror());  assert(v_stdout == "xyz 123" );// v_exit_status = 0
		// or
		if (osprocess("grep xyz", "abc\nxyz 123\ndef", v_stdout, v_stderr, v_exit_status)) {/*ok*/} else  abort("osprocess: " ^ lasterror());
	}

	printl("ostempdir();");
	{
		let v1 = var::ostempdir();
		// or
		let v2 = ostempdir();
	}

	printl("ostempfile();");
	{
		var temposfilename1 = var::ostempfile();
		// or
		var temposfilename2 = ostempfile();
	}

	printl("ossetenv(SV envcode) const;");
	{
		let envcode = "EXO_ABC", envvalue = "XYZ";
		envvalue.ossetenv(envcode);
		// or
		ossetenv(envcode, envvalue);
	}

	printl("osgetenv(SV envcode);");
	{
		var envvalue1;
		if (envvalue1.osgetenv("HOME")) {/*ok*/} else  abort("osgetenv: " ^ lasterror()); // e.g. "/home/exodus"
		// or
		let envvalue2 = osgetenv("EXO_ABC"); assert(envvalue2 == "XYZ");
	}

	printl("ospid();");
	{
		let pid1 = var::ospid(); /// e.g. 663237
		// or
		let pid2 = ospid();
	}

	printl("ostid();");
	{
		let tid1 = var::ostid(); /// e.g. 663237
		// or
		let tid2 = ostid();
	}

	printl("version();");
	{
		// e.g.
		// Local:  doc 2025-03-19 18:15:31 +0000 219cdad8a
		// Remote: doc 2025-03-17 15:03:00 +0000 958f412f0
		// https://github.com/exodusdb/exodusdb/commit/219cdad8a
		// https://github.com/exodusdb/exodusdb/archive/958f412f0.tar.gz
		//
		let v1 = var::version();
		// or
		let v2 = version();
	}

	printl("setxlocale(const char* newlocalecode);");
	{
		if (var::setxlocale("en_US.utf8")) {/*ok*/} else  abort("setxlocale: " ^ lasterror());
		// or
		if (setxlocale("en_US.utf8")) {/*ok*/} else  abort("setxlocale: " ^ lasterror());
	}

	printl("getxlocale();");
	{
				let v1 = var::getxlocale(); assert(v1 == "en_US.utf8");
		// or
		let v2 = getxlocale();
	}

	printl("outputl(in prefix = "") const;");
	{
		"abc"_var.outputl("xyz = "); /// Sends "xyz = abc\n" to stdout and flushes.
		// or
		outputl("xyz = ", "abc"); /// Any number of arguments is allowed. All will be output.
	}

	printl("logputl(in prefix = "") const;");
	{
		"abc"_var.logputl("xyz = "); /// Sends "xyz = abc\n" to stdlog buffer and is not flushed.
		// or
		logputl("xyz = ", "abc");; /// Any number of arguments is allowed. All will be output.
	}

	printl("errputl(in prefix = "") const;");
	{
		"abc"_var.errputl("xyz = "); /// Sends "xyz = abc\n" to stderr
		// or
		errputl("xyz = ", "abc"); /// Any number of arguments is allowed. All will be output.
	}

	printl("osflush() const;");
	{
		var().osflush();
		// or
		osflush();
	}

	printl("input(in prompt = "");");
	{
		// var v1 = "defaultvalue";
		// if (v1.input("Prompt:")) {/*ok*/} else  abort("input: " ^ lasterror());
		// or
		// var v2 = input();
	}

	printl("keypressed(const bool wait = false);");
	{
		var v1; v1.keypressed();
		// or
		var v2 = keypressed();
	}

	printl("isterminal(const int arg = 1) const;");
	{
		var v1 = var().isterminal(); /// 1 or 0
		// or
		var v2 = isterminal();
	}

	printl("abs() const;");
	{
		let v1 = -12.34;
		let v2 = v1.abs(); assert(v2 == 12.34);
		// or
		let v3 = abs(v1);
	}

	printl("pwr(in exponent) const;");
	{
				let v1 = var(2).pwr(8); assert(v1 == 256);
		// or
		let v2 = pwr(2, 8);
	}

	printl("initrnd() const;");
	{
		var(123).initrnd(); /// Set seed to 123
		// or
		initrnd(123);
	}

	printl("rnd()     const;");
	{
		let v1 = var(100).rnd(); /// Random 0 to 99
		// or
		let v2 = rnd(100);
	}

	printl("exp()     const;");
	{
				let v1 = var(1).exp(); assert(v1 == 2.718281828459045);
		// or
		let v2 = exp(1);
	}

	printl("sqrt()    const;");
	{
				let v1 = var(100).sqrt(); assert(v1 == 10);
		// or
		let v2 = sqrt(100);
	}

	printl("sin()     const;");
	{
				let v1 = var(30).sin(); assert(v1 == 0.5);
		// or
		let v2 = sin(30);
	}

	printl("cos()     const;");
	{
				let v1 = var(60).cos(); assert(v1 == 0.5);
		// or
		let v2 = cos(60);
	}

	printl("tan()     const;");
	{
				let v1 = var(45).tan(); assert(v1 == 1);
		// or
		let v2 = tan(45);
	}

	printl("atan()    const;");
	{
				let v1 = var(1).atan(); assert(v1 == 45);
		// or
		let v2 = atan(1);
	}

	printl("loge()    const;");
	{
				let v1 = var(2.718281828459045).loge(); assert(v1 == 1);
		// or
		let v2 = loge(2.718281828459045);
	}

	printl("integer() const;");
	{
				let v1 = var(2.9).integer(); assert(v1 == 2);
		// or
		let v2 = integer(2.9);
		var v3 = var(-2.9).integer(); assert(v3 == -2);
		// or
		var v4 = integer(-2.9);
	}

	printl("floor() const;");
	{
				let v1 = var(2.9).floor(); assert(v1 == 2);
		// or
		let v2 = floor(2.9);
		var v3 = var(-2.9).floor(); assert(v3 == -3);
		// or
		var v4 = floor(-2.9);
	}

	printl("mod(in modulus) const;");
	{
				let v1 = var(11).mod(5); assert(v1 == 1);
		// or
		let v2 = mod(11, 5); assert(v2 == 1);
		let v3 = mod(-11, 5); assert(v3 == 4);
		let v4 = mod(11, -5); assert(v4 == -4);
		let v5 = mod(-11, -5); assert(v5 == -1);
	}

	printl("setprecision(int newprecision);");
	{
		assert(0.000001_var == 0); /// NOTE WELL: Default precision 4.
		let new_precision1 = var::setprecision(6); assert(new_precision1 == 6); // Increase the precision.
		// or
		let new_precision2 = setprecision(6);
		assert(0.000001_var != 0); /// NOTE: Precision 6.
	}

	printl("getprecision();");
	{
		let curr_precision1 = var::getprecision();
		// or
		let curr_precision2 = getprecision();
	}

	printl("oconv_D(const char* conversion) const;");
	{
		let v1 = 19002;
		var v2;
		v2 =  v1.oconv( "D"   ) ; assert(v2 == "09 JAN 2020"  ); // Default
		v2 =  v1.oconv( "D/"  ) ; assert(v2 == "01/09/2020"   ); // mm/dd/yyyy - American numeric
		v2 =  v1.oconv( "D-"  ) ; assert(v2 == "01-09-2020"   ); // mm-dd-yyyy - American numeric
		v2 =  v1.oconv( "D/E" ) ; assert(v2 == "09/01/2020"   ); // dd/mm/yyyy - International numeric
		v2 =  v1.oconv( "D-E" ) ; assert(v2 == "09-01-2020"   ); // dd-mm-yyyy - International numeric
		v2 =  v1.oconv( "D2"  ) ; assert(v2 == "09 JAN 20"    ); // 2 digit year
		v2 =  v1.oconv( "D0"  ) ; assert(v2 == "09 JAN"       ); // No year
		v2 =  v1.oconv( "DS"  ) ; assert(v2 == "2020 JAN 09"  ); // yyyy mmm dd - ISO year first, alpha month
		v2 =  v1.oconv( "DS-" ) ; assert(v2 == "2020-01-09"   ); // yyyy-mm-dd  - ISO year first, numeric month
		v2 =  v1.oconv( "DZ"  ) ; assert(v2 == " 9 JAN 2020"  ); // Leading 0 become spaces
		v2 =  v1.oconv( "DZZ" ) ; assert(v2 == "9 JAN 2020"   ); // Leading 0 are suppressed
		v2 =  v1.oconv( "D!"  ) ; assert(v2 == "09JAN2020"    ); // No separators
		v2 =  v1.oconv( "DS-!") ; assert(v2 == "20200109"     ); // yyyymmdd packed
		v2 =  v1.oconv( "DM"  ) ; assert(v2 == "1"            ); // Month number
		v2 =  v1.oconv( "DMA" ) ; assert(v2 == "JANUARY"      ); // Month name
		v2 =  v1.oconv( "DY"  ) ; assert(v2 == "2020"         ); // Year number
		v2 =  v1.oconv( "DY2" ) ; assert(v2 == "20"           ); // Year 2 digits
		v2 =  v1.oconv( "DD"  ) ; assert(v2 == "9"            ); // Day number in month (1-31)
		v2 =  v1.oconv( "DW"  ) ; assert(v2 == "4"            ); // Weekday number (1-7)
		v2 =  v1.oconv( "DWA" ) ; assert(v2 == "THURSDAY"     ); // Weekday name
		v2 =  v1.oconv( "DQ"  ) ; assert(v2 == "1"            ); // Quarter number
		v2 =  v1.oconv( "DJ"  ) ; assert(v2 == "9"            ); // Day number in year
		v2 =  v1.oconv( "DL"  ) ; assert(v2 == "31"           ); // Last day number of month (28-31)
		// Dynamic array
		let v3 = "12345^12346]12347"_var;
		v2 = v3.oconv("D") ; assert(v2 == "18 OCT 2001^19 OCT 2001]20 OCT 2001"_var);
		 // or
		 v2 =  oconv(v3, "D"   ) ;
	}

	printl("iconv_D(const char* conversion) const;");
	{
		// International order "DE"
		var v2;
		v2 =             oconv(19005, "DE") ; assert(v2 == "12 JAN 2020");
		v2 =    "12/1/2020"_var.iconv("DE") ; assert(v2 == 19005);
		v2 =    "12 1 2020"_var.iconv("DE") ; assert(v2 == 19005);
		v2 =    "12-1-2020"_var.iconv("DE") ; assert(v2 == 19005);
		v2 =  "12 JAN 2020"_var.iconv("DE") ; assert(v2 == 19005);
		v2 =  "jan 12 2020"_var.iconv("DE") ; assert(v2 == 19005);
		// American order "D"
		v2 =             oconv(19329, "D") ; assert(v2 == "01 DEC 2020");
		v2 =    "12/1/2020"_var.iconv("D") ; assert(v2 == 19329);
		v2 =   "DEC 1 2020"_var.iconv("D") ; assert(v2 == 19329);
		v2 =   "1 dec 2020"_var.iconv("D") ; assert(v2 == 19329);
		// Reverse order
		v2 =   "2020/12/1"_var.iconv("DE") ; assert(v2 == 19329);
		v2 =    "2020-12-1"_var.iconv("D") ; assert(v2 == 19329);
		v2 =   "2020 1 dec"_var.iconv("D") ; assert(v2 == 19329);
		//Invalid date
		v2 =    "2/29/2021"_var.iconv("D") ; assert(v2 == "");
		v2 =   "29/2/2021"_var.iconv("DE") ; assert(v2 == "");
		// or
		v2 = iconv("12/1/2020"_var, "DE") ; assert(v2 == 19005);
	}

	printl("oconv_MT(const char* conversion) const;");
	{
		let v1  = 62000;
		var v2;
		v2 = v1.oconv("MT"  ); assert(v2 == "17:13"     ); // Default
		v2 = v1.oconv("MTH" ); assert(v2 == "05:13PM"   ); // 'H' flag for AM/PM
		v2 = v1.oconv("MTS" ); assert(v2 == "17:13:20"  ); // 'S' flag for seconds
		v2 = v1.oconv("MTHS"); assert(v2 == "05:13:20PM"); // Both flags
		let v3  = 0;
		v2 = v3.oconv("MT"  ); assert(v2 == "00:00");
		v2 = v3.oconv("MTH" ); assert(v2 == "12:00AM");
		v2 = v3.oconv("MTS" ); assert(v2 == "00:00:00");
		v2 = v3.oconv("MTHS"); assert(v2 == "12:00:00AM");
		// Dynamic array
		let v4  = "61980^62040]62100"_var;
		v2 = v4.oconv("MT"); assert(v2 == "17:13^17:14]17:15"_var);
		// or
		v2 = oconv(v1, "MT"); assert(v2 == "17:13");
	}

	printl("iconv_MT(bool strict) const;");
	{
		var v2;
		v2 =       "17:13"_var.iconv( "MT" ) ; assert(v2 == 61980);
		v2 =     "05:13PM"_var.iconv( "MT" ) ; assert(v2 == 61980);
		v2 =    "17:13:20"_var.iconv( "MT" ) ; assert(v2 == 62000);
		v2 =  "05:13:20PM"_var.iconv( "MT" ) ; assert(v2 == 62000);
		v2 =       "00:00"_var.iconv( "MT" ) ; assert(v2 == 0);
		v2 =     "12:00AM"_var.iconv( "MT" ) ; assert(v2 == 0    ); // Midnight
		v2 =     "12:00PM"_var.iconv( "MT" ) ; assert(v2 == 43200); // Noon
		v2 =    "00:00:00"_var.iconv( "MT" ) ; assert(v2 == 0);
		v2 =  "12:00:00AM"_var.iconv( "MT" ) ; assert(v2 == 0);
		// Dynamic array
		v2 = "17:13^05:13PM]17:13:20"_var.iconv("MT") ; assert(v2 == "61980^61980]62000"_var);
		// or
		v2 = iconv("17:13", "MT") ; assert(v2 == 61980);
	}

	printl("oconv_MD(const char* conversion) const;");
	{
		var v1 = -1234.567;
		var v2;
		v2 =  v1.oconv( "MD20"   ) ; assert(v2 == "-1234.57");
		v2 =  v1.oconv( "MD20,"  ) ; assert(v2 == "-1,234.57"   ); // , flag
		v2 =  v1.oconv( "MC20,"  ) ; assert(v2 == "-1.234,57"   ); // MC code
		v2 =  v1.oconv( "MD20,-" ) ; assert(v2 == "1,234.57-"  ); // - flag
		v2 =  v1.oconv( "MD20,<" ) ; assert(v2 == "<1,234.57>"  ); // < flag
		v2 =  v1.oconv( "MD20,C" ) ; assert(v2 == "1,234.57CR" ); // C flag
		v2 =  v1.oconv( "MD20,D" ) ; assert(v2 == "1,234.57DB" ); // D flag
		// Dynamic array
		var v3 = "1.1^2.1]2.2"_var;
		v2 =  v3.oconv( "MD20"   ) ; assert(v2 == "1.10^2.10]2.20"_var);
		// or
		v2 =  oconv(v1, "MD20"   ) ; assert(v2 == "-1234.57"   );
	}

	printl("oconv_LRC(in format) const;");
	{
		var v2;
		v2 =      "abcde"_var.oconv( "L#3" ) ; assert(v2 == "abc" ); // Truncating
		v2 =      "abcde"_var.oconv( "R#3" ) ; assert(v2 == "cde");
		v2 =      "abcde"_var.oconv( "C#3" ) ; assert(v2 == "abc");
		v2 =      "ab"_var.oconv( "L#6" ) ; assert(v2 == "ab    " ); // Padding
		v2 =      "ab"_var.oconv( "R#6" ) ; assert(v2 == "    ab");
		v2 =      "ab"_var.oconv( "C#6" ) ; assert(v2 == "  ab  ");
		v2 =       var(42).oconv( "L(0)#5" ) ; assert(v2 == "42000" ); // Padding char (x)
		v2 =       var(42).oconv( "R(0)#5" ) ; assert(v2 == "00042");
		v2 =       var(42).oconv( "C(0)#5" ) ; assert(v2 == "04200");
		v2 =       var(42).oconv( "C(0)#5" ) ; assert(v2 == "04200");
		// Dynamic array
		v2 =       "f1^v1]v2"_var.oconv("L(_)#5") ; assert(v2 == "f1___^v1___]v2___"_var);
		// Fail for non-ASCII (Should be 5)
		v2 =      "ðŸ±"_var.oconv("L#5").textwidth() ; assert(v2 == 3);
		// or
		v2 =      oconv("abcd", "L#3" ) ; assert(v2 == "abc" );
	}

	printl("oconv_T(in format) const;");
	{
		let v1 = "Have a nice day";
		let v2 = v1.oconv("T#10") ; assert(v2 == "Have a    |nice day  "_var);
		// or
		let v3  = oconv(v1, "T#10") ; //  "Have a    |nice day  "_var
	}

	printl("oconv_MR(const char* conversion);");
	{
		let v1 = "123/abC.";
		var v2;
		v2 = v1.oconv("MRL") ; assert(v2 == "123/abc."); // lcase
		v2 = v1.oconv("MRU") ; assert(v2 == "123/ABC."); // ucase
		v2 = v1.oconv("MRT") ; assert(v2 == "123/Abc."); // tcase
		v2 = v1.oconv("MRN") ; assert(v2 == "123"     ); // Return only digits
		v2 = v1.oconv("MRA") ; assert(v2 == "abC"     ); // Return only alphabetic
		v2 = v1.oconv("MRB") ; assert(v2 == "123abC"  ); // Return only alphanumeric
		v2 = v1.oconv("MR/N") ; assert(v2 == "/abC."  ); // Remove digits
		v2 = v1.oconv("MR/A") ; assert(v2 == "123/."  ); // Remove alphabetic
		v2 = v1.oconv("MR/B") ; assert(v2 == "/."     ); // Remove alphanumeric
	}

	printl("oconv_HEX(const int ioratio) const;");
	{
		var v2;
		v2 =      "ab01"_var.oconv( "HEX" ) ; assert(v2 == "61" "62" "30" "31");
		v2 =  "\xff\x00"_var.oconv( "HEX" ) ; assert(v2 == "FF" "00"           ); // Any bytes are ok.
		v2 =         var(10).oconv( "HEX" ) ; assert(v2 == "31" "30"           ); // Uses ASCII string equivalent of 10 i.e. "10".
		v2 =    "\u0393"_var.oconv( "HEX" ) ; assert(v2 == "CE" "93"           ); // Greek capital Gamma in UTF8 bytes.
		v2 =      "a^]b"_var.oconv( "HEX" ) ; assert(v2 == "61" "1E" "1D" "62" ); // Field and value marks.
		// or
		v2 =       oconv("ab01"_var, "HEX") ; assert(v2 == "61" "62" "30" "31");
	}

	printl("oconv_MX() const;");
	{
				let v1 = "14.5]QQ]65535"_var.oconv("MX"); assert(v1 == "F]QQ]FFFF"_var);
		// or
		let v2 = oconv("14.5]QQ]65535"_var, "MX");
	}

	printl("iconv_MX() const;");
	{
				let v1 = "F]QQ]FFFF"_var.iconv("MX"); assert(v1 == "15]]65535"_var);
		// or
		let v2 = iconv("F]QQ]FFFF", "MX");
	}

	printl("oconv_MB() const;");
	{
				let v1 = var(255).oconv("MB"); assert(v1 == 1111'1111);
		// or
		let v2 = oconv(255, "MB");
	}

	printl("oconv_TX(const char* conversion) const;");
	{
		// 1. Backslash in text remains backslash
		let v1 = var(_BS).oconv("TX");     // _BS
		// 2. Literal "\n" -> literal "\\n" (Double escape any escaped NL chars)
		let v2 = var(_BS "n").oconv("TX"); // _BS _BS "n"
		// 3. \n becomes literal "\n" (Single escape any NL chars)
		let v3 = var(_NL).oconv("TX");     // _BS "n"
		// 4. FM -> \n
		let v4 = "f1^f2"_var.oconv("TX"); assert(v4 == "f1" _NL "f2");
		// 5. VM -> "\" \n
		let v5 = "v1]v2"_var.oconv("TX"); assert(v5 == "v1" _BS _NL "v2");
		// 6. SM -> "\\" \n
		let v6 = "s1}s2"_var.oconv("TX"); assert(v6 == "s1" _BS _BS _NL "s2");
		// 7. TM -> "\\\" \n
		let v7 = "t1|t2"_var.oconv("TX"); assert(v7 == "t1" _BS _BS _BS _NL "t2");
		// 8. ST -> "\\\\" \n
		let v8 = "st1~st2"_var.oconv("TX"); assert(v8 == "st1" _BS _BS _BS _BS _NL "st2");
	}

////////////////
// Code examples dim.h
////////////////

	printl("dim() = default;");
	{
		dim d1;
	}

	printl("dim(const int nrows, const int ncols = 1);");
	{
		dim d1(10);
		dim d2(10, 3);
	}

	printl("dim(const dim& rhs);");
	{
		dim d1 = {2, 4, 6, 8};
		dim d2 = d1;
	}

	printl("dim(dim&& rhs) noexcept : base(std::move(rhs)), ncols_(rhs.ncols_)");
	{
		dim d1 = "f1^f2^f3"_var.split();
	}

	printl("dim(std::initializer_list<T> list)");
	{
		dim d1 = {1, 2, 3, 4, 5};
		dim d2 = {"A", "B", "C"};
	}

	printl("operator=(in v1);");
	{
		dim d1(10);
		d1 = "";
	}

	printl("redim(const int nrows, const int ncols = 1);");
	{
		dim d1;
		d1.redim(10, 3);
	}

	printl("swap(dim& d2) noexcept");
	{
		dim d1(5);
		dim d2(10);
		d1.swap(d2);
	}

	printl("operator[](int rowno)");
	{
		dim d1 = {1, 2, 3, 4, 5};
		d1[3] = "X";
		let v1 = d1[3]; assert(v1 == "X");
	}

	printl("operator[](int rowno, int colno)");
	{
		dim d1(10, 5);
		d1 = "";
		d1[3, 4] = "X";
		let v1 = d1[3, 4]; assert(v1 == "X");
	}

	printl("rows() const;");
	{
		dim d1(5,3);
		let v1 = d1.rows(); assert(v1 == 5);
	}

	printl("cols() const;");
	{
		dim d1(5,3);
		let v1 = d1.cols(); assert(v1 == 3);
	}

	printl("join(SV delimiter = _FM) const;");
	{
		dim d1 = {"f1", "f2", "f3"};
		let v1 = d1.join(); assert(v1 == "f1^f2^f3"_var);
	}

	printl("splitter(in str1, SV delimiter = _FM);");
	{
		dim d1;
		d1.splitter("f1^f2^f3"_var);  assert(d1.rows() == 3  );//// Automatically dimensioned.
		//
		dim d2(10);
		d2.splitter("f1^f2^f3"_var);  assert(d2.rows() == 10 );/// Predimensioned. Excess elements become ""
	}

	printl("sorter(bool reverse = false);");
	{
		dim d1 = "2,20,10,1"_var.split(",");
		d1.sorter();
		let v1 = d1.join(","); assert(v1 == "1,2,10,20"_var);
	}

	printl("reverser();");
	{
		dim d1 = "2,20,10,1"_var.split(",");
		d1.reverser();
		let v1 = d1.join(","); assert(v1 == "1,10,20,2"_var);
	}

	printl("shuffler();");
	{
		dim d1 = "2,20,10,1"_var.split(",");
		d1.shuffler();
		let v1 = d1.join(","); // random
	}

	printl("write(in dbfile, in key) const;");
	{
		dim d1 = "Client GD^G^20855^30000^1001.00^20855.76539"_var.split();
		let file = "xo_clients", key = "GD001";

		d1.write(file, key);
		// or
		write(d1 on file, key);
	}

	printl("read(in dbfile, in key);");
	{
		dim d1(10);
		let file = "xo_clients", key = "GD001";
		if (not d1.read(file, key)) abort("read: " ^ lasterror());  assert(d1.join() == "Client GD^G^20855^30000^1001.00^20855.76539^^^^"_var);
		// or
		if (not read(d1 from file, key)) abort("read: " ^ lasterror());
	}

	printl("oswrite(in osfilename, const char* codepage = "") const;");
	{
		dim d1 = "aaa=1\nbbb=2\nccc=3\n"_var.split("\n");

		let osfilename = "xo_conf.txt";
		if (not d1.oswrite(osfilename)) abort("oswrite: " ^ lasterror());
		// or
		if (not oswrite(d1 on osfilename)) abort("oswrite: " ^ lasterror());
	}

	printl("osread(in osfilename, const char* codepage = "");");
	{
		dim d1;
		let osfilename = "xo_conf.txt";
		if (not d1.osread(osfilename)) abort("osread: " ^ lasterror()); // d1.join("\n") -> "aaa=1\nbbb=2\nccc=3\n"_var0
		// or
		if (not osread(d1 from osfilename)) abort("osread: " ^ lasterror());
	}

////////////////
// Code examples exoprog.h
////////////////

	printl("select(in sortselectclause_or_filehandle = "");");
	{
		select("xo_clients by name by type with type 'A' 'B' and with balance between 0 and 2000");
		if (readnext(ID)) {/*ok*/} else  abort("select: " ^ lasterror());
	}

	printl("selectkeys(in keys);");
	{
		selectkeys("SB001^JB001^JB002"_var);
		if (readnext(ID)) {/*ok*/} else  abort("selectkeys: " ^ lasterror());  assert(ID == "SB001");
	}

	printl("hasnext();");
	{
		if (hasnext()) {/*ok*/} else  abort("hasnext: " ^ lasterror());
	}

	printl("readnext(out key);");
	{
		selectkeys("SB001^JB001^JB002"_var);
		if (readnext(ID)) {/*ok*/} else  abort("readnext: " ^ lasterror());  assert(ID == "SB001");
	}

	printl("readnext(out key, out valueno);");
	{
		selectkeys("SB001]2^SB001]1^JB001]2"_var);
		if (readnext(ID, MV)) {/*ok*/} else  abort("readnext: " ^ lasterror());  assert(ID == "SB001" ); assert(MV == 2);
	}

	printl("readnext(out record, out key, out valueno);");
	{
		select("xo_clients by name (R)");
		if (readnext(RECORD, ID, MV)) {/*ok*/} else  abort("readnext: " ^ lasterror());;
		assert(not RECORD.empty());
	}

	printl("pushselect(out cursor);");
	{
		select("xo_clients by name");
		var saved_xo_clients_cursor;
		pushselect(saved_xo_clients_cursor);
		//
		// abort("pushselect: " ^ lasterror()); work with another select list abort("pushselect: " ^ lasterror());
		//
		popselect(saved_xo_clients_cursor); // Reactivate the original select list.
	}

	printl("clearselect();");
	{
		clearselect();
	}

	printl("deleterecord(in filename);");
	{
		if (select("xo_clients with type 'Q' and with balance between 0 and 100")) {
		  if (deleterecord("xo_clients")) abort("deleterecord: " ^ lasterror());
		}
	}

	printl("deleterecord(in dbfile, in key);");
	{
		let file = "xo_clients", key = "QQ001";
		write("" on file, key);
		if (not deleterecord(file, key)) abort("deleterecord: " ^ lasterror());
		// or
		write("" on file, key);
		if (not file.deleterecord(key)) abort("deleterecord: " ^ lasterror());
	}

	printl("savelist(SV listname);");
	{
		selectkeys("SB001^SB002"_var);
		if (not savelist("my_list")) abort("savelist: " ^ lasterror());
	}

	printl("getlist(SV listname);");
	{
		if (not getlist("my_list")) abort("getlist: " ^ lasterror());
	}

	printl("deletelist(SV listname);");
	{
		if (not deletelist("my_list")) abort("deletelist: " ^ lasterror());
	}

	printl("exoprog_date(in type, in input0, in ndecs0, out output);");
	{
		DATEFMT = "D/E";
		let v1 = iconv("JAN 9 2025", "D");
		assert(oconv(v1, "[DATE]"   ) == " 9/ 1/2025");  // "D/EZ" or "[DATE,D]" equivalent assuming D/E in DATEFMT (replace leading zeros with spaces)
		assert(oconv(v1, "[DATE,4]" ) == " 9/ 1/2025");  // "D4Z"  equivalent assuming D/E in DATEFMT (replace leading zeros with spaces)
		assert(oconv(v1, "[DATE,*4]") == "9/1/2025");    // "D4ZZ" equivalent assuming D/E in DATEFMT (trim leading zeros and spaces)
		assert(oconv(v1, "[DATE,*]" ) == "9/1/2025");    // "DZZ"  equivalent assuming D/E in DATEFMT (trim leading zeros and spaces)
	}

	printl("exoprog_number(in type, in input0, in ndecs0, out output);");
	{
				var v1 = oconv("1234.5USD", "[NUMBER,2]"); assert(v1 == "1,234.50USD"); // Comma added and decimal places corrected.
	}

	printl("exoprog_number(in type, in input0, in ndecs0, out output);");
	{
				var v1 = iconv("1,234.5678USD", "[NUMBER]"); assert(v1 == "1234.57USD"); // Comma removed
	}

	printl("elapsedtimetext() const;");
	{
		var v1 = elapsedtimetext(); // e.g. "< 1ms"
	}

	printl("elapsedtimetext(in timestamp1, in timestamp2) const;");
	{
				let v1 = elapsedtimetext(0, 0.55); assert(v1 == "13 hours, 12 mins");
		let v2 = elapsedtimetext(0, 0.001); assert(v2 == "1 min, 26 secs");
	}

	printl("note(in msg, in options, io response) const;");
	{
		var response;
		// call note("Enter something", "RC", response);
	}

	printl("note(in msg) const;");
	{
		call note("Hello world.");
	}

	printl("getcursor(out cursor, int delayms = 3000, int max_errors = 0) const;");
	{
		var cursor;
		if (isterminal() and not getcursor(cursor)) abort("getcursor: " ^ lasterror()); // cursor becomes something like "0^20^0.012345"_var
	}

	printl("getcursor() const;");
	{
		let cursor = getcursor(); // If isterminal() then cursor becomes something like "0^20^0.012345"_var
	}
#ifdef EXO_FORMAT

	printl("setcursor(in cursor_coordinates) const;");
	{
		if (isterminal()) {
		    let cursor = getcursor(); // Save the current cursor position.
		    TRACE(cursor)             // Show the saved cursor position.
		    print(AT(0,0));           // Position the cursor at 0,0.
		    setcursor(cursor);        // Restore its position
		}
	}
#endif

	printl("invertarray(in input, bool pad = false);");
	{
		let v1 = "a]b]c^1]2]3"_var;
		let v2 = invertarray(v1); assert(v2 == "a]1^b]2^c]3"_var);
	}

	printl("sortarray(io array, in fns = "", in order = "");");
	{
		var v1 = "f1^10]20]2]1^ww]xx]yy]zz^f3^f4"_var;  // fields 2 and 3 are parallel multivalues and currently unordered.
		sortarray(v1, "2]3"_var, "AR");  assert(v1 == "f1^1]2]10]20^zz]yy]ww]xx^f3^f4"_var);
	}

////////
// exit:
////////

	gosub cleanup();

	printl("Test passed.");

	return 0;
}
subroutine cleanup() {

	//Note that all '// Cleanup' lines in the original source code must use literals and not variables
	//otherwise the generated code will VNA on cleanup
		if (not dbdelete("xo_gendoc_testdb")) {}; // Cleanup first
		if (not dbdelete("xo_gendoc_testdb2")) {}; // Cleanup first
		if (not deleteindex("xo_clients", "DATE_CREATED")) {}; // Cleanup first
		//if (not "xo_clients"_var.deleterecord("GD001")) {}; // Cleanup first
		if (not osremove(ostempdir() ^ "xo_gendoc_test.conf.bak")) {}; // Cleanup first
		if (not osremove(ostempdir() ^ "xo_gendoc_test.conf")) {}; // Cleanup first
		if (osrmdir("xo_test/aaa")) {}; // Cleanup first
		if (not deleterecord("xo_clients", "GD001")) {}; // Cleanup first
		if (not osremove("xo_conf.txt")) {}; // Cleanup first
};

programexit()
