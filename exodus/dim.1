.TH dim.h

.SH 1. DIMENSIONED ARRAY CONSTRUCTION 
.SH

.SS
dim d1;
.PP \"<p>
Create an undimensioned array of vars.
.sp 1 \"</p>
.PP \"<p>
Pending actual dimensions by redim, read, osread or split.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1;
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
dim d1(nrows, ncols = 1);
.PP \"<p>
Create a dimensioned array of vars.
.sp 1 \"</p>
.PP \"<p>
Specify a fixed number of columns and rows. All vars are unassigned.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1(10);
dim d2(10, 3);
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
dim d1 = d2; // Copy
.PP \"<p>
Copy a dimensioned array.
.sp 1 \"</p>
.PP \"<p>
Unassigned elements are copied as is.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1 = {2, 4, 6, 8};
dim d2 = d1;
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
dim d1 = dim(); // Move
.PP \"<p>
Save a dimensioned array created elsewhere.
.sp 1 \"</p>
.PP \"<p>
Use C++ "move" semantics.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1 = "f1^f2^f3"_var.split();
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
dim d1 = {"a", "b", "c" ...}; // Initializer list
.PP \"<p>
Create a dimensioned array from a literal list.
.sp 1 \"</p>
.PP \"<p>
All elements must be the same type, var, string, double, int, etc. All end up as vars which are flexible.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1 = {1, 2, 3, 4, 5};
dim d2 = {"A", "B", "C"};
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
dim d1 = v1;
.PP \"<p>
Initialise all elements of an dimensioned array.
.sp 1 \"</p>
.PP \"<p>
To some single value. e.g. a var,  "", 0 etc.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1(10);
d1 = "";
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
d1.redim(nrows, ncols = 1)
.PP \"<p>
Resize a dimensioned array.
.sp 1 \"</p>
.PP \"<p>
To a different number of rows and columns.
.sp 1 \"</p>
.PP \"<p>
Existing data will be retained. Any additional elements are unassigned.
.sp 1 \"</p>
.PP \"<p>
Resizing rows to 0 clears all data.
.sp 1 \"</p>
.PP \"<p>
Resizing cols to 0 clears all data and changes its status to "undimensioned".
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1;
d1.redim(10, 3);
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
d1.swap(d2) 
.PP \"<p>
Swap two arrays.
.sp 1 \"</p>
.PP \"<p>
Either or both may be undimensioned.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1(5);
dim d2(10);
d1.swap(d2);
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SH 2. ARRAY ACCESS
.SH

.SS
var v1 = d1[rowno];       d1[rowno] = v1;
.PP \"<p>
[row] Access and update dimensioned array elements.
.sp 1 \"</p>
.PP \"<p>
Two dimensioned arrays can be traversed, columnwise then rowwise, using one dimension array access.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1 = {1, 2, 3, 4, 5};
d1[3] = "X";
let v1 = d1[3]; // "X"
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
var v1 = d1[rowno, colno];       d1[rowno, colno] = v1;
.PP \"<p>
[row, col] Access and update dimensioned array elements.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1(10, 5);
d1 = "";
d1[3, 4] = "X";
let v1 = d1[3, 4]; // "X"
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
var v1 = d1.rows();
.PP \"<p>
Get the number of rows in the dimensioned array
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR A count. Can be zero, indicating an empty or undimensioned array.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1(5,3);
let v1 = d1.rows(); // 5
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
var v1 = d1.cols();
.PP \"<p>
Get the number of columns in the dimensioned array
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR A count.  0 if the array is undimensioned.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1(5,3);
let v1 = d1.cols(); // 3
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
var v1 = d1.join(delimiter = FM);
.PP \"<p>
Get a delimited string concatenating all elements of a dimensioned array.
.sp 1 \"</p>
.PP \"<p>
Unassigned elements on the end are omitted.
.sp 1 \"</p>
.PP \"<p>
\fBdelimiter:\fR Default is FM.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR A string var.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1 = {"f1", "f2", "f3"};
let v1 = d1.join(); // "f1^f2^f3"_var
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SH 3. ARRAY MUTATION
.SH

.SS
d1.splitter(str1, delimiter = FM)
.PP \"<p>
Create or update a dimensioned array using a string with delimiters.
.sp 1 \"</p>
.PP \"<p>
If the dim array is undimensioned it will be dimensioned with the number of elements that the string has fields.
.sp 1 \"</p>
.PP \"<p>
If the dim array is dimensioned and has more elements than there are fields in the string, the excess array elements are initialised to "". If the record has more fields than there are elements in the array, the excess fields are all left unsplit in the final element of the array.
.sp 1 \"</p>
.PP \"<p>
Predimensioning arrays allows the efficient reuse of arrays in loops and ensures that all elements are assigned values, useful when reading records from DB files.
.sp 1 \"</p>
.PP \"<p>
Using undimensioned arrays allows the efficient handling of arrays with a very variable number of elements. e.g. OS text files.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1;
d1.splitter("f1^f2^f3"_var); // d1.rows() -> 3  //// Automatically dimensioned.
//
dim d2(10);
d2.splitter("f1^f2^f3"_var); // d2.rows() -> 10 /// Predimensioned. Excess elements become ""
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
d1.sorter(reverse = false)
.PP \"<p>
Sort a dimensioned array.
.sp 1 \"</p>
.PP \"<p>
The order of the elements is adjusted so that each element is <= the next.
.sp 1 \"</p>
.PP \"<p>
\fBreverse:\fR If true, then the order is reversed. The default is false.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1 = "2,20,10,1"_var.split(",");
d1.sorter();
let v1 = d1.join(","); // "1,2,10,20"_var
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
d1.reverser()
.PP \"<p>
Reverse a dimensioned array.
.sp 1 \"</p>
.PP \"<p>
The order of the elements is reversed.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1 = "2,20,10,1"_var.split(",");
d1.reverser();
let v1 = d1.join(","); // "1,10,20,2"_var
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
d1.randomizer()
.PP \"<p>
Randomise a dimensioned array.
.sp 1 \"</p>
.PP \"<p>
The order of the elements is randomised.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1 = "2,20,10,1"_var.split(",");
d1.randomizer();
let v1 = d1.join(","); // random
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SH 4. ARRAY CONVERSION
.SH

.SS
dim d1 = d1.sort(reverse = false);
.PP \"<p>
Get a sorted copy of a dimensioned array.
.sp 1 \"</p>


.SS
dim d1 = d1.reverse();
.PP \"<p>
Get a reversed copy of a dimensioned array;
.sp 1 \"</p>


.SS
dim d1 = d1.randomize();
.PP \"<p>
Get a randomised copy of a dimensioned array.
.sp 1 \"</p>


.SH 5. ARRAY DB I/O
.SH

.SS
d1.write(dbfile, key)
.PP \"<p>
Write a DB file record created from a dimensioned array.
.sp 1 \"</p>
.PP \"<p>
Each element in the array becomes a separate field in the DB record.
.sp 1 \"</p>
.PP \"<p>
Redundant trailing FMs are omitted.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1 = "Client GD^G^20855^30000^1001.00^20855.76539"_var.split();
let file = "xo_clients", key = "GD001";
if (not deleterecord("xo_clients", "GD001")) {}; // Cleanup first
d1.write(file, key);
// or
write(d1 on file, key);
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (d1.read(dbfile, key)) ...
.PP \"<p>
Read a DB file record into a dimensioned array.
.sp 1 \"</p>
.PP \"<p>
Each field in the database record becomes a single element in the array.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR True if the record exists or false if not,
.sp 1 \"</p>
.PP \"<p>
If the array is predimensioned then any excess array elements are initialised to "" and any excess record fields are left unsplit in the final array element. See dim splitter for more info.
.sp 1 \"</p>
.PP \"<p>
If the array is not predimensioned (rows and cols = 0) then it will be dimensioned to have exactly the same number of rows as there are fields in the record being read.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1(10);
let file = "xo_clients", key = "GD001";
if (not d1.read(file, key)) ... // d1.join() -> "Client GD^G^20855^30000^1001.00^20855.76539^^^^"_var
// or
if (not read(d1 from file, key)) ...
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SH 6. ARRAY OS I/O
.SH

.SS
if (d1.oswrite(osfilename, codepage = "")) ...
.PP \"<p>
Create an entire OS text file from a dimensioned array
.sp 1 \"</p>
.PP \"<p>
Each element of the array becomes one line in the OS file delimited by \\n
.sp 1 \"</p>
.PP \"<p>
Any existing OS file is overwritten and replaced.
.sp 1 \"</p>
.PP \"<p>
\fBcodepage:\fR Optional: Data is converted from UTF8 to the required codepage/encoding before output. If the conversion cannot be performed then return false.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR True if successful or false if not.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1 = "aaa=1\nbbb=2\nccc=3\n"_var.split("\n");
if (not osremove("xo_conf.txt")) {}; // Cleanup first
let osfilename = "xo_conf.txt";
if (not d1.oswrite(osfilename)) ...
// or
if (not oswrite(d1 on osfilename)) ...
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (d1.osread(osfilename, codepage = "")) ...
.PP \"<p>
Read an entire OS text file into a dimensioned array.
.sp 1 \"</p>
.PP \"<p>
Each line in the OS file, delimited by \\n or \\r\\n, becomes a separate element in the array.
.sp 1 \"</p>
.PP \"<p>
Existing data in the array is lost and the array is redimensioned to the number of lines in the input data.
.sp 1 \"</p>
.PP \"<p>
\fBcodepage:\fR Optional. Data will be converted from the specified codepage/encoding to UTF8 after being read. If the conversion cannot be performed then return false.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR True if successful or false if not.
.sp 1 \"</p>
.PP \"<p>
If the first \\n in the file is \\r\\n then the whole file will be split using \\r\\n as delimiter.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
dim d1;
let osfilename = "xo_conf.txt";
if (not d1.osread(osfilename)) ... // d1.join("\n") -> "aaa=1\nbbb=2\nccc=3\n"_var0
// or
if (not osread(d1 from osfilename)) ...
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>



