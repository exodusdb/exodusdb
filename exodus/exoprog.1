.TH exoprog.h

.SH 1. SELECT LISTS
.SH

.SS
if (select(sortselectclause_or_filehandle = "")) ...
.PP \"<p>
Create an active select list using a natural language sort/select command.
.sp 1 \"</p>
.PP \"<p>
This and all the following exoprog member functions work on an environment variable CURSOR.
.sp 1 \"</p>
.PP \"<p>
Identical functions are available directly on plain var objects but vars have less functionality regarding dictionaries and environment variables which are built-in to exoprog.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR True if an active select list was created, false otherwise.
.sp 1 \"</p>
.PP \"<p>
In the following examples, various environment variables like RECORD, ID and MV are used instead of declaring and using named vars. In actual code, either may be freely used.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
select("xo_clients by name by type with type 'A' 'B' and with balance between 0 and 2000");
if (readnext(ID)) ... ok
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (selectkeys(keys)) ...
.PP \"<p>
Create an active select list from a dynamic array of keys.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
selectkeys("SB001^JB001^JB002"_var);
if (readnext(ID)) ... ok // ID -> "SB001"
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (hasnext()) ...
.PP \"<p>
Check if a select list is active.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
if (hasnext()) ... ok
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (readnext(out key)) ...
.PP \"<p>
Get the next key from an active select list.
.sp 1 \"</p>
.PP \"<p>
\fBkey[out]:\fR A string. Typically the key of a db file record.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR True if an active select list was available and the next key in the list was obtained.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
selectkeys("SB001^JB001^JB002"_var);
if (readnext(ID)) ... ok // ID -> "SB001"
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (readnext(out key, out valueno)) ...
.PP \"<p>
Get the next key and value number pair from an active select list.
.sp 1 \"</p>
.PP \"<p>
\fBkey[out]:\fR A string. Typically the key of a db file record.
.sp 1 \"</p>
.PP \"<p>
\fBvalueno[out]:\fR Is only available in select lists that have been created by sort/select commands that refer to multi-valued db dictionary fields where db records have multiple values for a specific field. In this case, a record key will appear multiple times in the select list since each multivalue is exploded for the purpose of sorting and selecting. This can be viewed as a process of "normalising" multivalues so they appear as multiple records instead of being held in a single record.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR True if an active select list was available and the next key in the list was obtained.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
selectkeys("SB001]2^SB001]1^JB001]2"_var);
if (readnext(ID, MV)) ... ok // ID -> "SB001" // MV -> 2
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (readnext(out record, out key, out valueno)) ...
.PP \"<p>
Get the next record, key and value no from an active select list.
.sp 1 \"</p>
.PP \"<p>
\fBrecord[out]:\fR Is only available in select lists that have been created with the final (R) option. Otherwise the record will be returned as an empty string and must be obtained using a db read() function.
.sp 1 \"</p>
.PP \"<p>
\fBkey[out]:\fR A string. Typically the key of a db file record.
.sp 1 \"</p>
.PP \"<p>
\fBvalueno[out]:\fR Is only available in select lists that have been created by sort/select commands that refer to multi-valued db dictionary fields where db records have multiple values for a specific field.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR True if an active select list was available and the next key in the list was obtained.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
select("xo_clients by name (R)");
if (readnext(RECORD, ID, MV)) ... ok;
assert(not RECORD.empty());
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
pushselect(out cursor)
.PP \"<p>
Get a reference to the currently active select list and suspend it.
.sp 1 \"</p>
.PP \"<p>
Allow another select list to be activated and used temporarily before the original select list is reactivated.
.sp 1 \"</p>
.PP \"<p>
Multiple levels of pushselect/popselect can be used.
.sp 1 \"</p>
.PP \"<p>
\fBcursor[out]:\fR A var that can be passed later on to the popselect() function to reactivate the saved list.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
select("xo_clients by name");
var saved_xo_clients_cursor;
pushselect(saved_xo_clients_cursor);
//
// ... work with another select list ...
//
popselect(saved_xo_clients_cursor); // Reactivate the original select list.
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
popselect(cursor)
.PP \"<p>
Re-activate a select list using a reference provided by pushselect().
.sp 1 \"</p>
.PP \"<p>
\fBcursor:\fR A var created by the pushselect() function.
.sp 1 \"</p>
.PP \"<p>
See pushselect() for more info.
.sp 1 \"</p>


.SS
clearselect()
.PP \"<p>
Deactivate an active select list.
.sp 1 \"</p>
.PP \"<p>
If no select list is active then nothing is done.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
clearselect();
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (deleterecord(filename)) ...
.PP \"<p>
Delete multiple DB records using an active select list.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR False if any records could not be deleted.
.sp 1 \"</p>
.PP \"<p>
Contrast this function with the two argument "deleterecord(file, key)" function that deletes a single record.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
if (select("xo_clients with type 'Q' and with balance between 0 and 100")) {
  if (deleterecord("xo_clients")) ...
}
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (deleterecord(dbfile, key)) ...
.PP \"<p>
Delete a single DB record.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
let file = "xo_clients", key = "QQ001";
write("" on file, key);
if (not deleterecord(file, key)) ...
// or
write("" on file, key);
if (not file.deleterecord(key)) ...
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (savelist(listname)) ...
.PP \"<p>
Save the current active select list under a given name.
.sp 1 \"</p>
.PP \"<p>
Select lists are saved in the DB file "lists". They are accessible to any Exodus process and remain until specifically deleted.
.sp 1 \"</p>
.PP \"<p>
After saving, the list is no longer active and hasnext() will return false.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR True if an active select list was saved, false if there was no active select list.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
selectkeys("SB001^SB002"_var);
if (not savelist("my_list")) ...
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (getlist(listname)) ...
.PP \"<p>
Create an active select list using a saved select list of a given name.
.sp 1 \"</p>
.PP \"<p>
A saved list is obtained from the "lists" file and activated. The list remains in the lists file for multiple use.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR True if an active select list was successfully reactivated, otherwise false.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
if (not getlist("my_list")) ...
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (deletelist(listname)) ...
.PP \"<p>
Remove a saved select list by name.
.sp 1 \"</p>
.PP \"<p>
A saved list is deleted from the "lists" file.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
if (not deletelist("my_list")) ...
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (formlist(filename_or_command, keys = "", fieldno = 0)) ...



.SS
if (makelist(listname, keys)) ...



.SH 2. PERFORM/EXECUTE
.SH

.SS
var v1 = perform(command_line);
.PP \"<p>
Run an Exodus program/library.
.sp 1 \"</p>
.PP \"<p>
Creates a new instance of an Exodus program library function object and calls its main() function using a command-like syntax, similar to that of running an OS executable program, and passes its arguments through the COMMAND and OPTIONS variables.
.sp 1 \"</p>
.PP \"<p>
A performed program/library's main function should have no arguments otherwise they appear unassigned and a segfault or core dump may occur.
.sp 1 \"</p>
.PP \"<p>
The Exodus program class member variables of a performed or executed program/library are all, as might be expected, initially unassigned unless specifically initialised inline. Note that this is not the same as calling a program library function (using function call syntax and round brackets funcx()), where the program/library/function's member variables are initially unassigned but retain their state between calls.
.sp 1 \"</p>
.PP \"<p>
\fBcommand_line:\fR Used to initialise the COMMAND, SENTENCE and OPTIONS environment variables of the performed exodus program/library. Analogous to passing function arguments. The first word of command_line is used as the name of the program/library to be loaded and run.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR Whatever the program returns from main() or passes as an argument to stop(). If the program terminates abnormally then it will return "" and lasterror() will contain some error message. The return value may be ignored so there is no need so wrap perform statements in if clauses to avoid compiler warnings.
.sp 1 \"</p>
.PP \"<p>
\fBthrow:\fR All the various runtime errors based on VarError e.g. VarUnassigned.
.sp 1 \"</p>
.PP \"<p>
\fBenvironment:\fR The following environment variables are initialised on entry to the main function of the program/library and are preserved untouched (actually restored) in the calling program.
.sp 1 \"</p>
.br
\(bu COMMAND, OPTIONS, SENTENCE.
.br
\(bu RECUR0, RECUR1, RECUR2, RECUR3, RECUR4 to "".
.br
\(bu ID, RECORD, MV, DICT initialised to "".
.br
\(bu LEVEL is incremented by one.
.br
\(bu All other environment variables are shared between the caller and callee. There is essentially only one environment in any one process or thread.
.br
\(bu CURSOR Any active select list in CURSOR is passed to the performed program/library and can be consumed by it. Conversely any active select list created by the performed program/library will be returned to the calling program. In other words, both the performing and the performed programs/libraries share a single active select list environment. This is different from execute() where the executed program/library gets its own private active select list, initially inactive.
.PP \"<p>
Exodus program/library/functions may also be called directly using conventional function calling syntax. To call an exodus program/library called progname using either the syntax "call progname(args...);" or "var v1 = progname(args...);" you must "#include <progname.h>" after the "programinit()" or "libraryinit()" lines in your program/library. See library.h for more info.
.sp 1 \"</p>


.SS
var v1 = execute(command_line);
.PP \"<p>
Run an exodus program/library.
.sp 1 \"</p>
.PP \"<p>
Identical to perform() but any currently active select list in the calling program/library is not accessible to the executed program/library and is preserved in the calling [program as is. Any select list created by the executed library is discarded when it terminates.
.sp 1 \"</p>


.SS
chain(command_line)
.PP \"<p>
Close the current program and perform another one.
.sp 1 \"</p>
.PP \"<p>
Similar to perform() except that the current program closes first and all environment variables carry forward unchanged.
.sp 1 \"</p>


.SS
var v1 = libinfo(libname);
.PP \"<p>
Check if a lib exists.
.sp 1 \"</p>
.PP \"<p>
Can be checked before perform/execute to avoid errors.
.sp 1 \"</p>
.PP \"<p>
Currently it does not check if the library is actually loadable.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR osfile info.
.sp 1 \"</p>


.SH 3. PROGRAM TERMINATION 
.SH

.SS
stop(result = "")
.PP \"<p>
Stop the current exodus program/library normally.
.sp 1 \"</p>
.PP \"<p>
Either return to the performing or executing parent exodus program/library, or exit to the OS if none.
.sp 1 \"</p>
.PP \"<p>
\fBresult:\fR Optional. It will be used as the return value of a parent program's perform() or execute() function, or if none, and therefore returning to the OS, it will be output to stdout if non-numeric or, if numeric, used as the exit status.
.sp 1 \"</p>


.SS
abort(message = "")
.PP \"<p>
Abort the current exodus program/library.
.sp 1 \"</p>
.PP \"<p>
Similar to stop but if exiting to the OS then the default exit status is 1.
.sp 1 \"</p>
.PP \"<p>
\fBmessage:\fR Optional. If exiting to the OS then it will be output to stderr or, if numeric, used as the exit status.
.sp 1 \"</p>


.SS
abortall(message = "")
.PP \"<p>
Abort the current exodus program/library.
.sp 1 \"</p>
.PP \"<p>
Similar to abort but if exiting to the OS then the default exit status is 2.
.sp 1 \"</p>


.SH 4. DB FILE DICTIONARIES
.SH

.SS
var v1 = calculate(dictid);
.PP \"<p>
Get DB record field values given field name only.
.sp 1 \"</p>
.PP \"<p>
Use a dictionary file that contains info sufficient to either extract or calculate the required value.
.sp 1 \"</p>
.br
1. Read fieldinfo from the current DICT file using readc() for caching.
.br
2. Use the fieldinfo to:
.RS
.br
\(bu Either extract a specific field number from the current RECORD/ID/MV environment variables.
.br
\(bu Or call a dictionary function library to calculate the result.
.RE


.SS
var v1 = calculate(dictid, dictfile, id, record, mv = 0);
.PP \"<p>
Get DB record field values given name and data.
.sp 1 \"</p>
.PP \"<p>
Same as the one argument version of calculate() but RECORD/ID/MV are provided as arguments instead of being hard coded.
.sp 1 \"</p>


.SS
var v1 = xlate(filename, key, fieldno_or_name, mode);
.PP \"<p>
Read DB field using field number or name.
.sp 1 \"</p>
.br
1. Read a record from a given file and key using readc() for caching.
.br
2. Extracts the given field number or calls calculate(dictid...) if non-numeric.
.PP \"<p>
\fBfilename:\fR The file to read.
.sp 1 \"</p>
.PP \"<p>
\fBkey:\fR The key of the record to read.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
\fBfieldno_or_name:\fR The field  to return.
.sp 1 \"</p>
.PD 0 \"<dl>
.TP 10\"<dt>
\fBnn\fR \"</dt>
Field number nn.
.\"</dd>
.TP 10\"<dt>
\fB0\fR \"</dt>
The record key (ID).
.\"</dd>
.TP 10\"<dt>
\fB""\fR \"</dt>
The whole record (RECORD)
.\"</dd>
.TP 10\"<dt>
\fBdictid\fR \"</dt>
The function calculate(dictid) will be called.
.\"</dd>
.PD \"</dl>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
\fBmode:\fR If the record does not exist.
.sp 1 \"</p>
.PD 0 \"<dl>
.TP 10\"<dt>
\fB"X"\fR \"</dt>
Return ""
.\"</dd>
.TP 10\"<dt>
\fB"C"\fR \"</dt>
Return the key.
.\"</dd>
.PD \"</dl>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
\fBMV:\fR Environment variable. Will be used to select a particular value if not zero, or all values if zero.
.sp 1 \"</p>


.SH 5. I/O CONVERSION
.SH

.SS
var v1 = oconv(input, conversion);
.PP \"<p>
iconv/oconv "[...]"
.sp 1 \"</p>
.PP \"<p>
ExoProgram's iconv/oconv functions have access to ExoProgram's environment variables like BASEFMT, DATEFMT and TZ and have the ability to call custom functions like "[funname,args...]"
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
[NUMBER]  // built-in. See doc below.
.sp 1 \"</p>
.PP \"<p>
[DATE]    // built-in. See doc below.
.sp 1 \"</p>
.PP \"<p>
[DATEPERIOD]  e.g. [DATEPERIOD,1] [DATEPERIOD,1,12]
.sp 1 \"</p>
.PP \"<p>
[DATETIME]    e.g. [DATETIME,4*,DOS] [DATETIME,4*,MTS] [DATETIME,4*]
.sp 1 \"</p>
.PP \"<p>
[TIME2]       e.g. [TIME2,MT] [TIME2,MTS] [TIME2,MTS48]
.sp 1 \"</p>


.SS
var v1 = iconv(input, conversion);



.SH 6. IOCONV DATE/TIME 
.SH

.SS
var v1 = iconv|oconv(var, "[DATE]");
.PP \"<p>
iconv/oconv "[DATE]"
.sp 1 \"</p>
.PP \"<p>
Use iconv/oconv code "[DATE,args]" when you want date conversion to depend on the environment variable DATEFMT, particularly its American/International setting. Otherwise use ordinary "D" conversion codes directly for slightly greater performance.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
\fBvar:\fR [oconv] An internal date (a number).
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR [oconv] A readable date in text format depending on "[DATE,args]" e.g. "31 DEC 2020" "31/12/2020" "12/31/2020"
.sp 1 \"</p>
.PP \"<p>
\fBvar:\fR [iconv] A date in text format as above.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR [iconv] An internal date (a number) or "" if the input could not be understood as a valid date.
.sp 1 \"</p>
.PP \"<p>
\fBargs:\fR If args is empty then DATEFMT is used as the conversion code. If args starts with "D" then args is used as the conversion codes but any E option in DATEFMT is appended. If args does not start with "D" then args are appended to DATEFMT, a "Z" option is appended, and the result used as the conversion code. A "*" option is equivalent to a second "Z" option.
.sp 1 \"</p>
.PP \"<p>
If you are calling iconv/oconv in code and DATEFMT is adequate for your needs then pass it directly as a function argument e.g. 'var v1 = iconv|oconv(v2, DATEFORMAT);' instead of indirectly like 'var v1 = iconv|oconv(v2, "[DATE]");'.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
DATEFMT = "D/E";
let v1 = iconv("JAN 9 2025", "D");
assert(oconv(v1, "[DATE]"   ) == " 9/ 1/2025");  // "D/EZ" or "[DATE,D]" equivalent assuming D/E in DATEFMT (replace leading zeros with spaces)
assert(oconv(v1, "[DATE,4]" ) == " 9/ 1/2025");  // "D4Z"  equivalent assuming D/E in DATEFMT (replace leading zeros with spaces)
assert(oconv(v1, "[DATE,*4]") == "9/1/2025");    // "D4ZZ" equivalent assuming D/E in DATEFMT (trim leading zeros and spaces)
assert(oconv(v1, "[DATE,*]" ) == "9/1/2025");    // "DZZ"  equivalent assuming D/E in DATEFMT (trim leading zeros and spaces)
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
var v1 = iconv|oconv(var, "[NUMBER]");
.PP \"<p>
iconv/oconv "[NUMBER]"
.sp 1 \"</p>
.PP \"<p>
Use iconv/oconv "[NUMBER,args]" either when your numbers have currency or unit code suffixes or when you want number conversion to depend on the environment variable BASEFMT to determine thousands separator and decimal point. Otherwise use ordinary "MD" conversion codes directly for slightly greater performance.
.sp 1 \"</p>
.PP \"<p>
Formatting for numbers with optional currency code/unit suffix and is sensitive to the International or European setting in BASEFMT regarding use of commas or dots for thousands separators and decimal points.
.sp 1 \"</p>
.PP \"<p>
Primarily used for oconv() but can be used in reverse for iconv.
.sp 1 \"</p>
.PP \"<p>
\fBvar:\fR A number with an optional currency code or unit suffix. e.g. "12345.67USD"
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR A formatted number with thousands separated conventionally e.g. "12.345.67USD".
.sp 1 \"</p>
.PP \"<p>
iconv/oconv("[NUMBER]")      oconv leaves ndecimals untouched as in the input. iconv see below.
.sp 1 \"</p>
.PP \"<p>
iconv/oconv("[NUMBER,2]")    Specified number of decimal places
.sp 1 \"</p>
.PP \"<p>
iconv/oconv("[NUMBER,BASE]") Decimal places as per BASEFMT
.sp 1 \"</p>
.PP \"<p>
iconv/oconv("[NUMBER,*]")    Leave decimal places untouched as in the input
.sp 1 \"</p>
.PP \"<p>
iconv/oconv("[NUMBER,X]")    Leave decimal places untouched as in the input
.sp 1 \"</p>
.PP \"<p>
iconv/oconv("[NUMBER,2Z]")   Z (suppress zero) combined with any other code for oconv results in empty output "" instead of "0.00" in case of zero input.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
Empty input "" gives empty output "".
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
All leading, trailing and internal spaces are removed from the input.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
A trailing currency or unit code is ignored and returned on output.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
An exodus number is an optional leading + or - followed by one or more decimal digits 0-9 with a single optional decimal point placed anywhere.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
If the input is non-numeric then "" is returned and STATUS set to 2. In the case of oconv with multiple fields or values each field or value is processed separately but STATUS is set to 2 if any are non-numeric.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
iconv removes and oconv adds thousand separator chars. The thousands separator is  "," if BASEFMT starts with "MD" or "." if it starts with "MC".
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
\fBoconv:\fR
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
Add thousands separator chars and optionally standardise the number of decimal places.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
Multiple numbers in fields, values, subvalues etc. can be processed in one string.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
Any leading + character is preserved on output.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
Z suppresses zeros and returns empty string "" instead.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
Special format "[NUMBER,ndecs,move_ndecs]": move_ndecs causes decimal point to be shifted left if positive or right if negative.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
var v1 = oconv("1234.5USD", "[NUMBER,2]"); // "1,234.50USD" // Comma added and decimal places corrected.
.EE \"</code>
.sp 1 \"</p>
iconv:
Remove all thousands separator chars and optionally standardise the number of decimal places.
If ndecs is not specified in the "[NUMBER]" pattern then ndecs is taken from the current RECORD using dictionary code NDECS if DICT is available otherwise it uses ndecs from BASEFMT.
iconv only handles a single field/value.
Optional prefix of "1/" or "/" causes the reciprocal of the number to be used. e.g. "1/100" or "/100" -> "0.01".
.PP \"<p>
\fBExample:\fR
.EX \"<code>
var v1 = iconv("1,234.5678USD", "[NUMBER]"); // "1234.57USD" // Comma removed
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
var v1 = amountunit(input0, out unitx);
.PP \"<p>
Parse amount+currency code string.
.sp 1 \"</p>
.PP \"<p>
Split amount+currency code/unit string into number and currency code/unit.
.sp 1 \"</p>
.PP \"<p>
\fBvar:\fR "123.45USD"
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR e.g. "123.45"
.sp 1 \"</p>
.PP \"<p>
\fBunitx[out]:\fR e.g. "USD"
.sp 1 \"</p>


.SS
var v1 = amountunit(input0);



.SH 7. TIME/DATE UTILITIES
.SH

.SS
var v1 = timedate2();
.PP \"<p>
Get text of date and time.
.sp 1 \"</p>
.PP \"<p>
In users time zone
.sp 1 \"</p>
.PP \"<p>
e.g. "2MAR2025 11:52AM"
.sp 1 \"</p>
.PP \"<p>
Offset from UTC by TZ seconds.
.sp 1 \"</p>


.SS
getdatetime(out user_date, out user_time, out system_date, out system_time, out UTC_date, out UTC_time)
.PP \"<p>
Get current user, server and UTC dates and times.
.sp 1 \"</p>
.PP \"<p>
User date and time is determined by adding the environment variable TZ.f(1)'s TZ offset (in seconds) to UTC date/time obtained from the operating system.
.sp 1 \"</p>
.PP \"<p>
"system" date and time is normally the same as UTC date/time and is determined by adding the environment variable TZ.f(2)'s TZ offset (in seconds) to UTC date/time obtained from the operating system.
.sp 1 \"</p>


.SS
var v1 = elapsedtimetext();
.PP \"<p>
Get text of elapsed time.
.sp 1 \"</p>
.PP \"<p>
Since environment variable TIMESTAMP.
.sp 1 \"</p>
.PP \"<p>
TIMESTAMP is initialised with ostimestamp() at program/thread startup.
.sp 1 \"</p>
.PP \"<p>
TIMESTAMP can be updated using ostimestamp() as and when desired.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
var v1 = elapsedtimetext(); // e.g. "< 1ms"
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
var v1 = elapsedtimetext(timestamp1, timestamp2);
.PP \"<p>
Get text of elapsed time.
.sp 1 \"</p>
.PP \"<p>
Between two given timestamps
.sp 1 \"</p>
.PP \"<p>
\fBWarning:\fR Use ostimestamp() not ostime(). The first is in days and the second is in seconds.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
let v1 = elapsedtimetext(0, 0.55);  // "13 hours, 12 mins"
let v2 = elapsedtimetext(0, 0.001); // "1 min, 26 secs"
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SH 8. TERMINAL I/O UTILITIES
.SH

.SS
note(msg, options, io response)
.PP \"<p>
Output a message to stdout and optionally request input.
.sp 1 \"</p>
.PP \"<p>
If input is requested but stdin is not a terminal then set the response to "" and continue.
.sp 1 \"</p>
.PP \"<p>
\fBoptions:\fR R = Response requested. C upper case response.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
var response;
// call note("Enter something", "RC", response);
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
note(msg)
.PP \"<p>
Output a message to stdout.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
call note("Hello world.");
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
var v1 = decide(question, options = "");
.PP \"<p>
Input user selection from a list of options.
.sp 1 \"</p>
.PP \"<p>
If stdin is not a terminal, set the response to "" and continue.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR The chosen option (value not number) or "" if the user cancelled.
.sp 1 \"</p>


.SS
var v1 = decide(question, options, out reply, defaultreply = 1);
.PP \"<p>
Input user selection from a list of options.
.sp 1 \"</p>
.PP \"<p>
If stdin is not a terminal set the response to the default value, or "" if none, and continue.
.sp 1 \"</p>
.PP \"<p>
\fBdefaultreply:\fR A default option if the user presses Enter.
.sp 1 \"</p>
.PP \"<p>
\fBreply[out]:\fR The option number that the user chose or "" if they cancelled.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR The chosen option (value not number) or "" if the user cancelled.
.sp 1 \"</p>


.SS
if (esctoexit()) ...
.PP \"<p>
Check for user pause or cancel.
.sp 1 \"</p>
.PP \"<p>
If stdin is a terminal, check if a key has been pressed and, if so, pause execution and ask the user to confirm if they want to escape/cancel or resume processing.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR
.sp 1 \"</p>
.PD 0 \"<dl>
.TP 10\"<dt>
\fBTrue\fR \"</dt>
A key has been pressed and the user chose not to resume.
.\"</dd>
.TP 10\"<dt>
\fBFalse\fR \"</dt>
stdif is not a terminal, no key has been pressed, or the user chose to resume.
.\"</dd>
.PD \"</dl>


.SS
var v1 = AT(code);
.PP \"<p>
Get a string to control terminal operation.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR A string to be output to the terminal in order to accomplish the desired operation.
.sp 1 \"</p>
.PP \"<p>
The terminal protocol is xterminal.
.sp 1 \"</p>
.PP \"<p>
\fBcode:\fR
.sp 1 \"</p>
.PD 0 \"<dl>
.TP 10\"<dt>
\fB n\fR \"</dt>
Position the cursor at column number n (1 based).
.\"</dd>
.TP 10\"<dt>
\fB 0\fR \"</dt>
Position the cursor at the first column (1).
.\"</dd>
.TP 10\"<dt>
\fB -1\fR \"</dt>
Clear the screen and home the cursor.
.\"</dd>
.TP 10\"<dt>
\fB -2\fR \"</dt>
Position the cursor at the top left home (x, y = 1, 1).
.\"</dd>
.TP 10\"<dt>
\fB -3\fR \"</dt>
Clear from the cursor at the end of screen.
.\"</dd>
.TP 10\"<dt>
\fB -4\fR \"</dt>
Clear from cursor to end of line.
.\"</dd>
.TP 10\"<dt>
\fB-40\fR \"</dt>
Position the cursor at columnno 0 and clear to end of line.
.\"</dd>
.PD \"</dl>


.SS
var v1 = AT(x, y);
.PP \"<p>
Get a terminal cursor positioning string.
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR A string to be output to the terminal to position the cursor at the desired screen x and y position.
.sp 1 \"</p>
.PP \"<p>
The terminal protocol is xterminal.
.sp 1 \"</p>


.SS
if (getcursor(out cursor, delayms = 3000, max_errors = 0)) ...
.PP \"<p>
Get the position of the terminal cursor.
.sp 1 \"</p>
.PP \"<p>
\fBcursor[out]:\fR If stdin is a terminal, an FM delimited string containing the x and y coordinates of the current terminal cursor.
.sp 1 \"</p>
.PP \"<p>
x and y are 1 based, not 0 based.
.sp 1 \"</p>
.PP \"<p>
If stdin is not a terminatl then an empty string "" is returned.
.sp 1 \"</p>
.PP \"<p>
The cursor additionally contains a third field which contains the delay in ms from the terminal.
.sp 1 \"</p>
.PP \"<p>
The FM delimited string returned can be later passed to setcursor() to reposition the cursor back to its original position or it can be parsed and used accordingly.
.sp 1 \"</p>
.PP \"<p>
\fBdelayms:\fR Default 3000ms. The maximum time to wait for terminal response.
.sp 1 \"</p>
.PP \"<p>
\fBmax_errors:\fR Default is 0. If not zero, reset the number of times to error before automatically disabling getcursor(). max_errors is initialised to 3. If negative then max_errors has the the effect of disabling all future calls to getcursor().
.sp 1 \"</p>
.PP \"<p>
In case the terminal fails to respond correctly within the required timeout, or is currently disabled due to too many failures, or has been specifically disabled then the returned "cursor" var contains a 4th field:
.sp 1 \"</p>
.PD 0 \"<dl>
.TP 10\"<dt>
\fBTIMEOUT\fR \"</dt>
The terminal failed to respond within the timeout.
.\"</dd>
.TP 10\"<dt>
\fBREAD_ERROR\fR \"</dt>
Failed to read terminal response.
.\"</dd>
.TP 10\"<dt>
\fBINVALID_RESPONSE\fR \"</dt>
Terminal response invalid.
.\"</dd>
.TP 10\"<dt>
\fBSETUP_ERROR\fR \"</dt>
Terminal setup failed.
.\"</dd>
.TP 10\"<dt>
\fBDISABLED\fR \"</dt>
Terminal is disabled due to more errors than the maximum currently set.
.\"</dd>
.PD \"</dl>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
var cursor;
if (isterminal() and not getcursor(cursor)) ... // cursor becomes something like "1^20^0.012345"_var
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
var v1 = getcursor();
.PP \"<p>
Get the position of the terminal cursor.
.sp 1 \"</p>
.PP \"<p>
For more info see the main getcursor() function above.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
let cursor = getcursor(); // If isterminal() then cursor becomes something like "0^20^0.012345"_var
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
setcursor(cursor_coordinates)
.PP \"<p>
If stdin is a terminal, position the cursor at x and y as per the given coordinates.
.sp 1 \"</p>
.PP \"<p>
\fBcursor_coordinates:\fR An FM delimited string containing the x and y coordinates of the terminal cursor as can be obtained by getcursor().
.PP \"<p>
\fBExample:\fR
.EX \"<code>
if (isterminal()) {
    let cursor = getcursor(); // Save the current cursor position.
    TRACE(cursor)             // Show the saved cursor position.
    print(AT(0,0));           // Position the cursor at 0,0.
    setcursor(cursor);        // Restore its position
}
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SH 9. ARRAY UTILITIES
.SH

.SS
var v1 = invertarray(input, pad = false);
.PP \"<p>
Dynamic array fields become values and vice versa
.sp 1 \"</p>
.PP \"<p>
\fBreturn:\fR The inverted dynamic array.
.sp 1 \"</p>
.PP \"<p>
\fBpad:\fR If true then on return, all fields will have the same number of values with superfluous trailing VMs where necessary.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
let v1 = "a]b]c^1]2]3"_var;
let v2 = invertarray(v1); // "a]1^b]2^c]3"_var
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
sortarray(io array, fns = "", order = "")
.PP \"<p>
Sort parallel fields of multivalues of dynamic arrays
.sp 1 \"</p>
.PP \"<p>
\fBfns:\fR VM separated list of field numbers to sort in parallel based on the first field number
.sp 1 \"</p>
.PP \"<p>
\fBorder:\fR
.sp 1 \"</p>
.PD 0 \"<dl>
.TP 10\"<dt>
\fBAL\fR \"</dt>
Ascending  - Left Justified (Alphabetic)
.\"</dd>
.TP 10\"<dt>
\fBDL\fR \"</dt>
Descending - Left Justified (Alphabetic)
.\"</dd>
.TP 10\"<dt>
\fBAR\fR \"</dt>
Ascending  - Right Justified (Numeric/Natural)
.\"</dd>
.TP 10\"<dt>
\fBDR\fR \"</dt>
Descending - Right Justified (Numeric/Natural)
.\"</dd>
.PD \"</dl>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
var v1 = "f1^10]20]2]1^ww]xx]yy]zz^f3^f4"_var;  // fields 2 and 3 are parallel multivalues and currently unordered.
sortarray(v1, "2]3"_var, "AR"); // v1 -> "f1^1]2]10]20^zz]yy]ww]xx^f3^f4"_var
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SH 10. RECORD LOCKING
.SH

.SS
if (lockrecord(filename, io file, keyx, unused, waitsecs = 0, allowduplicate = false)) ...



.SS
if (lockrecord(filename, io file, keyx)) ...



.SS
if (unlockrecord(filename, io file, key)) ...



.SS
if (unlockrecord()) ...




