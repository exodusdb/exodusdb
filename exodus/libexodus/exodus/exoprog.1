.TH exoprog.h

.SH 1. SELECT LISTS
.SH

.SS
if (select(sortselectclause_or_filehandle = "")) ...
.PP \"<p>
Create an active select list using a natural language sort/select command.
.sp 1 \"</p>
.PP \"<p>
This and all the following exoprog member functions work on an environment variable CURSOR.
.sp 1 \"</p>
.PP \"<p>
Identical functions are available directly on plain var objects but vars have less functionality regarding dictionaries and environment variables which are built-in to exoprog.
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR True if an active select list was created, false otherwise.
.sp 1 \"</p>
.PP \"<p>
In the following examples, various environment variables like RECORD, ID and MV are used instead of declaring and using named vars. In actual code, either may be freely used.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
select("xo_clients by name by type with type 'A' 'B' and with balance between 0 and 2000");
if (readnext(ID)) ... ok
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (selectkeys(keys)) ...
.PP \"<p>
Create an active select list from some given keys.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
selectkeys("SB001^JB001^JB002"_var);
if (readnext(ID)) ... ok // ID -> "SB001"
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (hasnext()) ...
.PP \"<p>
Check if a select list is active.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
if (hasnext()) ... ok
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (readnext(out key)) ...
.PP \"<p>
Get the next key from an active select list.
.sp 1 \"</p>
.PP \"<p>
\fBkey:\fR [out] A string. Typically the key of a db file record.
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR True if an active select list was available and the next key in the list was obtained.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
selectkeys("SB001^JB001^JB002"_var);
if (readnext(ID)) ... ok // ID -> "SB001"
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (readnext(out key, out valueno)) ...
.PP \"<p>
Get the next key and value number pair from an active select list.
.sp 1 \"</p>
.PP \"<p>
\fBkey:\fR [out] A string. Typically the key of a db file record.
.sp 1 \"</p>
.PP \"<p>
\fBvalueno:\fR [out] Is only available in select lists that have been created by sort/select commands that refer to multi-valued db dictionary fields where db records have multiple values for a specific field. In this case, a record key will appear multiple times in the select list since each multivalue is exploded for the purpose of sorting and selecting. This can be viewed as a process of "normalising" multivalues so they appear as multiple records instead of being held in a single record.
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR True if an active select list was available and the next key in the list was obtained.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
selectkeys("SB001]2^SB001]1^JB001]2"_var);
if (readnext(ID, MV)) ... ok // ID -> "SB001" // MV -> 2
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (readnext(out record, out key, out valueno)) ...
.PP \"<p>
Get the next record, key and value no from an active select list.
.sp 1 \"</p>
.PP \"<p>
\fBrecord:\fR [out] Is only available in select lists that have been created with the final (R) option. Otherwise the record will be returned as an empty string and must be obtained using a db read() function.
.sp 1 \"</p>
.PP \"<p>
\fBkey:\fR [out] A string. Typically the key of a db file record.
.sp 1 \"</p>
.PP \"<p>
\fBvalueno:\fR [out] Is only available in select lists that have been created by sort/select commands that refer to multi-valued db dictionary fields where db records have multiple values for a specific field.
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR True if an active select list was available and the next key in the list was obtained.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
select("xo_clients by name (R)");
if (readnext(RECORD, ID, MV)) ... ok;
assert(not RECORD.empty());
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
pushselect(out cursor)
.PP \"<p>
Saves a pointer to the currently active select list.
.sp 1 \"</p>
.PP \"<p>
This allows another select list to be activated and used temporarily before the original select list is reactivated.
.sp 1 \"</p>
.PP \"<p>
\fBcursor:\fR [out] A var that can be passed later on to the popselect() function to reactivate the saved list.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
select("xo_clients by name");
var saved_xo_clients_cursor;
pushselect(saved_xo_clients_cursor);
//
// ... work with another select list ...
//
popselect(saved_xo_clients_cursor); // Reactivate the original select list.
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
popselect(cursor)
.PP \"<p>
Re-establish an active select list saved by pushselect().
.sp 1 \"</p>
.PP \"<p>
\fBcursor:\fR A var created by the pushselect() function.
.sp 1 \"</p>
.PP \"<p>
See pushselect() for more info.
.sp 1 \"</p>


.SS
clearselect()
.PP \"<p>
Deactivate an active select list.
.sp 1 \"</p>
.PP \"<p>
If no select list is active then nothing is done.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
clearselect();
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (deleterecord(filename)) ...
.PP \"<p>
Use an active select list to delete db records.
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR False if any records could not be deleted.
.sp 1 \"</p>
.PP \"<p>
Contrast this function with the two argument "deleterecord(file, key)" function that deletes a single record.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
if (select("xo_clients with type 'Q' and with balance between 0 and 100")) {
  if (deleterecord("xo_clients")) ...
}
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (deleterecord(dbfile, key)) ...
.PP \"<p>
Delete a single database file record.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
let file = "xo_clients", key = "QQ001";
write("" on file, key);
if (not deleterecord(file, key)) ...
// or
write("" on file, key);
if (not file.deleterecord(key)) ...
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (savelist(listname)) ...
.PP \"<p>
Save a currently active select list under a given name.
.sp 1 \"</p>
.PP \"<p>
After saving, the list is no longer active and hasnext() will return false.
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR True if an active select list was saved, false if there was no active select list.
.sp 1 \"</p>
.PP \"<p>
Lists are saved as a record in the "lists" file.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
selectkeys("SB001^SB002"_var);
if (not savelist("my_list")) ...
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (getlist(listname)) ...
.PP \"<p>
Reactivate a saved select list of a given name.
.sp 1 \"</p>
.PP \"<p>
A saved list is obtained from the "lists" file and activated.
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR True if an active select list was successfully reactivated, otherwise false.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
if (not getlist("my_list")) ...
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (deletelist(listname)) ...
.PP \"<p>
Remove a saved select list by name.
.sp 1 \"</p>
.PP \"<p>
A saved list is deleted from the "lists" file.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
if (not deletelist("my_list")) ...
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
if (formlist(filename_or_command, keys = "", fieldno = 0)) ...



.SS
if (makelist(listname, keys)) ...



.SH 2. PERFORM/EXECUTE
.SH

.SS
var v1 = perform(command_line);
.PP \"<p>
Run an exodus program/library's main function using a command like syntax similar to that of os executable programs.
.sp 1 \"</p>
.PP \"<p>
\fBcommand_line:\fR Used to initialise the COMMAND, SENTENCE and OPTIONS environment variables of the performed exodus program/library. Analogous to passing function arguments. The first word of command_line is used as the name of the program/library to be loaded and run.
.sp 1 \"</p>
.PP \"<p>
The program/library's main function should have zero arguments. Performing a program/library function with main arguments results in them being unassigned and in some case core dump may occur.
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR Whatever var the program/library returns, or "" if it calls stop() or abort((). The return value can be ignored and discarded without any compiler warning.
.sp 1 \"</p>
.PP \"<p>
The following environment variables are initialised on entry to the main function of the program/library and are preserved untouched in the calling program.
.sp 1 \"</p>
.PP \"<p>
RECUR0, RECUR1, RECUR2, RECUR3, RECUR4 to "".
.sp 1 \"</p>
.PP \"<p>
ID, RECORD, MV, DICT initialised to "".
.sp 1 \"</p>
.PP \"<p>
LEVEL is incremented by one.
.sp 1 \"</p>
.PP \"<p>
All other environment variables are shared between the caller and callee. There is essentially only one environment in any one process or thread.
.sp 1 \"</p>
.PP \"<p>
Any active select list in CURSOR is passed to the performed program/library and can be consumed by it. Conversely any active select list created by the performed program/library will be returned to the calling program. In other words, both the performing and the performed programs/libraries share a single active select list environment. This is different from execute() which gets its own private active select list, initially inactive.
.sp 1 \"</p>
.PP \"<p>
Exodus program/libraries may also be called directly using conventional function calling syntax. To call an exodus program/library called progname using either the syntax "call progname(args...);" or "var v1 = progname(args...);" you must "#include <progname.h>" after the "programinit()" or "libraryinit()" lines in your program/library.
.sp 1 \"</p>


.SS
var v1 = execute(command_line);
.PP \"<p>
Run an exodus program/library's main function.
.sp 1 \"</p>
.PP \"<p>
Identical to perform() but any currently active select list in the calling program/library is not accessible to the executed program/library and is preserved in the calling [program as is. Any select list created by the executed library is discarded when it terminates.
.sp 1 \"</p>


.SS
chain(command_line)
.PP \"<p>
Close the current program and perform another one.
.sp 1 \"</p>
.PP \"<p>
Identical to perform() except that the current program closes first.
.sp 1 \"</p>


.SS
var v1 = libinfo(libname);
.PP \"<p>
Check if a lib exists to be performed/executed or called. Currently it does not check if it is actually loadable.
.sp 1 \"</p>


.SH 3. PROGRAM TERMINATION 
.SH

.SS
stop(message = "")
.PP \"<p>
Stop the current exodus program/library normally.
.sp 1 \"</p>
.PP \"<p>
Either return to the performing or executing parent exodus program/library, or exit to the OS if none.
.sp 1 \"</p>
.PP \"<p>
\fBmessage:\fR Optional. If exiting to the OS then it will be output to stdout or, if numeric, used as the exit status.
.sp 1 \"</p>


.SS
abort(message = "")
.PP \"<p>
Abort the current exodus program/library.
.sp 1 \"</p>
.PP \"<p>
Similar to stop but if exiting to the OS then the default exit status is 1.
.sp 1 \"</p>
.PP \"<p>
\fBmessage:\fR Optional. If exiting to the OS then it will be output to stderr or, if numeric, used as the exit status.
.sp 1 \"</p>


.SS
abortall(message = "")
.PP \"<p>
Abort the current exodus program/library.
.sp 1 \"</p>
.PP \"<p>
Similar to abort but if exiting to the OS then the default exit status is 2.
.sp 1 \"</p>


.SH 4. DB FILE DICTIONARIES
.SH

.SS
var v1 = calculate(dictid);
.PP \"<p>
Given a dictid reads a dictrec from the current DICT file (using readc()) and then either extracts a specific field number from the current RECORD/ID/MV environment variables or calls a dict function library to calculate the result.
.sp 1 \"</p>


.SS
var v1 = calculate(dictid, dictfile, id, record, mv = 0);
.PP \"<p>
Given dictid, dictfile, record, id and mv, reads a dictrec from dictfile (using readc()) and then either extracts a specific field number from the given record/id/mv or calls a dict function library to calculate the result.
.sp 1 \"</p>


.SS
var v1 = xlate(filename, key, fieldno_or_name, mode);
.PP \"<p>
Reads a record from the specified file and key (using readc()) and then either extracts a specific field number or calls calculate(dictid...) to obtain the result.
.sp 1 \"</p>
.PP \"<p>
\fBfilename:\fR Which file to read.
.sp 1 \"</p>
.PP \"<p>
\fBkey:\fR The key of the record to read.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
\fBfieldno_or_name:\fR The field  to return.
.sp 1 \"</p>
.PD 0 \"<dl>
.TP 10\"<dt>
\fBnn\fR \"</dt>
Field number nn.
.\"</dd>
.TP 10\"<dt>
\fB0\fR \"</dt>
The record key (ID).
.\"</dd>
.TP 10\"<dt>
\fB""\fR \"</dt>
The whole record (RECORD)
.\"</dd>
.TP 10\"<dt>
\fBdictid\fR \"</dt>
The function calculate(dictid) will be called.
.\"</dd>
.PD \"</dl>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
\fBmode:\fR If the record does not exist.
.sp 1 \"</p>
.PD 0 \"<dl>
.TP 10\"<dt>
\fB"X"\fR \"</dt>
Return ""
.\"</dd>
.TP 10\"<dt>
\fB"C"\fR \"</dt>
Return the key.
.\"</dd>
.PD \"</dl>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
\fBMV:\fR Environment variable. Will be used to select a particular value if not zero, or all values if zero.
.sp 1 \"</p>


.SH 5. I/O CONVERSION
.SH

.SS
var v1 = oconv(input, conversion);
.PP \"<p>
iconv/oconv with access to exoprogram's environment variables.
.sp 1 \"</p>
.PP \"<p>
exoprog's iconv/oconv have the ability to call custom functions like "[funname,args...]"
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
[NUMBER]  // built-in. See doc below.
.sp 1 \"</p>
.PP \"<p>
[DATE]    // built-in. See doc below.
.sp 1 \"</p>
.PP \"<p>
[DATEPERIOD]  e.g. [DATEPERIOD,1] [DATEPERIOD,1,12]
.sp 1 \"</p>
.PP \"<p>
[DATETIME]    e.g. [DATETIME,4*,DOS] [DATETIME,4*,MTS] [DATETIME,4*]
.sp 1 \"</p>
.PP \"<p>
[TIME2]       e.g. [TIME2,MT] [TIME2,MTS] [TIME2,MTS48]
.sp 1 \"</p>


.SS
var v1 = iconv(input, conversion);



.SH 6. IOCONV DATE/TIME 
.SH

.SS
var v1 = iconv|oconv(var, "[DATE]");
.PP \"<p>
Use iconv/oconv code "[DATE,args]" when you want date conversion to depend on the environment variable DATEFMT, particularly its American/International setting. Otherwise use ordinary "D" conversion codes directly for slightly greater performance.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
\fBvar:\fR [oconv] An internal date (a number).
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR [oconv] A readable date in text format depending on "[DATE,args]" e.g. "31 DEC 2020" "31/12/2020" "12/31/2020"
.sp 1 \"</p>
.PP \"<p>
\fBvar:\fR [iconv] A date in text format as above.
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR [iconv] An internal date (a number) or "" if the input could not be understood as a valid date.
.sp 1 \"</p>
.PP \"<p>
\fBargs:\fR If args is empty then DATEFMT is used as the conversion code. If args starts with "D" then args is used as the conversion codes but any E option in DATEFMT is appended. If args does not start with "D" then args are appended to DATEFMT, a "Z" option is appended, and the result used as the conversion code. A "*" option is equivalent to a second "Z" option.
.sp 1 \"</p>
.PP \"<p>
If you are calling iconv/oconv in code and DATEFMT is adequate for your needs then pass it directly as a function argument e.g. 'var v1 = iconv|oconv(v2, DATEFORMAT);' instead of indirectly like 'var v1 = iconv|oconv(v2, "[DATE]");'.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
DATEFMT = "D/E";
let v1 = iconv("JAN 9 2025", "D");
assert(oconv(v1, "[DATE]"   ) == " 9/ 1/2025");  // "D/EZ" or "[DATE,D]" equivalent assuming D/E in DATEFMT (replace leading zeros with spaces)
assert(oconv(v1, "[DATE,4]" ) == " 9/ 1/2025");  // "D4Z"  equivalent assuming D/E in DATEFMT (replace leading zeros with spaces)
assert(oconv(v1, "[DATE,*4]") == "9/1/2025");    // "D4ZZ" equivalent assuming D/E in DATEFMT (trim leading zeros and spaces)
assert(oconv(v1, "[DATE,*]" ) == "9/1/2025");    // "DZZ"  equivalent assuming D/E in DATEFMT (trim leading zeros and spaces)
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
var v1 = iconv|oconv(var, "[NUMBER]");
.PP \"<p>
Use iconv/oconv "[NUMBER,args]" either when your numbers have currency or unit code suffixes or when you want number conversion to depend on the environment variable BASEFMT to determine thousands separator and decimal point. Otherwise use ordinary "MD" conversion codes directly for slightly greater performance.
.sp 1 \"</p>
.PP \"<p>
Formatting for numbers with optional currency code/unit suffix and is sensitive to the International or European setting in BASEFMT regarding use of commas or dots for thousands separators and decimal points.
.sp 1 \"</p>
.PP \"<p>
Primarily used for oconv() but can be used in reverse for iconv.
.sp 1 \"</p>
.PP \"<p>
\fBvar:\fR A number with an optional currency code or unit suffix. e.g. "12345.67USD"
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR A formatted number with thousands separated conventionally e.g. "12.345.67USD".
.sp 1 \"</p>
.PP \"<p>
iconv/oconv("[NUMBER]")      oconv leaves ndecimals untouched as in the input. iconv see below.
.sp 1 \"</p>
.PP \"<p>
iconv/oconv("[NUMBER,2]")    Specified number of decimal places
.sp 1 \"</p>
.PP \"<p>
iconv/oconv("[NUMBER,BASE]") Decimal places as per BASEFMT
.sp 1 \"</p>
.PP \"<p>
iconv/oconv("[NUMBER,*]")    Leave decimal places untouched as in the input
.sp 1 \"</p>
.PP \"<p>
iconv/oconv("[NUMBER,X]")    Leave decimal places untouched as in the input
.sp 1 \"</p>
.PP \"<p>
iconv/oconv("[NUMBER,2Z]")   Z (suppress zero) combined with any other code for oconv results in empty output "" instead of "0.00" in case of zero input.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
Empty input "" gives empty output "".
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
All leading, trailing and internal spaces are removed from the input.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
A trailing currency or unit code is ignored and returned on output.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
An exodus number is an optional leading + or - followed by one or more decimal digits 0-9 with a single optional decimal point placed anywhere.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
If the input is non-numeric then "" is returned and STATUS set to 2. In the case of oconv with multiple fields or values each field or value is processed separately but STATUS is set to 2 if any are non-numeric.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
iconv removes and oconv adds thousand separator chars. The thousands separator is  "," if BASEFMT starts with "MD" or "." if it starts with "MC".
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
\fBoconv:\fR
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
Add thousands separator chars and optionally standardise the number of decimal places.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
Multiple numbers in fields, values, subvalues etc. can be processed in one string.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
Any leading + character is preserved on output.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
Z suppresses zeros and returns empty string "" instead.
.sp 1 \"</p>
.PP \"<p>
.sp 1 \"</p>
.PP \"<p>
Special format "[NUMBER,ndecs,move_ndecs]": move_ndecs causes decimal point to be shifted left if positive or right if negative.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
var v1 = oconv("1234.5USD", "[NUMBER,2]"); // "1,234.50USD" // Comma added and decimal places corrected.
.EE \"</code>
.sp 1 \"</p>
iconv:
Remove all thousands separator chars and optionally standardise the number of decimal places.
If ndecs is not specified in the "[NUMBER]" pattern then ndecs is taken from the current RECORD using dictionary code NDECS if DICT is available otherwise it uses ndecs from BASEFMT.
iconv only handles a single field/value.
Optional prefix of "1/" or "/" causes the reciprocal of the number to be used. e.g. "1/100" or "/100" -> "0.01".
.PP \"<p>
\fBExample:\fR
.EX \"<code>
var v1 = iconv("1,234.5678USD", "[NUMBER]"); // "1234.57USD" // Comma removed
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
var v1 = amountunit(input0, out unitx);
.PP \"<p>
Split amount+currency code/unit string into number and currency code/unit.
.sp 1 \"</p>
.PP \"<p>
\fBvar:\fR "123.45USD"
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR e.g. "123.45"
.sp 1 \"</p>
.PP \"<p>
\fBunitx:\fR [out] e.g. "USD"
.sp 1 \"</p>


.SS
var v1 = amountunit(input0);



.SH 7. TIME/DATE UTILITIES
.SH

.SS
var v1 = timedate2();
.PP \"<p>
\fBReturns:\fR Text of date and time in users time zone
.sp 1 \"</p>
.PP \"<p>
e.g. "2MAR2025 11:52AM"
.sp 1 \"</p>
.PP \"<p>
Offset from UTC by TZ seconds.
.sp 1 \"</p>


.SS
getdatetime(out user_date, out user_time, out system_date, out system_time, out UTC_date, out UTC_time)
.PP \"<p>
\fBReturns:\fR User, server and UTC date and time
.sp 1 \"</p>
.PP \"<p>
User date and time is determined by adding the environment variable TZ.f(1)'s TZ offset (in seconds) to UTC date/time obtained from the operating system.
.sp 1 \"</p>
.PP \"<p>
"system" date and time is normally the same as UTC date/time and is determined by adding the environment variable TZ.f(2)'s TZ offset (in seconds) to UTC date/time obtained from the operating system.
.sp 1 \"</p>


.SS
var v1 = elapsedtimetext();
.PP \"<p>
Get text of elapsed time since environment variable TIMESTAMP was initialised with ostimestamp() at program/thread startup.
.sp 1 \"</p>
.PP \"<p>
TIMESTAMP can be updated using ostimestamp() as and when desired.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
var v1 = elapsedtimetext(); // e.g. "< 1ms"
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
var v1 = elapsedtimetext(timestamp1, timestamp2);
.PP \"<p>
Get text of elapsed time between two timestamps
.sp 1 \"</p>
.PP \"<p>
Caution. Use ostimestamps not ostimes. One is in days and the other is in seconds.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
let v1 = elapsedtimetext(0, 0.55);  // "13 hours, 12 mins"
let v2 = elapsedtimetext(0, 0.001); // "1 min, 26 secs"
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SH 8. TERMINAL I/O UTILITIES
.SH

.SS
note(msg, options, io response)
.PP \"<p>
If stdin is a terminal, output a message to stdout and optionally pause processing and request a response from the user, otherwise set the response to "" and continue.
.sp 1 \"</p>
.PP \"<p>
\fBoptions:\fR R = Response requested. C upper case response.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
var response;
// call note("Enter something", "RC", response);
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
note(msg)
.PP \"<p>
Output a message to stdin and continue.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
call note("Hello world.");
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
var v1 = decide(question, options = "");
.PP \"<p>
If stdin is a terminal, pause processing, list some given options to stdout and request the user to make a choice, otherwise set the response to "" and continue.
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR The chosen option (value not number) or "" if the user cancelled.
.sp 1 \"</p>


.SS
var v1 = decide(question, options, out reply, defaultreply = 1);
.PP \"<p>
Same as decide() above but extended.
.sp 1 \"</p>
.PP \"<p>
\fBdefaultreply:\fR A default option if the user presses Enter.
.sp 1 \"</p>
.PP \"<p>
\fBreply:\fR [out] The option number that the user chose or "" if they cancelled.
.sp 1 \"</p>


.SS
if (esctoexit()) ...
.PP \"<p>
If stdin is a terminal, check if a key has been pressed and, if so, pause execution and ask the user to confirm if they want to escape/cancel or resume processing.
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR True if a key has been pressed and the user confirms to escape/cancel. False if no key has been pressed or the user chooses to resume and not escape/cancel.
.sp 1 \"</p>


.SS
var v1 = AT(code);
.PP \"<p>
Get a string to control terminal operation.
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR A string to be output to the terminal in order to accomplish the desired operation.
.sp 1 \"</p>
.PP \"<p>
The terminal protocol is xterminal.
.sp 1 \"</p>
.PP \"<p>
\fBcode:\fR
.sp 1 \"</p>
.PD 0 \"<dl>
.TP 10\"<dt>
\fBn\fR \"</dt>
Position the cursor at column number n
.\"</dd>
.TP 10\"<dt>
\fB0\fR \"</dt>
Position the cursor at column number 0
.\"</dd>
.TP 10\"<dt>
\fB-1\fR \"</dt>
Clear the screen and home the cursor
.\"</dd>
.TP 10\"<dt>
\fB-2\fR \"</dt>
Position the cursor at the top left home (x,y = 0,0)
.\"</dd>
.TP 10\"<dt>
\fB-3\fR \"</dt>
Clear from the cursor at the end of screen
.\"</dd>
.TP 10\"<dt>
\fB-4\fR \"</dt>
Clear from cursor to end of line
.\"</dd>
.TP 10\"<dt>
\fB-40\fR \"</dt>
Position the cursor at columnno 0 and clear to end of line
.\"</dd>
.PD \"</dl>


.SS
var v1 = AT(x, y);
.PP \"<p>
Get a terminal cursor positioning string.
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR A string to be output to the terminal to position the cursor at the desired screen x and y position.
.sp 1 \"</p>
.PP \"<p>
The terminal protocol is xterminal.
.sp 1 \"</p>


.SS
if (getcursor(out cursor, delayms = 3000, max_errors = 0)) ...
.PP \"<p>
Get the position of the terminal cursor.
.sp 1 \"</p>
.PP \"<p>
\fBcursor:\fR [out] If stdin is a terminal, an FM delimited string containing the x and y coordinates of the current terminal cursor.
.sp 1 \"</p>
.PP \"<p>
If stdin is not a terminatl then an empty string "" is returned.
.sp 1 \"</p>
.PP \"<p>
The cursor additionally contains a third field which contains the delay in ms from the terminal.
.sp 1 \"</p>
.PP \"<p>
The FM delimited string returned can be later passed to setcursor() to reposition the cursor back to its original position or it can be parsed and used accordingly.
.sp 1 \"</p>
.PP \"<p>
\fBdelayms:\fR Default 3000ms. The maximum time to wait for terminal response.
.sp 1 \"</p>
.PP \"<p>
\fBmax_errors:\fR Default is 0. If not zero, reset the number of times to error before automatically disabling getcursor(). max_errors is initialised to 3. If negative then max_errors has the the effect of disabling all future calls to getcursor().
.sp 1 \"</p>
.PP \"<p>
In case the terminal fails to respond correctly within the required timeout, or is currently disabled due to too many failures, or has been specifically disabled then the returned "cursor" var contains a 4th field:
.sp 1 \"</p>
.PD 0 \"<dl>
.TP 10\"<dt>
\fBTIMEOUT\fR \"</dt>
The terminal failed to respond within the timeout.
.\"</dd>
.TP 10\"<dt>
\fBREAD_ERROR\fR \"</dt>
Failed to read terminal response.
.\"</dd>
.TP 10\"<dt>
\fBINVALID_RESPONSE\fR \"</dt>
Terminal response invalid.
.\"</dd>
.TP 10\"<dt>
\fBSETUP_ERROR\fR \"</dt>
Terminal setup failed.
.\"</dd>
.TP 10\"<dt>
\fBDISABLED\fR \"</dt>
Terminal is disabled due to more errors than the maximum currently set.
.\"</dd>
.PD \"</dl>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
var cursor;
if (isterminal() and not getcursor(cursor)) ... // cursor becomes something like "0^20^0.012345"_var
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
var v1 = getcursor();
.PP \"<p>
Get the position of the terminal cursor.
.sp 1 \"</p>
.PP \"<p>
For more info see the main getcursor() function above.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
let cursor = getcursor(); // If isterminal() then cursor becomes something like "0^20^0.012345"_var
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
setcursor(cursor_coordinates)
.PP \"<p>
If stdin is a terminal, position the cursor at x and y as per the given coordinates.
.sp 1 \"</p>
.PP \"<p>
\fBcursor_coordinates:\fR An FM delimited string containing the x and y coordinates of the terminal cursor as can be obtained by getcursor().
.PP \"<p>
\fBExample:\fR
.EX \"<code>
if (isterminal()) {
    let cursor = getcursor(); // Save the current cursor position.
    TRACE(cursor)             // Show the saved cursor position.
    print(AT(0,0));           // Position the cursor at 0,0.
    setcursor(cursor);        // Restore its position
}
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SH 9. ARRAY UTILITIES
.SH

.SS
var v1 = invertarray(input, pad = false);
.PP \"<p>
Dynamic array fields become values and vice versa
.sp 1 \"</p>
.PP \"<p>
\fBReturns:\fR The inverted dynamic array.
.sp 1 \"</p>
.PP \"<p>
\fBpad:\fR If true then on return, all fields will have the same number of values with superfluous trailing VMs where necessary.
.sp 1 \"</p>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
let v1 = "a]b]c^1]2]3"_var;
let v2 = invertarray(v1); // "a]1^b]2^c]3"_var
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SS
sortarray(io array, fns = "", order = "")
.PP \"<p>
Sorts fields of multivalues of dynamic arrays in parallel
.sp 1 \"</p>
.PP \"<p>
\fBfns:\fR VM separated list of field numbers to sort in parallel based on the first field number
.sp 1 \"</p>
.PP \"<p>
\fBorder:\fR
.sp 1 \"</p>
.PD 0 \"<dl>
.TP 10\"<dt>
\fBAL\fR \"</dt>
Ascending  - Left Justified (Alphabetic)
.\"</dd>
.TP 10\"<dt>
\fBDL\fR \"</dt>
Descending - Left Justified (Alphabetic)
.\"</dd>
.TP 10\"<dt>
\fBAR\fR \"</dt>
Ascending  - Right Justified (Numeric/Natural)
.\"</dd>
.TP 10\"<dt>
\fBDR\fR \"</dt>
Descending - Right Justified (Numeric/Natural)
.\"</dd>
.PD \"</dl>
.PP \"<p>
.PP \"<p>
\fBExample:\fR
.EX \"<code>
var v1 = "f1^10]20]2]1^ww]xx]yy]zz^f3^f4"_var;  // fields 2 and 3 are parallel multivalues and currently unordered.
sortarray(v1, "2]3"_var, "AR"); // v1 -> "f1^1]2]10]20^zz]yy]ww]xx^f3^f4"_var
.EE \"</code>
.sp 1 \"</p>
.sp 1 \"</p>


.SH 10. RECORD LOCKING
.SH

.SS
if (lockrecord(filename, io file, keyx, recordx, waitsecs = 0, allowduplicate = false)) ...
.PP \"<p>
Does not actually return record
.sp 1 \"</p>


.SS
if (lockrecord(filename, io file, keyx)) ...



.SS
if (unlockrecord(filename, io file, key)) ...



.SS
if (unlockrecord()) ...




